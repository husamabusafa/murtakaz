
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model UserPreference
 * 
 */
export type UserPreference = $Result.DefaultSelection<Prisma.$UserPreferencePayload>
/**
 * Model ChangeRequest
 * 
 */
export type ChangeRequest = $Result.DefaultSelection<Prisma.$ChangeRequestPayload>
/**
 * Model ChangeApproval
 * 
 */
export type ChangeApproval = $Result.DefaultSelection<Prisma.$ChangeApprovalPayload>
/**
 * Model NodeType
 * 
 */
export type NodeType = $Result.DefaultSelection<Prisma.$NodeTypePayload>
/**
 * Model Node
 * 
 */
export type Node = $Result.DefaultSelection<Prisma.$NodePayload>
/**
 * Model NodeAssignment
 * 
 */
export type NodeAssignment = $Result.DefaultSelection<Prisma.$NodeAssignmentPayload>
/**
 * Model NodeDependency
 * 
 */
export type NodeDependency = $Result.DefaultSelection<Prisma.$NodeDependencyPayload>
/**
 * Model KpiDefinition
 * 
 */
export type KpiDefinition = $Result.DefaultSelection<Prisma.$KpiDefinitionPayload>
/**
 * Model KpiVariable
 * 
 */
export type KpiVariable = $Result.DefaultSelection<Prisma.$KpiVariablePayload>
/**
 * Model KpiValuePeriod
 * 
 */
export type KpiValuePeriod = $Result.DefaultSelection<Prisma.$KpiValuePeriodPayload>
/**
 * Model KpiVariableValue
 * 
 */
export type KpiVariableValue = $Result.DefaultSelection<Prisma.$KpiVariableValuePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  EXECUTIVE: 'EXECUTIVE',
  PMO: 'PMO',
  MANAGER: 'MANAGER',
  EMPLOYEE: 'EMPLOYEE'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Status: {
  PLANNED: 'PLANNED',
  ACTIVE: 'ACTIVE',
  AT_RISK: 'AT_RISK',
  COMPLETED: 'COMPLETED'
};

export type Status = (typeof Status)[keyof typeof Status]


export const ApprovalStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ApprovalStatus = (typeof ApprovalStatus)[keyof typeof ApprovalStatus]


export const NodeTypeCode: {
  STRATEGY: 'STRATEGY',
  PILLAR: 'PILLAR',
  OBJECTIVE: 'OBJECTIVE',
  INITIATIVE: 'INITIATIVE',
  PROJECT: 'PROJECT',
  TASK: 'TASK'
};

export type NodeTypeCode = (typeof NodeTypeCode)[keyof typeof NodeTypeCode]


export const NodeAssignmentRole: {
  OWNER: 'OWNER',
  CONTRIBUTOR: 'CONTRIBUTOR',
  REVIEWER: 'REVIEWER',
  APPROVER: 'APPROVER'
};

export type NodeAssignmentRole = (typeof NodeAssignmentRole)[keyof typeof NodeAssignmentRole]


export const KpiPeriodType: {
  MONTHLY: 'MONTHLY',
  QUARTERLY: 'QUARTERLY',
  YEARLY: 'YEARLY'
};

export type KpiPeriodType = (typeof KpiPeriodType)[keyof typeof KpiPeriodType]


export const KpiVariableDataType: {
  NUMBER: 'NUMBER',
  PERCENTAGE: 'PERCENTAGE'
};

export type KpiVariableDataType = (typeof KpiVariableDataType)[keyof typeof KpiVariableDataType]


export const KpiDefinitionStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type KpiDefinitionStatus = (typeof KpiDefinitionStatus)[keyof typeof KpiDefinitionStatus]


export const KpiValueStatus: {
  DRAFT: 'DRAFT',
  SUBMITTED: 'SUBMITTED',
  APPROVED: 'APPROVED',
  LOCKED: 'LOCKED'
};

export type KpiValueStatus = (typeof KpiValueStatus)[keyof typeof KpiValueStatus]


export const KpiDirection: {
  INCREASE_IS_GOOD: 'INCREASE_IS_GOOD',
  DECREASE_IS_GOOD: 'DECREASE_IS_GOOD'
};

export type KpiDirection = (typeof KpiDirection)[keyof typeof KpiDirection]


export const KpiAggregationMethod: {
  LAST_VALUE: 'LAST_VALUE',
  SUM: 'SUM',
  AVERAGE: 'AVERAGE',
  MIN: 'MIN',
  MAX: 'MAX'
};

export type KpiAggregationMethod = (typeof KpiAggregationMethod)[keyof typeof KpiAggregationMethod]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type ApprovalStatus = $Enums.ApprovalStatus

export const ApprovalStatus: typeof $Enums.ApprovalStatus

export type NodeTypeCode = $Enums.NodeTypeCode

export const NodeTypeCode: typeof $Enums.NodeTypeCode

export type NodeAssignmentRole = $Enums.NodeAssignmentRole

export const NodeAssignmentRole: typeof $Enums.NodeAssignmentRole

export type KpiPeriodType = $Enums.KpiPeriodType

export const KpiPeriodType: typeof $Enums.KpiPeriodType

export type KpiVariableDataType = $Enums.KpiVariableDataType

export const KpiVariableDataType: typeof $Enums.KpiVariableDataType

export type KpiDefinitionStatus = $Enums.KpiDefinitionStatus

export const KpiDefinitionStatus: typeof $Enums.KpiDefinitionStatus

export type KpiValueStatus = $Enums.KpiValueStatus

export const KpiValueStatus: typeof $Enums.KpiValueStatus

export type KpiDirection = $Enums.KpiDirection

export const KpiDirection: typeof $Enums.KpiDirection

export type KpiAggregationMethod = $Enums.KpiAggregationMethod

export const KpiAggregationMethod: typeof $Enums.KpiAggregationMethod

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Organizations
 * const organizations = await prisma.organization.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Organizations
   * const organizations = await prisma.organization.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPreference`: Exposes CRUD operations for the **UserPreference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPreferences
    * const userPreferences = await prisma.userPreference.findMany()
    * ```
    */
  get userPreference(): Prisma.UserPreferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.changeRequest`: Exposes CRUD operations for the **ChangeRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChangeRequests
    * const changeRequests = await prisma.changeRequest.findMany()
    * ```
    */
  get changeRequest(): Prisma.ChangeRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.changeApproval`: Exposes CRUD operations for the **ChangeApproval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChangeApprovals
    * const changeApprovals = await prisma.changeApproval.findMany()
    * ```
    */
  get changeApproval(): Prisma.ChangeApprovalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nodeType`: Exposes CRUD operations for the **NodeType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NodeTypes
    * const nodeTypes = await prisma.nodeType.findMany()
    * ```
    */
  get nodeType(): Prisma.NodeTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.node`: Exposes CRUD operations for the **Node** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Nodes
    * const nodes = await prisma.node.findMany()
    * ```
    */
  get node(): Prisma.NodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nodeAssignment`: Exposes CRUD operations for the **NodeAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NodeAssignments
    * const nodeAssignments = await prisma.nodeAssignment.findMany()
    * ```
    */
  get nodeAssignment(): Prisma.NodeAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nodeDependency`: Exposes CRUD operations for the **NodeDependency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NodeDependencies
    * const nodeDependencies = await prisma.nodeDependency.findMany()
    * ```
    */
  get nodeDependency(): Prisma.NodeDependencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kpiDefinition`: Exposes CRUD operations for the **KpiDefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KpiDefinitions
    * const kpiDefinitions = await prisma.kpiDefinition.findMany()
    * ```
    */
  get kpiDefinition(): Prisma.KpiDefinitionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kpiVariable`: Exposes CRUD operations for the **KpiVariable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KpiVariables
    * const kpiVariables = await prisma.kpiVariable.findMany()
    * ```
    */
  get kpiVariable(): Prisma.KpiVariableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kpiValuePeriod`: Exposes CRUD operations for the **KpiValuePeriod** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KpiValuePeriods
    * const kpiValuePeriods = await prisma.kpiValuePeriod.findMany()
    * ```
    */
  get kpiValuePeriod(): Prisma.KpiValuePeriodDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kpiVariableValue`: Exposes CRUD operations for the **KpiVariableValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KpiVariableValues
    * const kpiVariableValues = await prisma.kpiVariableValue.findMany()
    * ```
    */
  get kpiVariableValue(): Prisma.KpiVariableValueDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.1
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Organization: 'Organization',
    Department: 'Department',
    User: 'User',
    Account: 'Account',
    Session: 'Session',
    Verification: 'Verification',
    UserPreference: 'UserPreference',
    ChangeRequest: 'ChangeRequest',
    ChangeApproval: 'ChangeApproval',
    NodeType: 'NodeType',
    Node: 'Node',
    NodeAssignment: 'NodeAssignment',
    NodeDependency: 'NodeDependency',
    KpiDefinition: 'KpiDefinition',
    KpiVariable: 'KpiVariable',
    KpiValuePeriod: 'KpiValuePeriod',
    KpiVariableValue: 'KpiVariableValue'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "organization" | "department" | "user" | "account" | "session" | "verification" | "userPreference" | "changeRequest" | "changeApproval" | "nodeType" | "node" | "nodeAssignment" | "nodeDependency" | "kpiDefinition" | "kpiVariable" | "kpiValuePeriod" | "kpiVariableValue"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      UserPreference: {
        payload: Prisma.$UserPreferencePayload<ExtArgs>
        fields: Prisma.UserPreferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPreferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPreferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          findFirst: {
            args: Prisma.UserPreferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPreferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          findMany: {
            args: Prisma.UserPreferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>[]
          }
          create: {
            args: Prisma.UserPreferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          createMany: {
            args: Prisma.UserPreferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPreferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>[]
          }
          delete: {
            args: Prisma.UserPreferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          update: {
            args: Prisma.UserPreferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          deleteMany: {
            args: Prisma.UserPreferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPreferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPreferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>[]
          }
          upsert: {
            args: Prisma.UserPreferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencePayload>
          }
          aggregate: {
            args: Prisma.UserPreferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPreference>
          }
          groupBy: {
            args: Prisma.UserPreferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPreferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPreferenceCountArgs<ExtArgs>
            result: $Utils.Optional<UserPreferenceCountAggregateOutputType> | number
          }
        }
      }
      ChangeRequest: {
        payload: Prisma.$ChangeRequestPayload<ExtArgs>
        fields: Prisma.ChangeRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChangeRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChangeRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>
          }
          findFirst: {
            args: Prisma.ChangeRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChangeRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>
          }
          findMany: {
            args: Prisma.ChangeRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>[]
          }
          create: {
            args: Prisma.ChangeRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>
          }
          createMany: {
            args: Prisma.ChangeRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChangeRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>[]
          }
          delete: {
            args: Prisma.ChangeRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>
          }
          update: {
            args: Prisma.ChangeRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>
          }
          deleteMany: {
            args: Prisma.ChangeRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChangeRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChangeRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>[]
          }
          upsert: {
            args: Prisma.ChangeRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeRequestPayload>
          }
          aggregate: {
            args: Prisma.ChangeRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChangeRequest>
          }
          groupBy: {
            args: Prisma.ChangeRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChangeRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChangeRequestCountArgs<ExtArgs>
            result: $Utils.Optional<ChangeRequestCountAggregateOutputType> | number
          }
        }
      }
      ChangeApproval: {
        payload: Prisma.$ChangeApprovalPayload<ExtArgs>
        fields: Prisma.ChangeApprovalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChangeApprovalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeApprovalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChangeApprovalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeApprovalPayload>
          }
          findFirst: {
            args: Prisma.ChangeApprovalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeApprovalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChangeApprovalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeApprovalPayload>
          }
          findMany: {
            args: Prisma.ChangeApprovalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeApprovalPayload>[]
          }
          create: {
            args: Prisma.ChangeApprovalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeApprovalPayload>
          }
          createMany: {
            args: Prisma.ChangeApprovalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChangeApprovalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeApprovalPayload>[]
          }
          delete: {
            args: Prisma.ChangeApprovalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeApprovalPayload>
          }
          update: {
            args: Prisma.ChangeApprovalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeApprovalPayload>
          }
          deleteMany: {
            args: Prisma.ChangeApprovalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChangeApprovalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChangeApprovalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeApprovalPayload>[]
          }
          upsert: {
            args: Prisma.ChangeApprovalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChangeApprovalPayload>
          }
          aggregate: {
            args: Prisma.ChangeApprovalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChangeApproval>
          }
          groupBy: {
            args: Prisma.ChangeApprovalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChangeApprovalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChangeApprovalCountArgs<ExtArgs>
            result: $Utils.Optional<ChangeApprovalCountAggregateOutputType> | number
          }
        }
      }
      NodeType: {
        payload: Prisma.$NodeTypePayload<ExtArgs>
        fields: Prisma.NodeTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NodeTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NodeTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeTypePayload>
          }
          findFirst: {
            args: Prisma.NodeTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NodeTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeTypePayload>
          }
          findMany: {
            args: Prisma.NodeTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeTypePayload>[]
          }
          create: {
            args: Prisma.NodeTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeTypePayload>
          }
          createMany: {
            args: Prisma.NodeTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NodeTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeTypePayload>[]
          }
          delete: {
            args: Prisma.NodeTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeTypePayload>
          }
          update: {
            args: Prisma.NodeTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeTypePayload>
          }
          deleteMany: {
            args: Prisma.NodeTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NodeTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NodeTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeTypePayload>[]
          }
          upsert: {
            args: Prisma.NodeTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeTypePayload>
          }
          aggregate: {
            args: Prisma.NodeTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNodeType>
          }
          groupBy: {
            args: Prisma.NodeTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<NodeTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.NodeTypeCountArgs<ExtArgs>
            result: $Utils.Optional<NodeTypeCountAggregateOutputType> | number
          }
        }
      }
      Node: {
        payload: Prisma.$NodePayload<ExtArgs>
        fields: Prisma.NodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>
          }
          findFirst: {
            args: Prisma.NodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>
          }
          findMany: {
            args: Prisma.NodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>[]
          }
          create: {
            args: Prisma.NodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>
          }
          createMany: {
            args: Prisma.NodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>[]
          }
          delete: {
            args: Prisma.NodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>
          }
          update: {
            args: Prisma.NodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>
          }
          deleteMany: {
            args: Prisma.NodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>[]
          }
          upsert: {
            args: Prisma.NodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodePayload>
          }
          aggregate: {
            args: Prisma.NodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNode>
          }
          groupBy: {
            args: Prisma.NodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<NodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.NodeCountArgs<ExtArgs>
            result: $Utils.Optional<NodeCountAggregateOutputType> | number
          }
        }
      }
      NodeAssignment: {
        payload: Prisma.$NodeAssignmentPayload<ExtArgs>
        fields: Prisma.NodeAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NodeAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NodeAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeAssignmentPayload>
          }
          findFirst: {
            args: Prisma.NodeAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NodeAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeAssignmentPayload>
          }
          findMany: {
            args: Prisma.NodeAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeAssignmentPayload>[]
          }
          create: {
            args: Prisma.NodeAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeAssignmentPayload>
          }
          createMany: {
            args: Prisma.NodeAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NodeAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeAssignmentPayload>[]
          }
          delete: {
            args: Prisma.NodeAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeAssignmentPayload>
          }
          update: {
            args: Prisma.NodeAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.NodeAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NodeAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NodeAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.NodeAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeAssignmentPayload>
          }
          aggregate: {
            args: Prisma.NodeAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNodeAssignment>
          }
          groupBy: {
            args: Prisma.NodeAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<NodeAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.NodeAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<NodeAssignmentCountAggregateOutputType> | number
          }
        }
      }
      NodeDependency: {
        payload: Prisma.$NodeDependencyPayload<ExtArgs>
        fields: Prisma.NodeDependencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NodeDependencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeDependencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NodeDependencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeDependencyPayload>
          }
          findFirst: {
            args: Prisma.NodeDependencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeDependencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NodeDependencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeDependencyPayload>
          }
          findMany: {
            args: Prisma.NodeDependencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeDependencyPayload>[]
          }
          create: {
            args: Prisma.NodeDependencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeDependencyPayload>
          }
          createMany: {
            args: Prisma.NodeDependencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NodeDependencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeDependencyPayload>[]
          }
          delete: {
            args: Prisma.NodeDependencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeDependencyPayload>
          }
          update: {
            args: Prisma.NodeDependencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeDependencyPayload>
          }
          deleteMany: {
            args: Prisma.NodeDependencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NodeDependencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NodeDependencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeDependencyPayload>[]
          }
          upsert: {
            args: Prisma.NodeDependencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NodeDependencyPayload>
          }
          aggregate: {
            args: Prisma.NodeDependencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNodeDependency>
          }
          groupBy: {
            args: Prisma.NodeDependencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<NodeDependencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.NodeDependencyCountArgs<ExtArgs>
            result: $Utils.Optional<NodeDependencyCountAggregateOutputType> | number
          }
        }
      }
      KpiDefinition: {
        payload: Prisma.$KpiDefinitionPayload<ExtArgs>
        fields: Prisma.KpiDefinitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KpiDefinitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiDefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KpiDefinitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiDefinitionPayload>
          }
          findFirst: {
            args: Prisma.KpiDefinitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiDefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KpiDefinitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiDefinitionPayload>
          }
          findMany: {
            args: Prisma.KpiDefinitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiDefinitionPayload>[]
          }
          create: {
            args: Prisma.KpiDefinitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiDefinitionPayload>
          }
          createMany: {
            args: Prisma.KpiDefinitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KpiDefinitionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiDefinitionPayload>[]
          }
          delete: {
            args: Prisma.KpiDefinitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiDefinitionPayload>
          }
          update: {
            args: Prisma.KpiDefinitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiDefinitionPayload>
          }
          deleteMany: {
            args: Prisma.KpiDefinitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KpiDefinitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KpiDefinitionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiDefinitionPayload>[]
          }
          upsert: {
            args: Prisma.KpiDefinitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiDefinitionPayload>
          }
          aggregate: {
            args: Prisma.KpiDefinitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKpiDefinition>
          }
          groupBy: {
            args: Prisma.KpiDefinitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<KpiDefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.KpiDefinitionCountArgs<ExtArgs>
            result: $Utils.Optional<KpiDefinitionCountAggregateOutputType> | number
          }
        }
      }
      KpiVariable: {
        payload: Prisma.$KpiVariablePayload<ExtArgs>
        fields: Prisma.KpiVariableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KpiVariableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KpiVariableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariablePayload>
          }
          findFirst: {
            args: Prisma.KpiVariableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KpiVariableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariablePayload>
          }
          findMany: {
            args: Prisma.KpiVariableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariablePayload>[]
          }
          create: {
            args: Prisma.KpiVariableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariablePayload>
          }
          createMany: {
            args: Prisma.KpiVariableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KpiVariableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariablePayload>[]
          }
          delete: {
            args: Prisma.KpiVariableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariablePayload>
          }
          update: {
            args: Prisma.KpiVariableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariablePayload>
          }
          deleteMany: {
            args: Prisma.KpiVariableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KpiVariableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KpiVariableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariablePayload>[]
          }
          upsert: {
            args: Prisma.KpiVariableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariablePayload>
          }
          aggregate: {
            args: Prisma.KpiVariableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKpiVariable>
          }
          groupBy: {
            args: Prisma.KpiVariableGroupByArgs<ExtArgs>
            result: $Utils.Optional<KpiVariableGroupByOutputType>[]
          }
          count: {
            args: Prisma.KpiVariableCountArgs<ExtArgs>
            result: $Utils.Optional<KpiVariableCountAggregateOutputType> | number
          }
        }
      }
      KpiValuePeriod: {
        payload: Prisma.$KpiValuePeriodPayload<ExtArgs>
        fields: Prisma.KpiValuePeriodFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KpiValuePeriodFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiValuePeriodPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KpiValuePeriodFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiValuePeriodPayload>
          }
          findFirst: {
            args: Prisma.KpiValuePeriodFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiValuePeriodPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KpiValuePeriodFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiValuePeriodPayload>
          }
          findMany: {
            args: Prisma.KpiValuePeriodFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiValuePeriodPayload>[]
          }
          create: {
            args: Prisma.KpiValuePeriodCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiValuePeriodPayload>
          }
          createMany: {
            args: Prisma.KpiValuePeriodCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KpiValuePeriodCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiValuePeriodPayload>[]
          }
          delete: {
            args: Prisma.KpiValuePeriodDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiValuePeriodPayload>
          }
          update: {
            args: Prisma.KpiValuePeriodUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiValuePeriodPayload>
          }
          deleteMany: {
            args: Prisma.KpiValuePeriodDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KpiValuePeriodUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KpiValuePeriodUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiValuePeriodPayload>[]
          }
          upsert: {
            args: Prisma.KpiValuePeriodUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiValuePeriodPayload>
          }
          aggregate: {
            args: Prisma.KpiValuePeriodAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKpiValuePeriod>
          }
          groupBy: {
            args: Prisma.KpiValuePeriodGroupByArgs<ExtArgs>
            result: $Utils.Optional<KpiValuePeriodGroupByOutputType>[]
          }
          count: {
            args: Prisma.KpiValuePeriodCountArgs<ExtArgs>
            result: $Utils.Optional<KpiValuePeriodCountAggregateOutputType> | number
          }
        }
      }
      KpiVariableValue: {
        payload: Prisma.$KpiVariableValuePayload<ExtArgs>
        fields: Prisma.KpiVariableValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KpiVariableValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariableValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KpiVariableValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariableValuePayload>
          }
          findFirst: {
            args: Prisma.KpiVariableValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariableValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KpiVariableValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariableValuePayload>
          }
          findMany: {
            args: Prisma.KpiVariableValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariableValuePayload>[]
          }
          create: {
            args: Prisma.KpiVariableValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariableValuePayload>
          }
          createMany: {
            args: Prisma.KpiVariableValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KpiVariableValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariableValuePayload>[]
          }
          delete: {
            args: Prisma.KpiVariableValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariableValuePayload>
          }
          update: {
            args: Prisma.KpiVariableValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariableValuePayload>
          }
          deleteMany: {
            args: Prisma.KpiVariableValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KpiVariableValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KpiVariableValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariableValuePayload>[]
          }
          upsert: {
            args: Prisma.KpiVariableValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KpiVariableValuePayload>
          }
          aggregate: {
            args: Prisma.KpiVariableValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKpiVariableValue>
          }
          groupBy: {
            args: Prisma.KpiVariableValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<KpiVariableValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.KpiVariableValueCountArgs<ExtArgs>
            result: $Utils.Optional<KpiVariableValueCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    organization?: OrganizationOmit
    department?: DepartmentOmit
    user?: UserOmit
    account?: AccountOmit
    session?: SessionOmit
    verification?: VerificationOmit
    userPreference?: UserPreferenceOmit
    changeRequest?: ChangeRequestOmit
    changeApproval?: ChangeApprovalOmit
    nodeType?: NodeTypeOmit
    node?: NodeOmit
    nodeAssignment?: NodeAssignmentOmit
    nodeDependency?: NodeDependencyOmit
    kpiDefinition?: KpiDefinitionOmit
    kpiVariable?: KpiVariableOmit
    kpiValuePeriod?: KpiValuePeriodOmit
    kpiVariableValue?: KpiVariableValueOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    users: number
    departments: number
    nodes: number
    kpis: number
    changeRequests: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | OrganizationCountOutputTypeCountUsersArgs
    departments?: boolean | OrganizationCountOutputTypeCountDepartmentsArgs
    nodes?: boolean | OrganizationCountOutputTypeCountNodesArgs
    kpis?: boolean | OrganizationCountOutputTypeCountKpisArgs
    changeRequests?: boolean | OrganizationCountOutputTypeCountChangeRequestsArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountKpisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KpiDefinitionWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountChangeRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeRequestWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    children: number
    users: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | DepartmentCountOutputTypeCountChildrenArgs
    users?: boolean | DepartmentCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    directReports: number
    managedDepartments: number
    sessions: number
    accounts: number
    approvals: number
    changeRequests: number
    ownedNodes: number
    nodeAssignments: number
    kpiValuesEntered: number
    kpiValuesApproved: number
    ownedKpis: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    directReports?: boolean | UserCountOutputTypeCountDirectReportsArgs
    managedDepartments?: boolean | UserCountOutputTypeCountManagedDepartmentsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    approvals?: boolean | UserCountOutputTypeCountApprovalsArgs
    changeRequests?: boolean | UserCountOutputTypeCountChangeRequestsArgs
    ownedNodes?: boolean | UserCountOutputTypeCountOwnedNodesArgs
    nodeAssignments?: boolean | UserCountOutputTypeCountNodeAssignmentsArgs
    kpiValuesEntered?: boolean | UserCountOutputTypeCountKpiValuesEnteredArgs
    kpiValuesApproved?: boolean | UserCountOutputTypeCountKpiValuesApprovedArgs
    ownedKpis?: boolean | UserCountOutputTypeCountOwnedKpisArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDirectReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountManagedDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeApprovalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChangeRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNodeAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountKpiValuesEnteredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KpiValuePeriodWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountKpiValuesApprovedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KpiValuePeriodWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedKpisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KpiDefinitionWhereInput
  }


  /**
   * Count Type ChangeRequestCountOutputType
   */

  export type ChangeRequestCountOutputType = {
    approvals: number
  }

  export type ChangeRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvals?: boolean | ChangeRequestCountOutputTypeCountApprovalsArgs
  }

  // Custom InputTypes
  /**
   * ChangeRequestCountOutputType without action
   */
  export type ChangeRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequestCountOutputType
     */
    select?: ChangeRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChangeRequestCountOutputType without action
   */
  export type ChangeRequestCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeApprovalWhereInput
  }


  /**
   * Count Type NodeTypeCountOutputType
   */

  export type NodeTypeCountOutputType = {
    nodes: number
  }

  export type NodeTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodes?: boolean | NodeTypeCountOutputTypeCountNodesArgs
  }

  // Custom InputTypes
  /**
   * NodeTypeCountOutputType without action
   */
  export type NodeTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeTypeCountOutputType
     */
    select?: NodeTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NodeTypeCountOutputType without action
   */
  export type NodeTypeCountOutputTypeCountNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeWhereInput
  }


  /**
   * Count Type NodeCountOutputType
   */

  export type NodeCountOutputType = {
    children: number
    assignments: number
    outgoingDeps: number
    incomingDeps: number
    kpis: number
  }

  export type NodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | NodeCountOutputTypeCountChildrenArgs
    assignments?: boolean | NodeCountOutputTypeCountAssignmentsArgs
    outgoingDeps?: boolean | NodeCountOutputTypeCountOutgoingDepsArgs
    incomingDeps?: boolean | NodeCountOutputTypeCountIncomingDepsArgs
    kpis?: boolean | NodeCountOutputTypeCountKpisArgs
  }

  // Custom InputTypes
  /**
   * NodeCountOutputType without action
   */
  export type NodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeCountOutputType
     */
    select?: NodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NodeCountOutputType without action
   */
  export type NodeCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeWhereInput
  }

  /**
   * NodeCountOutputType without action
   */
  export type NodeCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeAssignmentWhereInput
  }

  /**
   * NodeCountOutputType without action
   */
  export type NodeCountOutputTypeCountOutgoingDepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeDependencyWhereInput
  }

  /**
   * NodeCountOutputType without action
   */
  export type NodeCountOutputTypeCountIncomingDepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeDependencyWhereInput
  }

  /**
   * NodeCountOutputType without action
   */
  export type NodeCountOutputTypeCountKpisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KpiDefinitionWhereInput
  }


  /**
   * Count Type KpiDefinitionCountOutputType
   */

  export type KpiDefinitionCountOutputType = {
    variables: number
    values: number
  }

  export type KpiDefinitionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variables?: boolean | KpiDefinitionCountOutputTypeCountVariablesArgs
    values?: boolean | KpiDefinitionCountOutputTypeCountValuesArgs
  }

  // Custom InputTypes
  /**
   * KpiDefinitionCountOutputType without action
   */
  export type KpiDefinitionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiDefinitionCountOutputType
     */
    select?: KpiDefinitionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KpiDefinitionCountOutputType without action
   */
  export type KpiDefinitionCountOutputTypeCountVariablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KpiVariableWhereInput
  }

  /**
   * KpiDefinitionCountOutputType without action
   */
  export type KpiDefinitionCountOutputTypeCountValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KpiValuePeriodWhereInput
  }


  /**
   * Count Type KpiVariableCountOutputType
   */

  export type KpiVariableCountOutputType = {
    values: number
  }

  export type KpiVariableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    values?: boolean | KpiVariableCountOutputTypeCountValuesArgs
  }

  // Custom InputTypes
  /**
   * KpiVariableCountOutputType without action
   */
  export type KpiVariableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariableCountOutputType
     */
    select?: KpiVariableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KpiVariableCountOutputType without action
   */
  export type KpiVariableCountOutputTypeCountValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KpiVariableValueWhereInput
  }


  /**
   * Count Type KpiValuePeriodCountOutputType
   */

  export type KpiValuePeriodCountOutputType = {
    variableValues: number
  }

  export type KpiValuePeriodCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variableValues?: boolean | KpiValuePeriodCountOutputTypeCountVariableValuesArgs
  }

  // Custom InputTypes
  /**
   * KpiValuePeriodCountOutputType without action
   */
  export type KpiValuePeriodCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiValuePeriodCountOutputType
     */
    select?: KpiValuePeriodCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KpiValuePeriodCountOutputType without action
   */
  export type KpiValuePeriodCountOutputTypeCountVariableValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KpiVariableValueWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    domain: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    domain: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    users?: boolean | Organization$usersArgs<ExtArgs>
    departments?: boolean | Organization$departmentsArgs<ExtArgs>
    nodes?: boolean | Organization$nodesArgs<ExtArgs>
    kpis?: boolean | Organization$kpisArgs<ExtArgs>
    changeRequests?: boolean | Organization$changeRequestsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    domain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "domain" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Organization$usersArgs<ExtArgs>
    departments?: boolean | Organization$departmentsArgs<ExtArgs>
    nodes?: boolean | Organization$nodesArgs<ExtArgs>
    kpis?: boolean | Organization$kpisArgs<ExtArgs>
    changeRequests?: boolean | Organization$changeRequestsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      departments: Prisma.$DepartmentPayload<ExtArgs>[]
      nodes: Prisma.$NodePayload<ExtArgs>[]
      kpis: Prisma.$KpiDefinitionPayload<ExtArgs>[]
      changeRequests: Prisma.$ChangeRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      domain: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Organization$usersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departments<T extends Organization$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nodes<T extends Organization$nodesArgs<ExtArgs> = {}>(args?: Subset<T, Organization$nodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kpis<T extends Organization$kpisArgs<ExtArgs> = {}>(args?: Subset<T, Organization$kpisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    changeRequests<T extends Organization$changeRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$changeRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly domain: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
    readonly deletedAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization.users
   */
  export type Organization$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Organization.departments
   */
  export type Organization$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Organization.nodes
   */
  export type Organization$nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    where?: NodeWhereInput
    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]
    cursor?: NodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NodeScalarFieldEnum | NodeScalarFieldEnum[]
  }

  /**
   * Organization.kpis
   */
  export type Organization$kpisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiDefinition
     */
    select?: KpiDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiDefinition
     */
    omit?: KpiDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiDefinitionInclude<ExtArgs> | null
    where?: KpiDefinitionWhereInput
    orderBy?: KpiDefinitionOrderByWithRelationInput | KpiDefinitionOrderByWithRelationInput[]
    cursor?: KpiDefinitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KpiDefinitionScalarFieldEnum | KpiDefinitionScalarFieldEnum[]
  }

  /**
   * Organization.changeRequests
   */
  export type Organization$changeRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    where?: ChangeRequestWhereInput
    orderBy?: ChangeRequestOrderByWithRelationInput | ChangeRequestOrderByWithRelationInput[]
    cursor?: ChangeRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChangeRequestScalarFieldEnum | ChangeRequestScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    name: string | null
    code: string | null
    parentId: string | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    name: string | null
    code: string | null
    parentId: string | null
    managerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    orgId: number
    name: number
    code: number
    parentId: number
    managerId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    code?: true
    parentId?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    code?: true
    parentId?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    code?: true
    parentId?: true
    managerId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    orgId: string
    name: string
    code: string | null
    parentId: string | null
    managerId: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    code?: boolean
    parentId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    parent?: boolean | Department$parentArgs<ExtArgs>
    children?: boolean | Department$childrenArgs<ExtArgs>
    manager?: boolean | Department$managerArgs<ExtArgs>
    users?: boolean | Department$usersArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    code?: boolean
    parentId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    parent?: boolean | Department$parentArgs<ExtArgs>
    manager?: boolean | Department$managerArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    code?: boolean
    parentId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    parent?: boolean | Department$parentArgs<ExtArgs>
    manager?: boolean | Department$managerArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    orgId?: boolean
    name?: boolean
    code?: boolean
    parentId?: boolean
    managerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "name" | "code" | "parentId" | "managerId" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    parent?: boolean | Department$parentArgs<ExtArgs>
    children?: boolean | Department$childrenArgs<ExtArgs>
    manager?: boolean | Department$managerArgs<ExtArgs>
    users?: boolean | Department$usersArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    parent?: boolean | Department$parentArgs<ExtArgs>
    manager?: boolean | Department$managerArgs<ExtArgs>
  }
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    parent?: boolean | Department$parentArgs<ExtArgs>
    manager?: boolean | Department$managerArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      org: Prisma.$OrganizationPayload<ExtArgs>
      parent: Prisma.$DepartmentPayload<ExtArgs> | null
      children: Prisma.$DepartmentPayload<ExtArgs>[]
      manager: Prisma.$UserPayload<ExtArgs> | null
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      name: string
      code: string | null
      parentId: string | null
      managerId: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends Department$parentArgs<ExtArgs> = {}>(args?: Subset<T, Department$parentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Department$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Department$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    manager<T extends Department$managerArgs<ExtArgs> = {}>(args?: Subset<T, Department$managerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends Department$usersArgs<ExtArgs> = {}>(args?: Subset<T, Department$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly orgId: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly code: FieldRef<"Department", 'String'>
    readonly parentId: FieldRef<"Department", 'String'>
    readonly managerId: FieldRef<"Department", 'String'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
    readonly deletedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.parent
   */
  export type Department$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Department.children
   */
  export type Department$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department.manager
   */
  export type Department$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Department.users
   */
  export type Department$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    email: string | null
    emailVerified: boolean | null
    name: string | null
    role: $Enums.Role | null
    managerId: string | null
    departmentId: string | null
    title: string | null
    image: string | null
    hashedPassword: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    email: string | null
    emailVerified: boolean | null
    name: string | null
    role: $Enums.Role | null
    managerId: string | null
    departmentId: string | null
    title: string | null
    image: string | null
    hashedPassword: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    orgId: number
    email: number
    emailVerified: number
    name: number
    role: number
    managerId: number
    departmentId: number
    title: number
    image: number
    hashedPassword: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    orgId?: true
    email?: true
    emailVerified?: true
    name?: true
    role?: true
    managerId?: true
    departmentId?: true
    title?: true
    image?: true
    hashedPassword?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    orgId?: true
    email?: true
    emailVerified?: true
    name?: true
    role?: true
    managerId?: true
    departmentId?: true
    title?: true
    image?: true
    hashedPassword?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    orgId?: true
    email?: true
    emailVerified?: true
    name?: true
    role?: true
    managerId?: true
    departmentId?: true
    title?: true
    image?: true
    hashedPassword?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    orgId: string
    email: string
    emailVerified: boolean
    name: string
    role: $Enums.Role
    managerId: string | null
    departmentId: string | null
    title: string | null
    image: string | null
    hashedPassword: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    role?: boolean
    managerId?: boolean
    departmentId?: boolean
    title?: boolean
    image?: boolean
    hashedPassword?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    directReports?: boolean | User$directReportsArgs<ExtArgs>
    department?: boolean | User$departmentArgs<ExtArgs>
    managedDepartments?: boolean | User$managedDepartmentsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    approvals?: boolean | User$approvalsArgs<ExtArgs>
    changeRequests?: boolean | User$changeRequestsArgs<ExtArgs>
    ownedNodes?: boolean | User$ownedNodesArgs<ExtArgs>
    nodeAssignments?: boolean | User$nodeAssignmentsArgs<ExtArgs>
    kpiValuesEntered?: boolean | User$kpiValuesEnteredArgs<ExtArgs>
    kpiValuesApproved?: boolean | User$kpiValuesApprovedArgs<ExtArgs>
    ownedKpis?: boolean | User$ownedKpisArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    role?: boolean
    managerId?: boolean
    departmentId?: boolean
    title?: boolean
    image?: boolean
    hashedPassword?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    department?: boolean | User$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    role?: boolean
    managerId?: boolean
    departmentId?: boolean
    title?: boolean
    image?: boolean
    hashedPassword?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    department?: boolean | User$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    orgId?: boolean
    email?: boolean
    emailVerified?: boolean
    name?: boolean
    role?: boolean
    managerId?: boolean
    departmentId?: boolean
    title?: boolean
    image?: boolean
    hashedPassword?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "email" | "emailVerified" | "name" | "role" | "managerId" | "departmentId" | "title" | "image" | "hashedPassword" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    directReports?: boolean | User$directReportsArgs<ExtArgs>
    department?: boolean | User$departmentArgs<ExtArgs>
    managedDepartments?: boolean | User$managedDepartmentsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    preferences?: boolean | User$preferencesArgs<ExtArgs>
    approvals?: boolean | User$approvalsArgs<ExtArgs>
    changeRequests?: boolean | User$changeRequestsArgs<ExtArgs>
    ownedNodes?: boolean | User$ownedNodesArgs<ExtArgs>
    nodeAssignments?: boolean | User$nodeAssignmentsArgs<ExtArgs>
    kpiValuesEntered?: boolean | User$kpiValuesEnteredArgs<ExtArgs>
    kpiValuesApproved?: boolean | User$kpiValuesApprovedArgs<ExtArgs>
    ownedKpis?: boolean | User$ownedKpisArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    department?: boolean | User$departmentArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    manager?: boolean | User$managerArgs<ExtArgs>
    department?: boolean | User$departmentArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      org: Prisma.$OrganizationPayload<ExtArgs>
      manager: Prisma.$UserPayload<ExtArgs> | null
      directReports: Prisma.$UserPayload<ExtArgs>[]
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      managedDepartments: Prisma.$DepartmentPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      preferences: Prisma.$UserPreferencePayload<ExtArgs> | null
      approvals: Prisma.$ChangeApprovalPayload<ExtArgs>[]
      changeRequests: Prisma.$ChangeRequestPayload<ExtArgs>[]
      ownedNodes: Prisma.$NodePayload<ExtArgs>[]
      nodeAssignments: Prisma.$NodeAssignmentPayload<ExtArgs>[]
      kpiValuesEntered: Prisma.$KpiValuePeriodPayload<ExtArgs>[]
      kpiValuesApproved: Prisma.$KpiValuePeriodPayload<ExtArgs>[]
      ownedKpis: Prisma.$KpiDefinitionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      email: string
      emailVerified: boolean
      name: string
      role: $Enums.Role
      managerId: string | null
      departmentId: string | null
      title: string | null
      image: string | null
      hashedPassword: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    manager<T extends User$managerArgs<ExtArgs> = {}>(args?: Subset<T, User$managerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    directReports<T extends User$directReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$directReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    department<T extends User$departmentArgs<ExtArgs> = {}>(args?: Subset<T, User$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    managedDepartments<T extends User$managedDepartmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$managedDepartmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    preferences<T extends User$preferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$preferencesArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    approvals<T extends User$approvalsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeApprovalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    changeRequests<T extends User$changeRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$changeRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ownedNodes<T extends User$ownedNodesArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedNodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nodeAssignments<T extends User$nodeAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$nodeAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kpiValuesEntered<T extends User$kpiValuesEnteredArgs<ExtArgs> = {}>(args?: Subset<T, User$kpiValuesEnteredArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiValuePeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kpiValuesApproved<T extends User$kpiValuesApprovedArgs<ExtArgs> = {}>(args?: Subset<T, User$kpiValuesApprovedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiValuePeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ownedKpis<T extends User$ownedKpisArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedKpisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly orgId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly managerId: FieldRef<"User", 'String'>
    readonly departmentId: FieldRef<"User", 'String'>
    readonly title: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly hashedPassword: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.manager
   */
  export type User$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.directReports
   */
  export type User$directReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.department
   */
  export type User$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * User.managedDepartments
   */
  export type User$managedDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.preferences
   */
  export type User$preferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    where?: UserPreferenceWhereInput
  }

  /**
   * User.approvals
   */
  export type User$approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeApproval
     */
    select?: ChangeApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeApproval
     */
    omit?: ChangeApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeApprovalInclude<ExtArgs> | null
    where?: ChangeApprovalWhereInput
    orderBy?: ChangeApprovalOrderByWithRelationInput | ChangeApprovalOrderByWithRelationInput[]
    cursor?: ChangeApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChangeApprovalScalarFieldEnum | ChangeApprovalScalarFieldEnum[]
  }

  /**
   * User.changeRequests
   */
  export type User$changeRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    where?: ChangeRequestWhereInput
    orderBy?: ChangeRequestOrderByWithRelationInput | ChangeRequestOrderByWithRelationInput[]
    cursor?: ChangeRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChangeRequestScalarFieldEnum | ChangeRequestScalarFieldEnum[]
  }

  /**
   * User.ownedNodes
   */
  export type User$ownedNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    where?: NodeWhereInput
    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]
    cursor?: NodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NodeScalarFieldEnum | NodeScalarFieldEnum[]
  }

  /**
   * User.nodeAssignments
   */
  export type User$nodeAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeAssignment
     */
    select?: NodeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeAssignment
     */
    omit?: NodeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeAssignmentInclude<ExtArgs> | null
    where?: NodeAssignmentWhereInput
    orderBy?: NodeAssignmentOrderByWithRelationInput | NodeAssignmentOrderByWithRelationInput[]
    cursor?: NodeAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NodeAssignmentScalarFieldEnum | NodeAssignmentScalarFieldEnum[]
  }

  /**
   * User.kpiValuesEntered
   */
  export type User$kpiValuesEnteredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiValuePeriod
     */
    select?: KpiValuePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiValuePeriod
     */
    omit?: KpiValuePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiValuePeriodInclude<ExtArgs> | null
    where?: KpiValuePeriodWhereInput
    orderBy?: KpiValuePeriodOrderByWithRelationInput | KpiValuePeriodOrderByWithRelationInput[]
    cursor?: KpiValuePeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KpiValuePeriodScalarFieldEnum | KpiValuePeriodScalarFieldEnum[]
  }

  /**
   * User.kpiValuesApproved
   */
  export type User$kpiValuesApprovedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiValuePeriod
     */
    select?: KpiValuePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiValuePeriod
     */
    omit?: KpiValuePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiValuePeriodInclude<ExtArgs> | null
    where?: KpiValuePeriodWhereInput
    orderBy?: KpiValuePeriodOrderByWithRelationInput | KpiValuePeriodOrderByWithRelationInput[]
    cursor?: KpiValuePeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KpiValuePeriodScalarFieldEnum | KpiValuePeriodScalarFieldEnum[]
  }

  /**
   * User.ownedKpis
   */
  export type User$ownedKpisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiDefinition
     */
    select?: KpiDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiDefinition
     */
    omit?: KpiDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiDefinitionInclude<ExtArgs> | null
    where?: KpiDefinitionWhereInput
    orderBy?: KpiDefinitionOrderByWithRelationInput | KpiDefinitionOrderByWithRelationInput[]
    cursor?: KpiDefinitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KpiDefinitionScalarFieldEnum | KpiDefinitionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "providerId" | "userId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    expiresAt: number
    token: number
    createdAt: number
    updatedAt: number
    ipAddress: number
    userAgent: number
    userId: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    expiresAt: Date
    token: string
    createdAt: Date
    updatedAt: Date
    ipAddress: string | null
    userAgent: string | null
    userId: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expiresAt" | "token" | "createdAt" | "updatedAt" | "ipAddress" | "userAgent" | "userId", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expiresAt: Date
      token: string
      createdAt: Date
      updatedAt: Date
      ipAddress: string | null
      userAgent: string | null
      userId: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly token: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model UserPreference
   */

  export type AggregateUserPreference = {
    _count: UserPreferenceCountAggregateOutputType | null
    _min: UserPreferenceMinAggregateOutputType | null
    _max: UserPreferenceMaxAggregateOutputType | null
  }

  export type UserPreferenceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    locale: string | null
    theme: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPreferenceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    locale: string | null
    theme: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPreferenceCountAggregateOutputType = {
    id: number
    userId: number
    locale: number
    theme: number
    notifications: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPreferenceMinAggregateInputType = {
    id?: true
    userId?: true
    locale?: true
    theme?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPreferenceMaxAggregateInputType = {
    id?: true
    userId?: true
    locale?: true
    theme?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPreferenceCountAggregateInputType = {
    id?: true
    userId?: true
    locale?: true
    theme?: true
    notifications?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPreferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreference to aggregate.
     */
    where?: UserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPreferences
    **/
    _count?: true | UserPreferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPreferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPreferenceMaxAggregateInputType
  }

  export type GetUserPreferenceAggregateType<T extends UserPreferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPreference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPreference[P]>
      : GetScalarType<T[P], AggregateUserPreference[P]>
  }




  export type UserPreferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferenceWhereInput
    orderBy?: UserPreferenceOrderByWithAggregationInput | UserPreferenceOrderByWithAggregationInput[]
    by: UserPreferenceScalarFieldEnum[] | UserPreferenceScalarFieldEnum
    having?: UserPreferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPreferenceCountAggregateInputType | true
    _min?: UserPreferenceMinAggregateInputType
    _max?: UserPreferenceMaxAggregateInputType
  }

  export type UserPreferenceGroupByOutputType = {
    id: string
    userId: string
    locale: string
    theme: string
    notifications: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UserPreferenceCountAggregateOutputType | null
    _min: UserPreferenceMinAggregateOutputType | null
    _max: UserPreferenceMaxAggregateOutputType | null
  }

  type GetUserPreferenceGroupByPayload<T extends UserPreferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPreferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPreferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPreferenceGroupByOutputType[P]>
            : GetScalarType<T[P], UserPreferenceGroupByOutputType[P]>
        }
      >
    >


  export type UserPreferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locale?: boolean
    theme?: boolean
    notifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreference"]>

  export type UserPreferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locale?: boolean
    theme?: boolean
    notifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreference"]>

  export type UserPreferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locale?: boolean
    theme?: boolean
    notifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreference"]>

  export type UserPreferenceSelectScalar = {
    id?: boolean
    userId?: boolean
    locale?: boolean
    theme?: boolean
    notifications?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPreferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "locale" | "theme" | "notifications" | "createdAt" | "updatedAt", ExtArgs["result"]["userPreference"]>
  export type UserPreferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPreferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPreferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPreferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPreference"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      locale: string
      theme: string
      notifications: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPreference"]>
    composites: {}
  }

  type UserPreferenceGetPayload<S extends boolean | null | undefined | UserPreferenceDefaultArgs> = $Result.GetResult<Prisma.$UserPreferencePayload, S>

  type UserPreferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPreferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPreferenceCountAggregateInputType | true
    }

  export interface UserPreferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPreference'], meta: { name: 'UserPreference' } }
    /**
     * Find zero or one UserPreference that matches the filter.
     * @param {UserPreferenceFindUniqueArgs} args - Arguments to find a UserPreference
     * @example
     * // Get one UserPreference
     * const userPreference = await prisma.userPreference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPreferenceFindUniqueArgs>(args: SelectSubset<T, UserPreferenceFindUniqueArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPreference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPreferenceFindUniqueOrThrowArgs} args - Arguments to find a UserPreference
     * @example
     * // Get one UserPreference
     * const userPreference = await prisma.userPreference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPreferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPreferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceFindFirstArgs} args - Arguments to find a UserPreference
     * @example
     * // Get one UserPreference
     * const userPreference = await prisma.userPreference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPreferenceFindFirstArgs>(args?: SelectSubset<T, UserPreferenceFindFirstArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceFindFirstOrThrowArgs} args - Arguments to find a UserPreference
     * @example
     * // Get one UserPreference
     * const userPreference = await prisma.userPreference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPreferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPreferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPreferences
     * const userPreferences = await prisma.userPreference.findMany()
     * 
     * // Get first 10 UserPreferences
     * const userPreferences = await prisma.userPreference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPreferenceWithIdOnly = await prisma.userPreference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPreferenceFindManyArgs>(args?: SelectSubset<T, UserPreferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPreference.
     * @param {UserPreferenceCreateArgs} args - Arguments to create a UserPreference.
     * @example
     * // Create one UserPreference
     * const UserPreference = await prisma.userPreference.create({
     *   data: {
     *     // ... data to create a UserPreference
     *   }
     * })
     * 
     */
    create<T extends UserPreferenceCreateArgs>(args: SelectSubset<T, UserPreferenceCreateArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPreferences.
     * @param {UserPreferenceCreateManyArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreference = await prisma.userPreference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPreferenceCreateManyArgs>(args?: SelectSubset<T, UserPreferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPreferences and returns the data saved in the database.
     * @param {UserPreferenceCreateManyAndReturnArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreference = await prisma.userPreference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPreferences and only return the `id`
     * const userPreferenceWithIdOnly = await prisma.userPreference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPreferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPreferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPreference.
     * @param {UserPreferenceDeleteArgs} args - Arguments to delete one UserPreference.
     * @example
     * // Delete one UserPreference
     * const UserPreference = await prisma.userPreference.delete({
     *   where: {
     *     // ... filter to delete one UserPreference
     *   }
     * })
     * 
     */
    delete<T extends UserPreferenceDeleteArgs>(args: SelectSubset<T, UserPreferenceDeleteArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPreference.
     * @param {UserPreferenceUpdateArgs} args - Arguments to update one UserPreference.
     * @example
     * // Update one UserPreference
     * const userPreference = await prisma.userPreference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPreferenceUpdateArgs>(args: SelectSubset<T, UserPreferenceUpdateArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPreferences.
     * @param {UserPreferenceDeleteManyArgs} args - Arguments to filter UserPreferences to delete.
     * @example
     * // Delete a few UserPreferences
     * const { count } = await prisma.userPreference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPreferenceDeleteManyArgs>(args?: SelectSubset<T, UserPreferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPreferences
     * const userPreference = await prisma.userPreference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPreferenceUpdateManyArgs>(args: SelectSubset<T, UserPreferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences and returns the data updated in the database.
     * @param {UserPreferenceUpdateManyAndReturnArgs} args - Arguments to update many UserPreferences.
     * @example
     * // Update many UserPreferences
     * const userPreference = await prisma.userPreference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPreferences and only return the `id`
     * const userPreferenceWithIdOnly = await prisma.userPreference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPreferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPreferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPreference.
     * @param {UserPreferenceUpsertArgs} args - Arguments to update or create a UserPreference.
     * @example
     * // Update or create a UserPreference
     * const userPreference = await prisma.userPreference.upsert({
     *   create: {
     *     // ... data to create a UserPreference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPreference we want to update
     *   }
     * })
     */
    upsert<T extends UserPreferenceUpsertArgs>(args: SelectSubset<T, UserPreferenceUpsertArgs<ExtArgs>>): Prisma__UserPreferenceClient<$Result.GetResult<Prisma.$UserPreferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceCountArgs} args - Arguments to filter UserPreferences to count.
     * @example
     * // Count the number of UserPreferences
     * const count = await prisma.userPreference.count({
     *   where: {
     *     // ... the filter for the UserPreferences we want to count
     *   }
     * })
    **/
    count<T extends UserPreferenceCountArgs>(
      args?: Subset<T, UserPreferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPreferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPreferenceAggregateArgs>(args: Subset<T, UserPreferenceAggregateArgs>): Prisma.PrismaPromise<GetUserPreferenceAggregateType<T>>

    /**
     * Group by UserPreference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPreferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPreferenceGroupByArgs['orderBy'] }
        : { orderBy?: UserPreferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPreferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPreferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPreference model
   */
  readonly fields: UserPreferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPreference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPreferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPreference model
   */
  interface UserPreferenceFieldRefs {
    readonly id: FieldRef<"UserPreference", 'String'>
    readonly userId: FieldRef<"UserPreference", 'String'>
    readonly locale: FieldRef<"UserPreference", 'String'>
    readonly theme: FieldRef<"UserPreference", 'String'>
    readonly notifications: FieldRef<"UserPreference", 'Json'>
    readonly createdAt: FieldRef<"UserPreference", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPreference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPreference findUnique
   */
  export type UserPreferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreference to fetch.
     */
    where: UserPreferenceWhereUniqueInput
  }

  /**
   * UserPreference findUniqueOrThrow
   */
  export type UserPreferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreference to fetch.
     */
    where: UserPreferenceWhereUniqueInput
  }

  /**
   * UserPreference findFirst
   */
  export type UserPreferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreference to fetch.
     */
    where?: UserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferenceScalarFieldEnum | UserPreferenceScalarFieldEnum[]
  }

  /**
   * UserPreference findFirstOrThrow
   */
  export type UserPreferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreference to fetch.
     */
    where?: UserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferenceScalarFieldEnum | UserPreferenceScalarFieldEnum[]
  }

  /**
   * UserPreference findMany
   */
  export type UserPreferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferenceOrderByWithRelationInput | UserPreferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPreferences.
     */
    cursor?: UserPreferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    distinct?: UserPreferenceScalarFieldEnum | UserPreferenceScalarFieldEnum[]
  }

  /**
   * UserPreference create
   */
  export type UserPreferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPreference.
     */
    data: XOR<UserPreferenceCreateInput, UserPreferenceUncheckedCreateInput>
  }

  /**
   * UserPreference createMany
   */
  export type UserPreferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferenceCreateManyInput | UserPreferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPreference createManyAndReturn
   */
  export type UserPreferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferenceCreateManyInput | UserPreferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreference update
   */
  export type UserPreferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPreference.
     */
    data: XOR<UserPreferenceUpdateInput, UserPreferenceUncheckedUpdateInput>
    /**
     * Choose, which UserPreference to update.
     */
    where: UserPreferenceWhereUniqueInput
  }

  /**
   * UserPreference updateMany
   */
  export type UserPreferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferenceUpdateManyMutationInput, UserPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferenceWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
  }

  /**
   * UserPreference updateManyAndReturn
   */
  export type UserPreferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferenceUpdateManyMutationInput, UserPreferenceUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferenceWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreference upsert
   */
  export type UserPreferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPreference to update in case it exists.
     */
    where: UserPreferenceWhereUniqueInput
    /**
     * In case the UserPreference found by the `where` argument doesn't exist, create a new UserPreference with this data.
     */
    create: XOR<UserPreferenceCreateInput, UserPreferenceUncheckedCreateInput>
    /**
     * In case the UserPreference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPreferenceUpdateInput, UserPreferenceUncheckedUpdateInput>
  }

  /**
   * UserPreference delete
   */
  export type UserPreferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
    /**
     * Filter which UserPreference to delete.
     */
    where: UserPreferenceWhereUniqueInput
  }

  /**
   * UserPreference deleteMany
   */
  export type UserPreferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to delete
     */
    where?: UserPreferenceWhereInput
    /**
     * Limit how many UserPreferences to delete.
     */
    limit?: number
  }

  /**
   * UserPreference without action
   */
  export type UserPreferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreference
     */
    select?: UserPreferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreference
     */
    omit?: UserPreferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferenceInclude<ExtArgs> | null
  }


  /**
   * Model ChangeRequest
   */

  export type AggregateChangeRequest = {
    _count: ChangeRequestCountAggregateOutputType | null
    _min: ChangeRequestMinAggregateOutputType | null
    _max: ChangeRequestMaxAggregateOutputType | null
  }

  export type ChangeRequestMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    entityType: string | null
    entityId: string | null
    status: $Enums.ApprovalStatus | null
    requestedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    decidedAt: Date | null
    deletedAt: Date | null
  }

  export type ChangeRequestMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    entityType: string | null
    entityId: string | null
    status: $Enums.ApprovalStatus | null
    requestedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    decidedAt: Date | null
    deletedAt: Date | null
  }

  export type ChangeRequestCountAggregateOutputType = {
    id: number
    orgId: number
    entityType: number
    entityId: number
    payload: number
    status: number
    requestedBy: number
    createdAt: number
    updatedAt: number
    decidedAt: number
    deletedAt: number
    _all: number
  }


  export type ChangeRequestMinAggregateInputType = {
    id?: true
    orgId?: true
    entityType?: true
    entityId?: true
    status?: true
    requestedBy?: true
    createdAt?: true
    updatedAt?: true
    decidedAt?: true
    deletedAt?: true
  }

  export type ChangeRequestMaxAggregateInputType = {
    id?: true
    orgId?: true
    entityType?: true
    entityId?: true
    status?: true
    requestedBy?: true
    createdAt?: true
    updatedAt?: true
    decidedAt?: true
    deletedAt?: true
  }

  export type ChangeRequestCountAggregateInputType = {
    id?: true
    orgId?: true
    entityType?: true
    entityId?: true
    payload?: true
    status?: true
    requestedBy?: true
    createdAt?: true
    updatedAt?: true
    decidedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ChangeRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChangeRequest to aggregate.
     */
    where?: ChangeRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeRequests to fetch.
     */
    orderBy?: ChangeRequestOrderByWithRelationInput | ChangeRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChangeRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChangeRequests
    **/
    _count?: true | ChangeRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChangeRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChangeRequestMaxAggregateInputType
  }

  export type GetChangeRequestAggregateType<T extends ChangeRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateChangeRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChangeRequest[P]>
      : GetScalarType<T[P], AggregateChangeRequest[P]>
  }




  export type ChangeRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeRequestWhereInput
    orderBy?: ChangeRequestOrderByWithAggregationInput | ChangeRequestOrderByWithAggregationInput[]
    by: ChangeRequestScalarFieldEnum[] | ChangeRequestScalarFieldEnum
    having?: ChangeRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChangeRequestCountAggregateInputType | true
    _min?: ChangeRequestMinAggregateInputType
    _max?: ChangeRequestMaxAggregateInputType
  }

  export type ChangeRequestGroupByOutputType = {
    id: string
    orgId: string
    entityType: string
    entityId: string
    payload: JsonValue
    status: $Enums.ApprovalStatus
    requestedBy: string
    createdAt: Date
    updatedAt: Date
    decidedAt: Date | null
    deletedAt: Date | null
    _count: ChangeRequestCountAggregateOutputType | null
    _min: ChangeRequestMinAggregateOutputType | null
    _max: ChangeRequestMaxAggregateOutputType | null
  }

  type GetChangeRequestGroupByPayload<T extends ChangeRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChangeRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChangeRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChangeRequestGroupByOutputType[P]>
            : GetScalarType<T[P], ChangeRequestGroupByOutputType[P]>
        }
      >
    >


  export type ChangeRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    entityType?: boolean
    entityId?: boolean
    payload?: boolean
    status?: boolean
    requestedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    decidedAt?: boolean
    deletedAt?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
    approvals?: boolean | ChangeRequest$approvalsArgs<ExtArgs>
    _count?: boolean | ChangeRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["changeRequest"]>

  export type ChangeRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    entityType?: boolean
    entityId?: boolean
    payload?: boolean
    status?: boolean
    requestedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    decidedAt?: boolean
    deletedAt?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["changeRequest"]>

  export type ChangeRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    entityType?: boolean
    entityId?: boolean
    payload?: boolean
    status?: boolean
    requestedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    decidedAt?: boolean
    deletedAt?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["changeRequest"]>

  export type ChangeRequestSelectScalar = {
    id?: boolean
    orgId?: boolean
    entityType?: boolean
    entityId?: boolean
    payload?: boolean
    status?: boolean
    requestedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    decidedAt?: boolean
    deletedAt?: boolean
  }

  export type ChangeRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "entityType" | "entityId" | "payload" | "status" | "requestedBy" | "createdAt" | "updatedAt" | "decidedAt" | "deletedAt", ExtArgs["result"]["changeRequest"]>
  export type ChangeRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
    approvals?: boolean | ChangeRequest$approvalsArgs<ExtArgs>
    _count?: boolean | ChangeRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChangeRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChangeRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChangeRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChangeRequest"
    objects: {
      org: Prisma.$OrganizationPayload<ExtArgs>
      requester: Prisma.$UserPayload<ExtArgs>
      approvals: Prisma.$ChangeApprovalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      entityType: string
      entityId: string
      payload: Prisma.JsonValue
      status: $Enums.ApprovalStatus
      requestedBy: string
      createdAt: Date
      updatedAt: Date
      decidedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["changeRequest"]>
    composites: {}
  }

  type ChangeRequestGetPayload<S extends boolean | null | undefined | ChangeRequestDefaultArgs> = $Result.GetResult<Prisma.$ChangeRequestPayload, S>

  type ChangeRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChangeRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChangeRequestCountAggregateInputType | true
    }

  export interface ChangeRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChangeRequest'], meta: { name: 'ChangeRequest' } }
    /**
     * Find zero or one ChangeRequest that matches the filter.
     * @param {ChangeRequestFindUniqueArgs} args - Arguments to find a ChangeRequest
     * @example
     * // Get one ChangeRequest
     * const changeRequest = await prisma.changeRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChangeRequestFindUniqueArgs>(args: SelectSubset<T, ChangeRequestFindUniqueArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChangeRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChangeRequestFindUniqueOrThrowArgs} args - Arguments to find a ChangeRequest
     * @example
     * // Get one ChangeRequest
     * const changeRequest = await prisma.changeRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChangeRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, ChangeRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChangeRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeRequestFindFirstArgs} args - Arguments to find a ChangeRequest
     * @example
     * // Get one ChangeRequest
     * const changeRequest = await prisma.changeRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChangeRequestFindFirstArgs>(args?: SelectSubset<T, ChangeRequestFindFirstArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChangeRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeRequestFindFirstOrThrowArgs} args - Arguments to find a ChangeRequest
     * @example
     * // Get one ChangeRequest
     * const changeRequest = await prisma.changeRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChangeRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, ChangeRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChangeRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChangeRequests
     * const changeRequests = await prisma.changeRequest.findMany()
     * 
     * // Get first 10 ChangeRequests
     * const changeRequests = await prisma.changeRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const changeRequestWithIdOnly = await prisma.changeRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChangeRequestFindManyArgs>(args?: SelectSubset<T, ChangeRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChangeRequest.
     * @param {ChangeRequestCreateArgs} args - Arguments to create a ChangeRequest.
     * @example
     * // Create one ChangeRequest
     * const ChangeRequest = await prisma.changeRequest.create({
     *   data: {
     *     // ... data to create a ChangeRequest
     *   }
     * })
     * 
     */
    create<T extends ChangeRequestCreateArgs>(args: SelectSubset<T, ChangeRequestCreateArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChangeRequests.
     * @param {ChangeRequestCreateManyArgs} args - Arguments to create many ChangeRequests.
     * @example
     * // Create many ChangeRequests
     * const changeRequest = await prisma.changeRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChangeRequestCreateManyArgs>(args?: SelectSubset<T, ChangeRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChangeRequests and returns the data saved in the database.
     * @param {ChangeRequestCreateManyAndReturnArgs} args - Arguments to create many ChangeRequests.
     * @example
     * // Create many ChangeRequests
     * const changeRequest = await prisma.changeRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChangeRequests and only return the `id`
     * const changeRequestWithIdOnly = await prisma.changeRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChangeRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, ChangeRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChangeRequest.
     * @param {ChangeRequestDeleteArgs} args - Arguments to delete one ChangeRequest.
     * @example
     * // Delete one ChangeRequest
     * const ChangeRequest = await prisma.changeRequest.delete({
     *   where: {
     *     // ... filter to delete one ChangeRequest
     *   }
     * })
     * 
     */
    delete<T extends ChangeRequestDeleteArgs>(args: SelectSubset<T, ChangeRequestDeleteArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChangeRequest.
     * @param {ChangeRequestUpdateArgs} args - Arguments to update one ChangeRequest.
     * @example
     * // Update one ChangeRequest
     * const changeRequest = await prisma.changeRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChangeRequestUpdateArgs>(args: SelectSubset<T, ChangeRequestUpdateArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChangeRequests.
     * @param {ChangeRequestDeleteManyArgs} args - Arguments to filter ChangeRequests to delete.
     * @example
     * // Delete a few ChangeRequests
     * const { count } = await prisma.changeRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChangeRequestDeleteManyArgs>(args?: SelectSubset<T, ChangeRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChangeRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChangeRequests
     * const changeRequest = await prisma.changeRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChangeRequestUpdateManyArgs>(args: SelectSubset<T, ChangeRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChangeRequests and returns the data updated in the database.
     * @param {ChangeRequestUpdateManyAndReturnArgs} args - Arguments to update many ChangeRequests.
     * @example
     * // Update many ChangeRequests
     * const changeRequest = await prisma.changeRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChangeRequests and only return the `id`
     * const changeRequestWithIdOnly = await prisma.changeRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChangeRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, ChangeRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChangeRequest.
     * @param {ChangeRequestUpsertArgs} args - Arguments to update or create a ChangeRequest.
     * @example
     * // Update or create a ChangeRequest
     * const changeRequest = await prisma.changeRequest.upsert({
     *   create: {
     *     // ... data to create a ChangeRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChangeRequest we want to update
     *   }
     * })
     */
    upsert<T extends ChangeRequestUpsertArgs>(args: SelectSubset<T, ChangeRequestUpsertArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChangeRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeRequestCountArgs} args - Arguments to filter ChangeRequests to count.
     * @example
     * // Count the number of ChangeRequests
     * const count = await prisma.changeRequest.count({
     *   where: {
     *     // ... the filter for the ChangeRequests we want to count
     *   }
     * })
    **/
    count<T extends ChangeRequestCountArgs>(
      args?: Subset<T, ChangeRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChangeRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChangeRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChangeRequestAggregateArgs>(args: Subset<T, ChangeRequestAggregateArgs>): Prisma.PrismaPromise<GetChangeRequestAggregateType<T>>

    /**
     * Group by ChangeRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChangeRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChangeRequestGroupByArgs['orderBy'] }
        : { orderBy?: ChangeRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChangeRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChangeRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChangeRequest model
   */
  readonly fields: ChangeRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChangeRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChangeRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    requester<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approvals<T extends ChangeRequest$approvalsArgs<ExtArgs> = {}>(args?: Subset<T, ChangeRequest$approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeApprovalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChangeRequest model
   */
  interface ChangeRequestFieldRefs {
    readonly id: FieldRef<"ChangeRequest", 'String'>
    readonly orgId: FieldRef<"ChangeRequest", 'String'>
    readonly entityType: FieldRef<"ChangeRequest", 'String'>
    readonly entityId: FieldRef<"ChangeRequest", 'String'>
    readonly payload: FieldRef<"ChangeRequest", 'Json'>
    readonly status: FieldRef<"ChangeRequest", 'ApprovalStatus'>
    readonly requestedBy: FieldRef<"ChangeRequest", 'String'>
    readonly createdAt: FieldRef<"ChangeRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"ChangeRequest", 'DateTime'>
    readonly decidedAt: FieldRef<"ChangeRequest", 'DateTime'>
    readonly deletedAt: FieldRef<"ChangeRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChangeRequest findUnique
   */
  export type ChangeRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChangeRequest to fetch.
     */
    where: ChangeRequestWhereUniqueInput
  }

  /**
   * ChangeRequest findUniqueOrThrow
   */
  export type ChangeRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChangeRequest to fetch.
     */
    where: ChangeRequestWhereUniqueInput
  }

  /**
   * ChangeRequest findFirst
   */
  export type ChangeRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChangeRequest to fetch.
     */
    where?: ChangeRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeRequests to fetch.
     */
    orderBy?: ChangeRequestOrderByWithRelationInput | ChangeRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangeRequests.
     */
    cursor?: ChangeRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangeRequests.
     */
    distinct?: ChangeRequestScalarFieldEnum | ChangeRequestScalarFieldEnum[]
  }

  /**
   * ChangeRequest findFirstOrThrow
   */
  export type ChangeRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChangeRequest to fetch.
     */
    where?: ChangeRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeRequests to fetch.
     */
    orderBy?: ChangeRequestOrderByWithRelationInput | ChangeRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangeRequests.
     */
    cursor?: ChangeRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangeRequests.
     */
    distinct?: ChangeRequestScalarFieldEnum | ChangeRequestScalarFieldEnum[]
  }

  /**
   * ChangeRequest findMany
   */
  export type ChangeRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which ChangeRequests to fetch.
     */
    where?: ChangeRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeRequests to fetch.
     */
    orderBy?: ChangeRequestOrderByWithRelationInput | ChangeRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChangeRequests.
     */
    cursor?: ChangeRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeRequests.
     */
    skip?: number
    distinct?: ChangeRequestScalarFieldEnum | ChangeRequestScalarFieldEnum[]
  }

  /**
   * ChangeRequest create
   */
  export type ChangeRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a ChangeRequest.
     */
    data: XOR<ChangeRequestCreateInput, ChangeRequestUncheckedCreateInput>
  }

  /**
   * ChangeRequest createMany
   */
  export type ChangeRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChangeRequests.
     */
    data: ChangeRequestCreateManyInput | ChangeRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChangeRequest createManyAndReturn
   */
  export type ChangeRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * The data used to create many ChangeRequests.
     */
    data: ChangeRequestCreateManyInput | ChangeRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChangeRequest update
   */
  export type ChangeRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a ChangeRequest.
     */
    data: XOR<ChangeRequestUpdateInput, ChangeRequestUncheckedUpdateInput>
    /**
     * Choose, which ChangeRequest to update.
     */
    where: ChangeRequestWhereUniqueInput
  }

  /**
   * ChangeRequest updateMany
   */
  export type ChangeRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChangeRequests.
     */
    data: XOR<ChangeRequestUpdateManyMutationInput, ChangeRequestUncheckedUpdateManyInput>
    /**
     * Filter which ChangeRequests to update
     */
    where?: ChangeRequestWhereInput
    /**
     * Limit how many ChangeRequests to update.
     */
    limit?: number
  }

  /**
   * ChangeRequest updateManyAndReturn
   */
  export type ChangeRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * The data used to update ChangeRequests.
     */
    data: XOR<ChangeRequestUpdateManyMutationInput, ChangeRequestUncheckedUpdateManyInput>
    /**
     * Filter which ChangeRequests to update
     */
    where?: ChangeRequestWhereInput
    /**
     * Limit how many ChangeRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChangeRequest upsert
   */
  export type ChangeRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the ChangeRequest to update in case it exists.
     */
    where: ChangeRequestWhereUniqueInput
    /**
     * In case the ChangeRequest found by the `where` argument doesn't exist, create a new ChangeRequest with this data.
     */
    create: XOR<ChangeRequestCreateInput, ChangeRequestUncheckedCreateInput>
    /**
     * In case the ChangeRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChangeRequestUpdateInput, ChangeRequestUncheckedUpdateInput>
  }

  /**
   * ChangeRequest delete
   */
  export type ChangeRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
    /**
     * Filter which ChangeRequest to delete.
     */
    where: ChangeRequestWhereUniqueInput
  }

  /**
   * ChangeRequest deleteMany
   */
  export type ChangeRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChangeRequests to delete
     */
    where?: ChangeRequestWhereInput
    /**
     * Limit how many ChangeRequests to delete.
     */
    limit?: number
  }

  /**
   * ChangeRequest.approvals
   */
  export type ChangeRequest$approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeApproval
     */
    select?: ChangeApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeApproval
     */
    omit?: ChangeApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeApprovalInclude<ExtArgs> | null
    where?: ChangeApprovalWhereInput
    orderBy?: ChangeApprovalOrderByWithRelationInput | ChangeApprovalOrderByWithRelationInput[]
    cursor?: ChangeApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChangeApprovalScalarFieldEnum | ChangeApprovalScalarFieldEnum[]
  }

  /**
   * ChangeRequest without action
   */
  export type ChangeRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeRequest
     */
    select?: ChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeRequest
     */
    omit?: ChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeRequestInclude<ExtArgs> | null
  }


  /**
   * Model ChangeApproval
   */

  export type AggregateChangeApproval = {
    _count: ChangeApprovalCountAggregateOutputType | null
    _min: ChangeApprovalMinAggregateOutputType | null
    _max: ChangeApprovalMaxAggregateOutputType | null
  }

  export type ChangeApprovalMinAggregateOutputType = {
    id: string | null
    changeRequestId: string | null
    approverId: string | null
    status: $Enums.ApprovalStatus | null
    comment: string | null
    createdAt: Date | null
    decidedAt: Date | null
  }

  export type ChangeApprovalMaxAggregateOutputType = {
    id: string | null
    changeRequestId: string | null
    approverId: string | null
    status: $Enums.ApprovalStatus | null
    comment: string | null
    createdAt: Date | null
    decidedAt: Date | null
  }

  export type ChangeApprovalCountAggregateOutputType = {
    id: number
    changeRequestId: number
    approverId: number
    status: number
    comment: number
    createdAt: number
    decidedAt: number
    _all: number
  }


  export type ChangeApprovalMinAggregateInputType = {
    id?: true
    changeRequestId?: true
    approverId?: true
    status?: true
    comment?: true
    createdAt?: true
    decidedAt?: true
  }

  export type ChangeApprovalMaxAggregateInputType = {
    id?: true
    changeRequestId?: true
    approverId?: true
    status?: true
    comment?: true
    createdAt?: true
    decidedAt?: true
  }

  export type ChangeApprovalCountAggregateInputType = {
    id?: true
    changeRequestId?: true
    approverId?: true
    status?: true
    comment?: true
    createdAt?: true
    decidedAt?: true
    _all?: true
  }

  export type ChangeApprovalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChangeApproval to aggregate.
     */
    where?: ChangeApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeApprovals to fetch.
     */
    orderBy?: ChangeApprovalOrderByWithRelationInput | ChangeApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChangeApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChangeApprovals
    **/
    _count?: true | ChangeApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChangeApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChangeApprovalMaxAggregateInputType
  }

  export type GetChangeApprovalAggregateType<T extends ChangeApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregateChangeApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChangeApproval[P]>
      : GetScalarType<T[P], AggregateChangeApproval[P]>
  }




  export type ChangeApprovalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChangeApprovalWhereInput
    orderBy?: ChangeApprovalOrderByWithAggregationInput | ChangeApprovalOrderByWithAggregationInput[]
    by: ChangeApprovalScalarFieldEnum[] | ChangeApprovalScalarFieldEnum
    having?: ChangeApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChangeApprovalCountAggregateInputType | true
    _min?: ChangeApprovalMinAggregateInputType
    _max?: ChangeApprovalMaxAggregateInputType
  }

  export type ChangeApprovalGroupByOutputType = {
    id: string
    changeRequestId: string
    approverId: string
    status: $Enums.ApprovalStatus
    comment: string | null
    createdAt: Date
    decidedAt: Date | null
    _count: ChangeApprovalCountAggregateOutputType | null
    _min: ChangeApprovalMinAggregateOutputType | null
    _max: ChangeApprovalMaxAggregateOutputType | null
  }

  type GetChangeApprovalGroupByPayload<T extends ChangeApprovalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChangeApprovalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChangeApprovalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChangeApprovalGroupByOutputType[P]>
            : GetScalarType<T[P], ChangeApprovalGroupByOutputType[P]>
        }
      >
    >


  export type ChangeApprovalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    changeRequestId?: boolean
    approverId?: boolean
    status?: boolean
    comment?: boolean
    createdAt?: boolean
    decidedAt?: boolean
    changeRequest?: boolean | ChangeRequestDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["changeApproval"]>

  export type ChangeApprovalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    changeRequestId?: boolean
    approverId?: boolean
    status?: boolean
    comment?: boolean
    createdAt?: boolean
    decidedAt?: boolean
    changeRequest?: boolean | ChangeRequestDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["changeApproval"]>

  export type ChangeApprovalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    changeRequestId?: boolean
    approverId?: boolean
    status?: boolean
    comment?: boolean
    createdAt?: boolean
    decidedAt?: boolean
    changeRequest?: boolean | ChangeRequestDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["changeApproval"]>

  export type ChangeApprovalSelectScalar = {
    id?: boolean
    changeRequestId?: boolean
    approverId?: boolean
    status?: boolean
    comment?: boolean
    createdAt?: boolean
    decidedAt?: boolean
  }

  export type ChangeApprovalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "changeRequestId" | "approverId" | "status" | "comment" | "createdAt" | "decidedAt", ExtArgs["result"]["changeApproval"]>
  export type ChangeApprovalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    changeRequest?: boolean | ChangeRequestDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChangeApprovalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    changeRequest?: boolean | ChangeRequestDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChangeApprovalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    changeRequest?: boolean | ChangeRequestDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChangeApprovalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChangeApproval"
    objects: {
      changeRequest: Prisma.$ChangeRequestPayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      changeRequestId: string
      approverId: string
      status: $Enums.ApprovalStatus
      comment: string | null
      createdAt: Date
      decidedAt: Date | null
    }, ExtArgs["result"]["changeApproval"]>
    composites: {}
  }

  type ChangeApprovalGetPayload<S extends boolean | null | undefined | ChangeApprovalDefaultArgs> = $Result.GetResult<Prisma.$ChangeApprovalPayload, S>

  type ChangeApprovalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChangeApprovalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChangeApprovalCountAggregateInputType | true
    }

  export interface ChangeApprovalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChangeApproval'], meta: { name: 'ChangeApproval' } }
    /**
     * Find zero or one ChangeApproval that matches the filter.
     * @param {ChangeApprovalFindUniqueArgs} args - Arguments to find a ChangeApproval
     * @example
     * // Get one ChangeApproval
     * const changeApproval = await prisma.changeApproval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChangeApprovalFindUniqueArgs>(args: SelectSubset<T, ChangeApprovalFindUniqueArgs<ExtArgs>>): Prisma__ChangeApprovalClient<$Result.GetResult<Prisma.$ChangeApprovalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChangeApproval that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChangeApprovalFindUniqueOrThrowArgs} args - Arguments to find a ChangeApproval
     * @example
     * // Get one ChangeApproval
     * const changeApproval = await prisma.changeApproval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChangeApprovalFindUniqueOrThrowArgs>(args: SelectSubset<T, ChangeApprovalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChangeApprovalClient<$Result.GetResult<Prisma.$ChangeApprovalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChangeApproval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeApprovalFindFirstArgs} args - Arguments to find a ChangeApproval
     * @example
     * // Get one ChangeApproval
     * const changeApproval = await prisma.changeApproval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChangeApprovalFindFirstArgs>(args?: SelectSubset<T, ChangeApprovalFindFirstArgs<ExtArgs>>): Prisma__ChangeApprovalClient<$Result.GetResult<Prisma.$ChangeApprovalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChangeApproval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeApprovalFindFirstOrThrowArgs} args - Arguments to find a ChangeApproval
     * @example
     * // Get one ChangeApproval
     * const changeApproval = await prisma.changeApproval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChangeApprovalFindFirstOrThrowArgs>(args?: SelectSubset<T, ChangeApprovalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChangeApprovalClient<$Result.GetResult<Prisma.$ChangeApprovalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChangeApprovals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeApprovalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChangeApprovals
     * const changeApprovals = await prisma.changeApproval.findMany()
     * 
     * // Get first 10 ChangeApprovals
     * const changeApprovals = await prisma.changeApproval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const changeApprovalWithIdOnly = await prisma.changeApproval.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChangeApprovalFindManyArgs>(args?: SelectSubset<T, ChangeApprovalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeApprovalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChangeApproval.
     * @param {ChangeApprovalCreateArgs} args - Arguments to create a ChangeApproval.
     * @example
     * // Create one ChangeApproval
     * const ChangeApproval = await prisma.changeApproval.create({
     *   data: {
     *     // ... data to create a ChangeApproval
     *   }
     * })
     * 
     */
    create<T extends ChangeApprovalCreateArgs>(args: SelectSubset<T, ChangeApprovalCreateArgs<ExtArgs>>): Prisma__ChangeApprovalClient<$Result.GetResult<Prisma.$ChangeApprovalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChangeApprovals.
     * @param {ChangeApprovalCreateManyArgs} args - Arguments to create many ChangeApprovals.
     * @example
     * // Create many ChangeApprovals
     * const changeApproval = await prisma.changeApproval.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChangeApprovalCreateManyArgs>(args?: SelectSubset<T, ChangeApprovalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChangeApprovals and returns the data saved in the database.
     * @param {ChangeApprovalCreateManyAndReturnArgs} args - Arguments to create many ChangeApprovals.
     * @example
     * // Create many ChangeApprovals
     * const changeApproval = await prisma.changeApproval.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChangeApprovals and only return the `id`
     * const changeApprovalWithIdOnly = await prisma.changeApproval.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChangeApprovalCreateManyAndReturnArgs>(args?: SelectSubset<T, ChangeApprovalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeApprovalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChangeApproval.
     * @param {ChangeApprovalDeleteArgs} args - Arguments to delete one ChangeApproval.
     * @example
     * // Delete one ChangeApproval
     * const ChangeApproval = await prisma.changeApproval.delete({
     *   where: {
     *     // ... filter to delete one ChangeApproval
     *   }
     * })
     * 
     */
    delete<T extends ChangeApprovalDeleteArgs>(args: SelectSubset<T, ChangeApprovalDeleteArgs<ExtArgs>>): Prisma__ChangeApprovalClient<$Result.GetResult<Prisma.$ChangeApprovalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChangeApproval.
     * @param {ChangeApprovalUpdateArgs} args - Arguments to update one ChangeApproval.
     * @example
     * // Update one ChangeApproval
     * const changeApproval = await prisma.changeApproval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChangeApprovalUpdateArgs>(args: SelectSubset<T, ChangeApprovalUpdateArgs<ExtArgs>>): Prisma__ChangeApprovalClient<$Result.GetResult<Prisma.$ChangeApprovalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChangeApprovals.
     * @param {ChangeApprovalDeleteManyArgs} args - Arguments to filter ChangeApprovals to delete.
     * @example
     * // Delete a few ChangeApprovals
     * const { count } = await prisma.changeApproval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChangeApprovalDeleteManyArgs>(args?: SelectSubset<T, ChangeApprovalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChangeApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChangeApprovals
     * const changeApproval = await prisma.changeApproval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChangeApprovalUpdateManyArgs>(args: SelectSubset<T, ChangeApprovalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChangeApprovals and returns the data updated in the database.
     * @param {ChangeApprovalUpdateManyAndReturnArgs} args - Arguments to update many ChangeApprovals.
     * @example
     * // Update many ChangeApprovals
     * const changeApproval = await prisma.changeApproval.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChangeApprovals and only return the `id`
     * const changeApprovalWithIdOnly = await prisma.changeApproval.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChangeApprovalUpdateManyAndReturnArgs>(args: SelectSubset<T, ChangeApprovalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChangeApprovalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChangeApproval.
     * @param {ChangeApprovalUpsertArgs} args - Arguments to update or create a ChangeApproval.
     * @example
     * // Update or create a ChangeApproval
     * const changeApproval = await prisma.changeApproval.upsert({
     *   create: {
     *     // ... data to create a ChangeApproval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChangeApproval we want to update
     *   }
     * })
     */
    upsert<T extends ChangeApprovalUpsertArgs>(args: SelectSubset<T, ChangeApprovalUpsertArgs<ExtArgs>>): Prisma__ChangeApprovalClient<$Result.GetResult<Prisma.$ChangeApprovalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChangeApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeApprovalCountArgs} args - Arguments to filter ChangeApprovals to count.
     * @example
     * // Count the number of ChangeApprovals
     * const count = await prisma.changeApproval.count({
     *   where: {
     *     // ... the filter for the ChangeApprovals we want to count
     *   }
     * })
    **/
    count<T extends ChangeApprovalCountArgs>(
      args?: Subset<T, ChangeApprovalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChangeApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChangeApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChangeApprovalAggregateArgs>(args: Subset<T, ChangeApprovalAggregateArgs>): Prisma.PrismaPromise<GetChangeApprovalAggregateType<T>>

    /**
     * Group by ChangeApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChangeApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChangeApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChangeApprovalGroupByArgs['orderBy'] }
        : { orderBy?: ChangeApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChangeApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChangeApprovalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChangeApproval model
   */
  readonly fields: ChangeApprovalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChangeApproval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChangeApprovalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    changeRequest<T extends ChangeRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChangeRequestDefaultArgs<ExtArgs>>): Prisma__ChangeRequestClient<$Result.GetResult<Prisma.$ChangeRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChangeApproval model
   */
  interface ChangeApprovalFieldRefs {
    readonly id: FieldRef<"ChangeApproval", 'String'>
    readonly changeRequestId: FieldRef<"ChangeApproval", 'String'>
    readonly approverId: FieldRef<"ChangeApproval", 'String'>
    readonly status: FieldRef<"ChangeApproval", 'ApprovalStatus'>
    readonly comment: FieldRef<"ChangeApproval", 'String'>
    readonly createdAt: FieldRef<"ChangeApproval", 'DateTime'>
    readonly decidedAt: FieldRef<"ChangeApproval", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChangeApproval findUnique
   */
  export type ChangeApprovalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeApproval
     */
    select?: ChangeApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeApproval
     */
    omit?: ChangeApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeApprovalInclude<ExtArgs> | null
    /**
     * Filter, which ChangeApproval to fetch.
     */
    where: ChangeApprovalWhereUniqueInput
  }

  /**
   * ChangeApproval findUniqueOrThrow
   */
  export type ChangeApprovalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeApproval
     */
    select?: ChangeApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeApproval
     */
    omit?: ChangeApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeApprovalInclude<ExtArgs> | null
    /**
     * Filter, which ChangeApproval to fetch.
     */
    where: ChangeApprovalWhereUniqueInput
  }

  /**
   * ChangeApproval findFirst
   */
  export type ChangeApprovalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeApproval
     */
    select?: ChangeApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeApproval
     */
    omit?: ChangeApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeApprovalInclude<ExtArgs> | null
    /**
     * Filter, which ChangeApproval to fetch.
     */
    where?: ChangeApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeApprovals to fetch.
     */
    orderBy?: ChangeApprovalOrderByWithRelationInput | ChangeApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangeApprovals.
     */
    cursor?: ChangeApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangeApprovals.
     */
    distinct?: ChangeApprovalScalarFieldEnum | ChangeApprovalScalarFieldEnum[]
  }

  /**
   * ChangeApproval findFirstOrThrow
   */
  export type ChangeApprovalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeApproval
     */
    select?: ChangeApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeApproval
     */
    omit?: ChangeApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeApprovalInclude<ExtArgs> | null
    /**
     * Filter, which ChangeApproval to fetch.
     */
    where?: ChangeApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeApprovals to fetch.
     */
    orderBy?: ChangeApprovalOrderByWithRelationInput | ChangeApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChangeApprovals.
     */
    cursor?: ChangeApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChangeApprovals.
     */
    distinct?: ChangeApprovalScalarFieldEnum | ChangeApprovalScalarFieldEnum[]
  }

  /**
   * ChangeApproval findMany
   */
  export type ChangeApprovalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeApproval
     */
    select?: ChangeApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeApproval
     */
    omit?: ChangeApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeApprovalInclude<ExtArgs> | null
    /**
     * Filter, which ChangeApprovals to fetch.
     */
    where?: ChangeApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChangeApprovals to fetch.
     */
    orderBy?: ChangeApprovalOrderByWithRelationInput | ChangeApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChangeApprovals.
     */
    cursor?: ChangeApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChangeApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChangeApprovals.
     */
    skip?: number
    distinct?: ChangeApprovalScalarFieldEnum | ChangeApprovalScalarFieldEnum[]
  }

  /**
   * ChangeApproval create
   */
  export type ChangeApprovalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeApproval
     */
    select?: ChangeApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeApproval
     */
    omit?: ChangeApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeApprovalInclude<ExtArgs> | null
    /**
     * The data needed to create a ChangeApproval.
     */
    data: XOR<ChangeApprovalCreateInput, ChangeApprovalUncheckedCreateInput>
  }

  /**
   * ChangeApproval createMany
   */
  export type ChangeApprovalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChangeApprovals.
     */
    data: ChangeApprovalCreateManyInput | ChangeApprovalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChangeApproval createManyAndReturn
   */
  export type ChangeApprovalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeApproval
     */
    select?: ChangeApprovalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeApproval
     */
    omit?: ChangeApprovalOmit<ExtArgs> | null
    /**
     * The data used to create many ChangeApprovals.
     */
    data: ChangeApprovalCreateManyInput | ChangeApprovalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeApprovalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChangeApproval update
   */
  export type ChangeApprovalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeApproval
     */
    select?: ChangeApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeApproval
     */
    omit?: ChangeApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeApprovalInclude<ExtArgs> | null
    /**
     * The data needed to update a ChangeApproval.
     */
    data: XOR<ChangeApprovalUpdateInput, ChangeApprovalUncheckedUpdateInput>
    /**
     * Choose, which ChangeApproval to update.
     */
    where: ChangeApprovalWhereUniqueInput
  }

  /**
   * ChangeApproval updateMany
   */
  export type ChangeApprovalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChangeApprovals.
     */
    data: XOR<ChangeApprovalUpdateManyMutationInput, ChangeApprovalUncheckedUpdateManyInput>
    /**
     * Filter which ChangeApprovals to update
     */
    where?: ChangeApprovalWhereInput
    /**
     * Limit how many ChangeApprovals to update.
     */
    limit?: number
  }

  /**
   * ChangeApproval updateManyAndReturn
   */
  export type ChangeApprovalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeApproval
     */
    select?: ChangeApprovalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeApproval
     */
    omit?: ChangeApprovalOmit<ExtArgs> | null
    /**
     * The data used to update ChangeApprovals.
     */
    data: XOR<ChangeApprovalUpdateManyMutationInput, ChangeApprovalUncheckedUpdateManyInput>
    /**
     * Filter which ChangeApprovals to update
     */
    where?: ChangeApprovalWhereInput
    /**
     * Limit how many ChangeApprovals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeApprovalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChangeApproval upsert
   */
  export type ChangeApprovalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeApproval
     */
    select?: ChangeApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeApproval
     */
    omit?: ChangeApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeApprovalInclude<ExtArgs> | null
    /**
     * The filter to search for the ChangeApproval to update in case it exists.
     */
    where: ChangeApprovalWhereUniqueInput
    /**
     * In case the ChangeApproval found by the `where` argument doesn't exist, create a new ChangeApproval with this data.
     */
    create: XOR<ChangeApprovalCreateInput, ChangeApprovalUncheckedCreateInput>
    /**
     * In case the ChangeApproval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChangeApprovalUpdateInput, ChangeApprovalUncheckedUpdateInput>
  }

  /**
   * ChangeApproval delete
   */
  export type ChangeApprovalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeApproval
     */
    select?: ChangeApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeApproval
     */
    omit?: ChangeApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeApprovalInclude<ExtArgs> | null
    /**
     * Filter which ChangeApproval to delete.
     */
    where: ChangeApprovalWhereUniqueInput
  }

  /**
   * ChangeApproval deleteMany
   */
  export type ChangeApprovalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChangeApprovals to delete
     */
    where?: ChangeApprovalWhereInput
    /**
     * Limit how many ChangeApprovals to delete.
     */
    limit?: number
  }

  /**
   * ChangeApproval without action
   */
  export type ChangeApprovalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChangeApproval
     */
    select?: ChangeApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChangeApproval
     */
    omit?: ChangeApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChangeApprovalInclude<ExtArgs> | null
  }


  /**
   * Model NodeType
   */

  export type AggregateNodeType = {
    _count: NodeTypeCountAggregateOutputType | null
    _avg: NodeTypeAvgAggregateOutputType | null
    _sum: NodeTypeSumAggregateOutputType | null
    _min: NodeTypeMinAggregateOutputType | null
    _max: NodeTypeMaxAggregateOutputType | null
  }

  export type NodeTypeAvgAggregateOutputType = {
    levelOrder: number | null
  }

  export type NodeTypeSumAggregateOutputType = {
    levelOrder: number | null
  }

  export type NodeTypeMinAggregateOutputType = {
    id: string | null
    code: $Enums.NodeTypeCode | null
    displayName: string | null
    levelOrder: number | null
    canHaveKpis: boolean | null
  }

  export type NodeTypeMaxAggregateOutputType = {
    id: string | null
    code: $Enums.NodeTypeCode | null
    displayName: string | null
    levelOrder: number | null
    canHaveKpis: boolean | null
  }

  export type NodeTypeCountAggregateOutputType = {
    id: number
    code: number
    displayName: number
    levelOrder: number
    canHaveKpis: number
    _all: number
  }


  export type NodeTypeAvgAggregateInputType = {
    levelOrder?: true
  }

  export type NodeTypeSumAggregateInputType = {
    levelOrder?: true
  }

  export type NodeTypeMinAggregateInputType = {
    id?: true
    code?: true
    displayName?: true
    levelOrder?: true
    canHaveKpis?: true
  }

  export type NodeTypeMaxAggregateInputType = {
    id?: true
    code?: true
    displayName?: true
    levelOrder?: true
    canHaveKpis?: true
  }

  export type NodeTypeCountAggregateInputType = {
    id?: true
    code?: true
    displayName?: true
    levelOrder?: true
    canHaveKpis?: true
    _all?: true
  }

  export type NodeTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NodeType to aggregate.
     */
    where?: NodeTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeTypes to fetch.
     */
    orderBy?: NodeTypeOrderByWithRelationInput | NodeTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NodeTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NodeTypes
    **/
    _count?: true | NodeTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NodeTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NodeTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NodeTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NodeTypeMaxAggregateInputType
  }

  export type GetNodeTypeAggregateType<T extends NodeTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateNodeType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNodeType[P]>
      : GetScalarType<T[P], AggregateNodeType[P]>
  }




  export type NodeTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeTypeWhereInput
    orderBy?: NodeTypeOrderByWithAggregationInput | NodeTypeOrderByWithAggregationInput[]
    by: NodeTypeScalarFieldEnum[] | NodeTypeScalarFieldEnum
    having?: NodeTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NodeTypeCountAggregateInputType | true
    _avg?: NodeTypeAvgAggregateInputType
    _sum?: NodeTypeSumAggregateInputType
    _min?: NodeTypeMinAggregateInputType
    _max?: NodeTypeMaxAggregateInputType
  }

  export type NodeTypeGroupByOutputType = {
    id: string
    code: $Enums.NodeTypeCode
    displayName: string
    levelOrder: number
    canHaveKpis: boolean
    _count: NodeTypeCountAggregateOutputType | null
    _avg: NodeTypeAvgAggregateOutputType | null
    _sum: NodeTypeSumAggregateOutputType | null
    _min: NodeTypeMinAggregateOutputType | null
    _max: NodeTypeMaxAggregateOutputType | null
  }

  type GetNodeTypeGroupByPayload<T extends NodeTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NodeTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NodeTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NodeTypeGroupByOutputType[P]>
            : GetScalarType<T[P], NodeTypeGroupByOutputType[P]>
        }
      >
    >


  export type NodeTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    displayName?: boolean
    levelOrder?: boolean
    canHaveKpis?: boolean
    nodes?: boolean | NodeType$nodesArgs<ExtArgs>
    _count?: boolean | NodeTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nodeType"]>

  export type NodeTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    displayName?: boolean
    levelOrder?: boolean
    canHaveKpis?: boolean
  }, ExtArgs["result"]["nodeType"]>

  export type NodeTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    displayName?: boolean
    levelOrder?: boolean
    canHaveKpis?: boolean
  }, ExtArgs["result"]["nodeType"]>

  export type NodeTypeSelectScalar = {
    id?: boolean
    code?: boolean
    displayName?: boolean
    levelOrder?: boolean
    canHaveKpis?: boolean
  }

  export type NodeTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "displayName" | "levelOrder" | "canHaveKpis", ExtArgs["result"]["nodeType"]>
  export type NodeTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodes?: boolean | NodeType$nodesArgs<ExtArgs>
    _count?: boolean | NodeTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NodeTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type NodeTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NodeTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NodeType"
    objects: {
      nodes: Prisma.$NodePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: $Enums.NodeTypeCode
      displayName: string
      levelOrder: number
      canHaveKpis: boolean
    }, ExtArgs["result"]["nodeType"]>
    composites: {}
  }

  type NodeTypeGetPayload<S extends boolean | null | undefined | NodeTypeDefaultArgs> = $Result.GetResult<Prisma.$NodeTypePayload, S>

  type NodeTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NodeTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NodeTypeCountAggregateInputType | true
    }

  export interface NodeTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NodeType'], meta: { name: 'NodeType' } }
    /**
     * Find zero or one NodeType that matches the filter.
     * @param {NodeTypeFindUniqueArgs} args - Arguments to find a NodeType
     * @example
     * // Get one NodeType
     * const nodeType = await prisma.nodeType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NodeTypeFindUniqueArgs>(args: SelectSubset<T, NodeTypeFindUniqueArgs<ExtArgs>>): Prisma__NodeTypeClient<$Result.GetResult<Prisma.$NodeTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NodeType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NodeTypeFindUniqueOrThrowArgs} args - Arguments to find a NodeType
     * @example
     * // Get one NodeType
     * const nodeType = await prisma.nodeType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NodeTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, NodeTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NodeTypeClient<$Result.GetResult<Prisma.$NodeTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NodeType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeTypeFindFirstArgs} args - Arguments to find a NodeType
     * @example
     * // Get one NodeType
     * const nodeType = await prisma.nodeType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NodeTypeFindFirstArgs>(args?: SelectSubset<T, NodeTypeFindFirstArgs<ExtArgs>>): Prisma__NodeTypeClient<$Result.GetResult<Prisma.$NodeTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NodeType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeTypeFindFirstOrThrowArgs} args - Arguments to find a NodeType
     * @example
     * // Get one NodeType
     * const nodeType = await prisma.nodeType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NodeTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, NodeTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__NodeTypeClient<$Result.GetResult<Prisma.$NodeTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NodeTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NodeTypes
     * const nodeTypes = await prisma.nodeType.findMany()
     * 
     * // Get first 10 NodeTypes
     * const nodeTypes = await prisma.nodeType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nodeTypeWithIdOnly = await prisma.nodeType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NodeTypeFindManyArgs>(args?: SelectSubset<T, NodeTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NodeType.
     * @param {NodeTypeCreateArgs} args - Arguments to create a NodeType.
     * @example
     * // Create one NodeType
     * const NodeType = await prisma.nodeType.create({
     *   data: {
     *     // ... data to create a NodeType
     *   }
     * })
     * 
     */
    create<T extends NodeTypeCreateArgs>(args: SelectSubset<T, NodeTypeCreateArgs<ExtArgs>>): Prisma__NodeTypeClient<$Result.GetResult<Prisma.$NodeTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NodeTypes.
     * @param {NodeTypeCreateManyArgs} args - Arguments to create many NodeTypes.
     * @example
     * // Create many NodeTypes
     * const nodeType = await prisma.nodeType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NodeTypeCreateManyArgs>(args?: SelectSubset<T, NodeTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NodeTypes and returns the data saved in the database.
     * @param {NodeTypeCreateManyAndReturnArgs} args - Arguments to create many NodeTypes.
     * @example
     * // Create many NodeTypes
     * const nodeType = await prisma.nodeType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NodeTypes and only return the `id`
     * const nodeTypeWithIdOnly = await prisma.nodeType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NodeTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, NodeTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NodeType.
     * @param {NodeTypeDeleteArgs} args - Arguments to delete one NodeType.
     * @example
     * // Delete one NodeType
     * const NodeType = await prisma.nodeType.delete({
     *   where: {
     *     // ... filter to delete one NodeType
     *   }
     * })
     * 
     */
    delete<T extends NodeTypeDeleteArgs>(args: SelectSubset<T, NodeTypeDeleteArgs<ExtArgs>>): Prisma__NodeTypeClient<$Result.GetResult<Prisma.$NodeTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NodeType.
     * @param {NodeTypeUpdateArgs} args - Arguments to update one NodeType.
     * @example
     * // Update one NodeType
     * const nodeType = await prisma.nodeType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NodeTypeUpdateArgs>(args: SelectSubset<T, NodeTypeUpdateArgs<ExtArgs>>): Prisma__NodeTypeClient<$Result.GetResult<Prisma.$NodeTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NodeTypes.
     * @param {NodeTypeDeleteManyArgs} args - Arguments to filter NodeTypes to delete.
     * @example
     * // Delete a few NodeTypes
     * const { count } = await prisma.nodeType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NodeTypeDeleteManyArgs>(args?: SelectSubset<T, NodeTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NodeTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NodeTypes
     * const nodeType = await prisma.nodeType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NodeTypeUpdateManyArgs>(args: SelectSubset<T, NodeTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NodeTypes and returns the data updated in the database.
     * @param {NodeTypeUpdateManyAndReturnArgs} args - Arguments to update many NodeTypes.
     * @example
     * // Update many NodeTypes
     * const nodeType = await prisma.nodeType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NodeTypes and only return the `id`
     * const nodeTypeWithIdOnly = await prisma.nodeType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NodeTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, NodeTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NodeType.
     * @param {NodeTypeUpsertArgs} args - Arguments to update or create a NodeType.
     * @example
     * // Update or create a NodeType
     * const nodeType = await prisma.nodeType.upsert({
     *   create: {
     *     // ... data to create a NodeType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NodeType we want to update
     *   }
     * })
     */
    upsert<T extends NodeTypeUpsertArgs>(args: SelectSubset<T, NodeTypeUpsertArgs<ExtArgs>>): Prisma__NodeTypeClient<$Result.GetResult<Prisma.$NodeTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NodeTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeTypeCountArgs} args - Arguments to filter NodeTypes to count.
     * @example
     * // Count the number of NodeTypes
     * const count = await prisma.nodeType.count({
     *   where: {
     *     // ... the filter for the NodeTypes we want to count
     *   }
     * })
    **/
    count<T extends NodeTypeCountArgs>(
      args?: Subset<T, NodeTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NodeTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NodeType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NodeTypeAggregateArgs>(args: Subset<T, NodeTypeAggregateArgs>): Prisma.PrismaPromise<GetNodeTypeAggregateType<T>>

    /**
     * Group by NodeType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NodeTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NodeTypeGroupByArgs['orderBy'] }
        : { orderBy?: NodeTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NodeTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNodeTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NodeType model
   */
  readonly fields: NodeTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NodeType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NodeTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nodes<T extends NodeType$nodesArgs<ExtArgs> = {}>(args?: Subset<T, NodeType$nodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NodeType model
   */
  interface NodeTypeFieldRefs {
    readonly id: FieldRef<"NodeType", 'String'>
    readonly code: FieldRef<"NodeType", 'NodeTypeCode'>
    readonly displayName: FieldRef<"NodeType", 'String'>
    readonly levelOrder: FieldRef<"NodeType", 'Int'>
    readonly canHaveKpis: FieldRef<"NodeType", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * NodeType findUnique
   */
  export type NodeTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeType
     */
    select?: NodeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeType
     */
    omit?: NodeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeTypeInclude<ExtArgs> | null
    /**
     * Filter, which NodeType to fetch.
     */
    where: NodeTypeWhereUniqueInput
  }

  /**
   * NodeType findUniqueOrThrow
   */
  export type NodeTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeType
     */
    select?: NodeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeType
     */
    omit?: NodeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeTypeInclude<ExtArgs> | null
    /**
     * Filter, which NodeType to fetch.
     */
    where: NodeTypeWhereUniqueInput
  }

  /**
   * NodeType findFirst
   */
  export type NodeTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeType
     */
    select?: NodeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeType
     */
    omit?: NodeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeTypeInclude<ExtArgs> | null
    /**
     * Filter, which NodeType to fetch.
     */
    where?: NodeTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeTypes to fetch.
     */
    orderBy?: NodeTypeOrderByWithRelationInput | NodeTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NodeTypes.
     */
    cursor?: NodeTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NodeTypes.
     */
    distinct?: NodeTypeScalarFieldEnum | NodeTypeScalarFieldEnum[]
  }

  /**
   * NodeType findFirstOrThrow
   */
  export type NodeTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeType
     */
    select?: NodeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeType
     */
    omit?: NodeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeTypeInclude<ExtArgs> | null
    /**
     * Filter, which NodeType to fetch.
     */
    where?: NodeTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeTypes to fetch.
     */
    orderBy?: NodeTypeOrderByWithRelationInput | NodeTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NodeTypes.
     */
    cursor?: NodeTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NodeTypes.
     */
    distinct?: NodeTypeScalarFieldEnum | NodeTypeScalarFieldEnum[]
  }

  /**
   * NodeType findMany
   */
  export type NodeTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeType
     */
    select?: NodeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeType
     */
    omit?: NodeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeTypeInclude<ExtArgs> | null
    /**
     * Filter, which NodeTypes to fetch.
     */
    where?: NodeTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeTypes to fetch.
     */
    orderBy?: NodeTypeOrderByWithRelationInput | NodeTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NodeTypes.
     */
    cursor?: NodeTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeTypes.
     */
    skip?: number
    distinct?: NodeTypeScalarFieldEnum | NodeTypeScalarFieldEnum[]
  }

  /**
   * NodeType create
   */
  export type NodeTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeType
     */
    select?: NodeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeType
     */
    omit?: NodeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a NodeType.
     */
    data: XOR<NodeTypeCreateInput, NodeTypeUncheckedCreateInput>
  }

  /**
   * NodeType createMany
   */
  export type NodeTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NodeTypes.
     */
    data: NodeTypeCreateManyInput | NodeTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NodeType createManyAndReturn
   */
  export type NodeTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeType
     */
    select?: NodeTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NodeType
     */
    omit?: NodeTypeOmit<ExtArgs> | null
    /**
     * The data used to create many NodeTypes.
     */
    data: NodeTypeCreateManyInput | NodeTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NodeType update
   */
  export type NodeTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeType
     */
    select?: NodeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeType
     */
    omit?: NodeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a NodeType.
     */
    data: XOR<NodeTypeUpdateInput, NodeTypeUncheckedUpdateInput>
    /**
     * Choose, which NodeType to update.
     */
    where: NodeTypeWhereUniqueInput
  }

  /**
   * NodeType updateMany
   */
  export type NodeTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NodeTypes.
     */
    data: XOR<NodeTypeUpdateManyMutationInput, NodeTypeUncheckedUpdateManyInput>
    /**
     * Filter which NodeTypes to update
     */
    where?: NodeTypeWhereInput
    /**
     * Limit how many NodeTypes to update.
     */
    limit?: number
  }

  /**
   * NodeType updateManyAndReturn
   */
  export type NodeTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeType
     */
    select?: NodeTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NodeType
     */
    omit?: NodeTypeOmit<ExtArgs> | null
    /**
     * The data used to update NodeTypes.
     */
    data: XOR<NodeTypeUpdateManyMutationInput, NodeTypeUncheckedUpdateManyInput>
    /**
     * Filter which NodeTypes to update
     */
    where?: NodeTypeWhereInput
    /**
     * Limit how many NodeTypes to update.
     */
    limit?: number
  }

  /**
   * NodeType upsert
   */
  export type NodeTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeType
     */
    select?: NodeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeType
     */
    omit?: NodeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the NodeType to update in case it exists.
     */
    where: NodeTypeWhereUniqueInput
    /**
     * In case the NodeType found by the `where` argument doesn't exist, create a new NodeType with this data.
     */
    create: XOR<NodeTypeCreateInput, NodeTypeUncheckedCreateInput>
    /**
     * In case the NodeType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NodeTypeUpdateInput, NodeTypeUncheckedUpdateInput>
  }

  /**
   * NodeType delete
   */
  export type NodeTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeType
     */
    select?: NodeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeType
     */
    omit?: NodeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeTypeInclude<ExtArgs> | null
    /**
     * Filter which NodeType to delete.
     */
    where: NodeTypeWhereUniqueInput
  }

  /**
   * NodeType deleteMany
   */
  export type NodeTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NodeTypes to delete
     */
    where?: NodeTypeWhereInput
    /**
     * Limit how many NodeTypes to delete.
     */
    limit?: number
  }

  /**
   * NodeType.nodes
   */
  export type NodeType$nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    where?: NodeWhereInput
    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]
    cursor?: NodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NodeScalarFieldEnum | NodeScalarFieldEnum[]
  }

  /**
   * NodeType without action
   */
  export type NodeTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeType
     */
    select?: NodeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeType
     */
    omit?: NodeTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeTypeInclude<ExtArgs> | null
  }


  /**
   * Model Node
   */

  export type AggregateNode = {
    _count: NodeCountAggregateOutputType | null
    _avg: NodeAvgAggregateOutputType | null
    _sum: NodeSumAggregateOutputType | null
    _min: NodeMinAggregateOutputType | null
    _max: NodeMaxAggregateOutputType | null
  }

  export type NodeAvgAggregateOutputType = {
    progress: number | null
  }

  export type NodeSumAggregateOutputType = {
    progress: number | null
  }

  export type NodeMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    nodeTypeId: string | null
    parentId: string | null
    name: string | null
    description: string | null
    ownerUserId: string | null
    status: $Enums.Status | null
    progress: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type NodeMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    nodeTypeId: string | null
    parentId: string | null
    name: string | null
    description: string | null
    ownerUserId: string | null
    status: $Enums.Status | null
    progress: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type NodeCountAggregateOutputType = {
    id: number
    orgId: number
    nodeTypeId: number
    parentId: number
    name: number
    description: number
    ownerUserId: number
    status: number
    progress: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type NodeAvgAggregateInputType = {
    progress?: true
  }

  export type NodeSumAggregateInputType = {
    progress?: true
  }

  export type NodeMinAggregateInputType = {
    id?: true
    orgId?: true
    nodeTypeId?: true
    parentId?: true
    name?: true
    description?: true
    ownerUserId?: true
    status?: true
    progress?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type NodeMaxAggregateInputType = {
    id?: true
    orgId?: true
    nodeTypeId?: true
    parentId?: true
    name?: true
    description?: true
    ownerUserId?: true
    status?: true
    progress?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type NodeCountAggregateInputType = {
    id?: true
    orgId?: true
    nodeTypeId?: true
    parentId?: true
    name?: true
    description?: true
    ownerUserId?: true
    status?: true
    progress?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type NodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Node to aggregate.
     */
    where?: NodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nodes to fetch.
     */
    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Nodes
    **/
    _count?: true | NodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NodeMaxAggregateInputType
  }

  export type GetNodeAggregateType<T extends NodeAggregateArgs> = {
        [P in keyof T & keyof AggregateNode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNode[P]>
      : GetScalarType<T[P], AggregateNode[P]>
  }




  export type NodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeWhereInput
    orderBy?: NodeOrderByWithAggregationInput | NodeOrderByWithAggregationInput[]
    by: NodeScalarFieldEnum[] | NodeScalarFieldEnum
    having?: NodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NodeCountAggregateInputType | true
    _avg?: NodeAvgAggregateInputType
    _sum?: NodeSumAggregateInputType
    _min?: NodeMinAggregateInputType
    _max?: NodeMaxAggregateInputType
  }

  export type NodeGroupByOutputType = {
    id: string
    orgId: string
    nodeTypeId: string
    parentId: string | null
    name: string
    description: string | null
    ownerUserId: string | null
    status: $Enums.Status
    progress: number
    startDate: Date | null
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: NodeCountAggregateOutputType | null
    _avg: NodeAvgAggregateOutputType | null
    _sum: NodeSumAggregateOutputType | null
    _min: NodeMinAggregateOutputType | null
    _max: NodeMaxAggregateOutputType | null
  }

  type GetNodeGroupByPayload<T extends NodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NodeGroupByOutputType[P]>
            : GetScalarType<T[P], NodeGroupByOutputType[P]>
        }
      >
    >


  export type NodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    nodeTypeId?: boolean
    parentId?: boolean
    name?: boolean
    description?: boolean
    ownerUserId?: boolean
    status?: boolean
    progress?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    nodeType?: boolean | NodeTypeDefaultArgs<ExtArgs>
    parent?: boolean | Node$parentArgs<ExtArgs>
    children?: boolean | Node$childrenArgs<ExtArgs>
    ownerUser?: boolean | Node$ownerUserArgs<ExtArgs>
    assignments?: boolean | Node$assignmentsArgs<ExtArgs>
    outgoingDeps?: boolean | Node$outgoingDepsArgs<ExtArgs>
    incomingDeps?: boolean | Node$incomingDepsArgs<ExtArgs>
    kpis?: boolean | Node$kpisArgs<ExtArgs>
    _count?: boolean | NodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["node"]>

  export type NodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    nodeTypeId?: boolean
    parentId?: boolean
    name?: boolean
    description?: boolean
    ownerUserId?: boolean
    status?: boolean
    progress?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    nodeType?: boolean | NodeTypeDefaultArgs<ExtArgs>
    parent?: boolean | Node$parentArgs<ExtArgs>
    ownerUser?: boolean | Node$ownerUserArgs<ExtArgs>
  }, ExtArgs["result"]["node"]>

  export type NodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    nodeTypeId?: boolean
    parentId?: boolean
    name?: boolean
    description?: boolean
    ownerUserId?: boolean
    status?: boolean
    progress?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    nodeType?: boolean | NodeTypeDefaultArgs<ExtArgs>
    parent?: boolean | Node$parentArgs<ExtArgs>
    ownerUser?: boolean | Node$ownerUserArgs<ExtArgs>
  }, ExtArgs["result"]["node"]>

  export type NodeSelectScalar = {
    id?: boolean
    orgId?: boolean
    nodeTypeId?: boolean
    parentId?: boolean
    name?: boolean
    description?: boolean
    ownerUserId?: boolean
    status?: boolean
    progress?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type NodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "nodeTypeId" | "parentId" | "name" | "description" | "ownerUserId" | "status" | "progress" | "startDate" | "endDate" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["node"]>
  export type NodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    nodeType?: boolean | NodeTypeDefaultArgs<ExtArgs>
    parent?: boolean | Node$parentArgs<ExtArgs>
    children?: boolean | Node$childrenArgs<ExtArgs>
    ownerUser?: boolean | Node$ownerUserArgs<ExtArgs>
    assignments?: boolean | Node$assignmentsArgs<ExtArgs>
    outgoingDeps?: boolean | Node$outgoingDepsArgs<ExtArgs>
    incomingDeps?: boolean | Node$incomingDepsArgs<ExtArgs>
    kpis?: boolean | Node$kpisArgs<ExtArgs>
    _count?: boolean | NodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    nodeType?: boolean | NodeTypeDefaultArgs<ExtArgs>
    parent?: boolean | Node$parentArgs<ExtArgs>
    ownerUser?: boolean | Node$ownerUserArgs<ExtArgs>
  }
  export type NodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    nodeType?: boolean | NodeTypeDefaultArgs<ExtArgs>
    parent?: boolean | Node$parentArgs<ExtArgs>
    ownerUser?: boolean | Node$ownerUserArgs<ExtArgs>
  }

  export type $NodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Node"
    objects: {
      org: Prisma.$OrganizationPayload<ExtArgs>
      nodeType: Prisma.$NodeTypePayload<ExtArgs>
      parent: Prisma.$NodePayload<ExtArgs> | null
      children: Prisma.$NodePayload<ExtArgs>[]
      ownerUser: Prisma.$UserPayload<ExtArgs> | null
      assignments: Prisma.$NodeAssignmentPayload<ExtArgs>[]
      outgoingDeps: Prisma.$NodeDependencyPayload<ExtArgs>[]
      incomingDeps: Prisma.$NodeDependencyPayload<ExtArgs>[]
      kpis: Prisma.$KpiDefinitionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      nodeTypeId: string
      parentId: string | null
      name: string
      description: string | null
      ownerUserId: string | null
      status: $Enums.Status
      progress: number
      startDate: Date | null
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["node"]>
    composites: {}
  }

  type NodeGetPayload<S extends boolean | null | undefined | NodeDefaultArgs> = $Result.GetResult<Prisma.$NodePayload, S>

  type NodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NodeCountAggregateInputType | true
    }

  export interface NodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Node'], meta: { name: 'Node' } }
    /**
     * Find zero or one Node that matches the filter.
     * @param {NodeFindUniqueArgs} args - Arguments to find a Node
     * @example
     * // Get one Node
     * const node = await prisma.node.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NodeFindUniqueArgs>(args: SelectSubset<T, NodeFindUniqueArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Node that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NodeFindUniqueOrThrowArgs} args - Arguments to find a Node
     * @example
     * // Get one Node
     * const node = await prisma.node.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NodeFindUniqueOrThrowArgs>(args: SelectSubset<T, NodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Node that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeFindFirstArgs} args - Arguments to find a Node
     * @example
     * // Get one Node
     * const node = await prisma.node.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NodeFindFirstArgs>(args?: SelectSubset<T, NodeFindFirstArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Node that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeFindFirstOrThrowArgs} args - Arguments to find a Node
     * @example
     * // Get one Node
     * const node = await prisma.node.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NodeFindFirstOrThrowArgs>(args?: SelectSubset<T, NodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Nodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Nodes
     * const nodes = await prisma.node.findMany()
     * 
     * // Get first 10 Nodes
     * const nodes = await prisma.node.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nodeWithIdOnly = await prisma.node.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NodeFindManyArgs>(args?: SelectSubset<T, NodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Node.
     * @param {NodeCreateArgs} args - Arguments to create a Node.
     * @example
     * // Create one Node
     * const Node = await prisma.node.create({
     *   data: {
     *     // ... data to create a Node
     *   }
     * })
     * 
     */
    create<T extends NodeCreateArgs>(args: SelectSubset<T, NodeCreateArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Nodes.
     * @param {NodeCreateManyArgs} args - Arguments to create many Nodes.
     * @example
     * // Create many Nodes
     * const node = await prisma.node.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NodeCreateManyArgs>(args?: SelectSubset<T, NodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Nodes and returns the data saved in the database.
     * @param {NodeCreateManyAndReturnArgs} args - Arguments to create many Nodes.
     * @example
     * // Create many Nodes
     * const node = await prisma.node.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Nodes and only return the `id`
     * const nodeWithIdOnly = await prisma.node.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NodeCreateManyAndReturnArgs>(args?: SelectSubset<T, NodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Node.
     * @param {NodeDeleteArgs} args - Arguments to delete one Node.
     * @example
     * // Delete one Node
     * const Node = await prisma.node.delete({
     *   where: {
     *     // ... filter to delete one Node
     *   }
     * })
     * 
     */
    delete<T extends NodeDeleteArgs>(args: SelectSubset<T, NodeDeleteArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Node.
     * @param {NodeUpdateArgs} args - Arguments to update one Node.
     * @example
     * // Update one Node
     * const node = await prisma.node.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NodeUpdateArgs>(args: SelectSubset<T, NodeUpdateArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Nodes.
     * @param {NodeDeleteManyArgs} args - Arguments to filter Nodes to delete.
     * @example
     * // Delete a few Nodes
     * const { count } = await prisma.node.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NodeDeleteManyArgs>(args?: SelectSubset<T, NodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Nodes
     * const node = await prisma.node.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NodeUpdateManyArgs>(args: SelectSubset<T, NodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nodes and returns the data updated in the database.
     * @param {NodeUpdateManyAndReturnArgs} args - Arguments to update many Nodes.
     * @example
     * // Update many Nodes
     * const node = await prisma.node.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Nodes and only return the `id`
     * const nodeWithIdOnly = await prisma.node.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NodeUpdateManyAndReturnArgs>(args: SelectSubset<T, NodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Node.
     * @param {NodeUpsertArgs} args - Arguments to update or create a Node.
     * @example
     * // Update or create a Node
     * const node = await prisma.node.upsert({
     *   create: {
     *     // ... data to create a Node
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Node we want to update
     *   }
     * })
     */
    upsert<T extends NodeUpsertArgs>(args: SelectSubset<T, NodeUpsertArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Nodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeCountArgs} args - Arguments to filter Nodes to count.
     * @example
     * // Count the number of Nodes
     * const count = await prisma.node.count({
     *   where: {
     *     // ... the filter for the Nodes we want to count
     *   }
     * })
    **/
    count<T extends NodeCountArgs>(
      args?: Subset<T, NodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Node.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NodeAggregateArgs>(args: Subset<T, NodeAggregateArgs>): Prisma.PrismaPromise<GetNodeAggregateType<T>>

    /**
     * Group by Node.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NodeGroupByArgs['orderBy'] }
        : { orderBy?: NodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Node model
   */
  readonly fields: NodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Node.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    nodeType<T extends NodeTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NodeTypeDefaultArgs<ExtArgs>>): Prisma__NodeTypeClient<$Result.GetResult<Prisma.$NodeTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends Node$parentArgs<ExtArgs> = {}>(args?: Subset<T, Node$parentArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Node$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Node$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ownerUser<T extends Node$ownerUserArgs<ExtArgs> = {}>(args?: Subset<T, Node$ownerUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignments<T extends Node$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Node$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    outgoingDeps<T extends Node$outgoingDepsArgs<ExtArgs> = {}>(args?: Subset<T, Node$outgoingDepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeDependencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    incomingDeps<T extends Node$incomingDepsArgs<ExtArgs> = {}>(args?: Subset<T, Node$incomingDepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeDependencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kpis<T extends Node$kpisArgs<ExtArgs> = {}>(args?: Subset<T, Node$kpisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Node model
   */
  interface NodeFieldRefs {
    readonly id: FieldRef<"Node", 'String'>
    readonly orgId: FieldRef<"Node", 'String'>
    readonly nodeTypeId: FieldRef<"Node", 'String'>
    readonly parentId: FieldRef<"Node", 'String'>
    readonly name: FieldRef<"Node", 'String'>
    readonly description: FieldRef<"Node", 'String'>
    readonly ownerUserId: FieldRef<"Node", 'String'>
    readonly status: FieldRef<"Node", 'Status'>
    readonly progress: FieldRef<"Node", 'Int'>
    readonly startDate: FieldRef<"Node", 'DateTime'>
    readonly endDate: FieldRef<"Node", 'DateTime'>
    readonly createdAt: FieldRef<"Node", 'DateTime'>
    readonly updatedAt: FieldRef<"Node", 'DateTime'>
    readonly deletedAt: FieldRef<"Node", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Node findUnique
   */
  export type NodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * Filter, which Node to fetch.
     */
    where: NodeWhereUniqueInput
  }

  /**
   * Node findUniqueOrThrow
   */
  export type NodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * Filter, which Node to fetch.
     */
    where: NodeWhereUniqueInput
  }

  /**
   * Node findFirst
   */
  export type NodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * Filter, which Node to fetch.
     */
    where?: NodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nodes to fetch.
     */
    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nodes.
     */
    cursor?: NodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nodes.
     */
    distinct?: NodeScalarFieldEnum | NodeScalarFieldEnum[]
  }

  /**
   * Node findFirstOrThrow
   */
  export type NodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * Filter, which Node to fetch.
     */
    where?: NodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nodes to fetch.
     */
    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nodes.
     */
    cursor?: NodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nodes.
     */
    distinct?: NodeScalarFieldEnum | NodeScalarFieldEnum[]
  }

  /**
   * Node findMany
   */
  export type NodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * Filter, which Nodes to fetch.
     */
    where?: NodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nodes to fetch.
     */
    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Nodes.
     */
    cursor?: NodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nodes.
     */
    skip?: number
    distinct?: NodeScalarFieldEnum | NodeScalarFieldEnum[]
  }

  /**
   * Node create
   */
  export type NodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * The data needed to create a Node.
     */
    data: XOR<NodeCreateInput, NodeUncheckedCreateInput>
  }

  /**
   * Node createMany
   */
  export type NodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Nodes.
     */
    data: NodeCreateManyInput | NodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Node createManyAndReturn
   */
  export type NodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * The data used to create many Nodes.
     */
    data: NodeCreateManyInput | NodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Node update
   */
  export type NodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * The data needed to update a Node.
     */
    data: XOR<NodeUpdateInput, NodeUncheckedUpdateInput>
    /**
     * Choose, which Node to update.
     */
    where: NodeWhereUniqueInput
  }

  /**
   * Node updateMany
   */
  export type NodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Nodes.
     */
    data: XOR<NodeUpdateManyMutationInput, NodeUncheckedUpdateManyInput>
    /**
     * Filter which Nodes to update
     */
    where?: NodeWhereInput
    /**
     * Limit how many Nodes to update.
     */
    limit?: number
  }

  /**
   * Node updateManyAndReturn
   */
  export type NodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * The data used to update Nodes.
     */
    data: XOR<NodeUpdateManyMutationInput, NodeUncheckedUpdateManyInput>
    /**
     * Filter which Nodes to update
     */
    where?: NodeWhereInput
    /**
     * Limit how many Nodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Node upsert
   */
  export type NodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * The filter to search for the Node to update in case it exists.
     */
    where: NodeWhereUniqueInput
    /**
     * In case the Node found by the `where` argument doesn't exist, create a new Node with this data.
     */
    create: XOR<NodeCreateInput, NodeUncheckedCreateInput>
    /**
     * In case the Node was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NodeUpdateInput, NodeUncheckedUpdateInput>
  }

  /**
   * Node delete
   */
  export type NodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    /**
     * Filter which Node to delete.
     */
    where: NodeWhereUniqueInput
  }

  /**
   * Node deleteMany
   */
  export type NodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nodes to delete
     */
    where?: NodeWhereInput
    /**
     * Limit how many Nodes to delete.
     */
    limit?: number
  }

  /**
   * Node.parent
   */
  export type Node$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    where?: NodeWhereInput
  }

  /**
   * Node.children
   */
  export type Node$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
    where?: NodeWhereInput
    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]
    cursor?: NodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NodeScalarFieldEnum | NodeScalarFieldEnum[]
  }

  /**
   * Node.ownerUser
   */
  export type Node$ownerUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Node.assignments
   */
  export type Node$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeAssignment
     */
    select?: NodeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeAssignment
     */
    omit?: NodeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeAssignmentInclude<ExtArgs> | null
    where?: NodeAssignmentWhereInput
    orderBy?: NodeAssignmentOrderByWithRelationInput | NodeAssignmentOrderByWithRelationInput[]
    cursor?: NodeAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NodeAssignmentScalarFieldEnum | NodeAssignmentScalarFieldEnum[]
  }

  /**
   * Node.outgoingDeps
   */
  export type Node$outgoingDepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeDependency
     */
    select?: NodeDependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeDependency
     */
    omit?: NodeDependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeDependencyInclude<ExtArgs> | null
    where?: NodeDependencyWhereInput
    orderBy?: NodeDependencyOrderByWithRelationInput | NodeDependencyOrderByWithRelationInput[]
    cursor?: NodeDependencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NodeDependencyScalarFieldEnum | NodeDependencyScalarFieldEnum[]
  }

  /**
   * Node.incomingDeps
   */
  export type Node$incomingDepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeDependency
     */
    select?: NodeDependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeDependency
     */
    omit?: NodeDependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeDependencyInclude<ExtArgs> | null
    where?: NodeDependencyWhereInput
    orderBy?: NodeDependencyOrderByWithRelationInput | NodeDependencyOrderByWithRelationInput[]
    cursor?: NodeDependencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NodeDependencyScalarFieldEnum | NodeDependencyScalarFieldEnum[]
  }

  /**
   * Node.kpis
   */
  export type Node$kpisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiDefinition
     */
    select?: KpiDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiDefinition
     */
    omit?: KpiDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiDefinitionInclude<ExtArgs> | null
    where?: KpiDefinitionWhereInput
    orderBy?: KpiDefinitionOrderByWithRelationInput | KpiDefinitionOrderByWithRelationInput[]
    cursor?: KpiDefinitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KpiDefinitionScalarFieldEnum | KpiDefinitionScalarFieldEnum[]
  }

  /**
   * Node without action
   */
  export type NodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Node
     */
    select?: NodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Node
     */
    omit?: NodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeInclude<ExtArgs> | null
  }


  /**
   * Model NodeAssignment
   */

  export type AggregateNodeAssignment = {
    _count: NodeAssignmentCountAggregateOutputType | null
    _min: NodeAssignmentMinAggregateOutputType | null
    _max: NodeAssignmentMaxAggregateOutputType | null
  }

  export type NodeAssignmentMinAggregateOutputType = {
    id: string | null
    nodeId: string | null
    userId: string | null
    role: $Enums.NodeAssignmentRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NodeAssignmentMaxAggregateOutputType = {
    id: string | null
    nodeId: string | null
    userId: string | null
    role: $Enums.NodeAssignmentRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NodeAssignmentCountAggregateOutputType = {
    id: number
    nodeId: number
    userId: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NodeAssignmentMinAggregateInputType = {
    id?: true
    nodeId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NodeAssignmentMaxAggregateInputType = {
    id?: true
    nodeId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NodeAssignmentCountAggregateInputType = {
    id?: true
    nodeId?: true
    userId?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NodeAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NodeAssignment to aggregate.
     */
    where?: NodeAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeAssignments to fetch.
     */
    orderBy?: NodeAssignmentOrderByWithRelationInput | NodeAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NodeAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NodeAssignments
    **/
    _count?: true | NodeAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NodeAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NodeAssignmentMaxAggregateInputType
  }

  export type GetNodeAssignmentAggregateType<T extends NodeAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateNodeAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNodeAssignment[P]>
      : GetScalarType<T[P], AggregateNodeAssignment[P]>
  }




  export type NodeAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeAssignmentWhereInput
    orderBy?: NodeAssignmentOrderByWithAggregationInput | NodeAssignmentOrderByWithAggregationInput[]
    by: NodeAssignmentScalarFieldEnum[] | NodeAssignmentScalarFieldEnum
    having?: NodeAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NodeAssignmentCountAggregateInputType | true
    _min?: NodeAssignmentMinAggregateInputType
    _max?: NodeAssignmentMaxAggregateInputType
  }

  export type NodeAssignmentGroupByOutputType = {
    id: string
    nodeId: string
    userId: string
    role: $Enums.NodeAssignmentRole
    createdAt: Date
    updatedAt: Date
    _count: NodeAssignmentCountAggregateOutputType | null
    _min: NodeAssignmentMinAggregateOutputType | null
    _max: NodeAssignmentMaxAggregateOutputType | null
  }

  type GetNodeAssignmentGroupByPayload<T extends NodeAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NodeAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NodeAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NodeAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], NodeAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type NodeAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nodeId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    node?: boolean | NodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nodeAssignment"]>

  export type NodeAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nodeId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    node?: boolean | NodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nodeAssignment"]>

  export type NodeAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nodeId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    node?: boolean | NodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nodeAssignment"]>

  export type NodeAssignmentSelectScalar = {
    id?: boolean
    nodeId?: boolean
    userId?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NodeAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nodeId" | "userId" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["nodeAssignment"]>
  export type NodeAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    node?: boolean | NodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NodeAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    node?: boolean | NodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NodeAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    node?: boolean | NodeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NodeAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NodeAssignment"
    objects: {
      node: Prisma.$NodePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nodeId: string
      userId: string
      role: $Enums.NodeAssignmentRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["nodeAssignment"]>
    composites: {}
  }

  type NodeAssignmentGetPayload<S extends boolean | null | undefined | NodeAssignmentDefaultArgs> = $Result.GetResult<Prisma.$NodeAssignmentPayload, S>

  type NodeAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NodeAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NodeAssignmentCountAggregateInputType | true
    }

  export interface NodeAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NodeAssignment'], meta: { name: 'NodeAssignment' } }
    /**
     * Find zero or one NodeAssignment that matches the filter.
     * @param {NodeAssignmentFindUniqueArgs} args - Arguments to find a NodeAssignment
     * @example
     * // Get one NodeAssignment
     * const nodeAssignment = await prisma.nodeAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NodeAssignmentFindUniqueArgs>(args: SelectSubset<T, NodeAssignmentFindUniqueArgs<ExtArgs>>): Prisma__NodeAssignmentClient<$Result.GetResult<Prisma.$NodeAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NodeAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NodeAssignmentFindUniqueOrThrowArgs} args - Arguments to find a NodeAssignment
     * @example
     * // Get one NodeAssignment
     * const nodeAssignment = await prisma.nodeAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NodeAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, NodeAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NodeAssignmentClient<$Result.GetResult<Prisma.$NodeAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NodeAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeAssignmentFindFirstArgs} args - Arguments to find a NodeAssignment
     * @example
     * // Get one NodeAssignment
     * const nodeAssignment = await prisma.nodeAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NodeAssignmentFindFirstArgs>(args?: SelectSubset<T, NodeAssignmentFindFirstArgs<ExtArgs>>): Prisma__NodeAssignmentClient<$Result.GetResult<Prisma.$NodeAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NodeAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeAssignmentFindFirstOrThrowArgs} args - Arguments to find a NodeAssignment
     * @example
     * // Get one NodeAssignment
     * const nodeAssignment = await prisma.nodeAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NodeAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, NodeAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__NodeAssignmentClient<$Result.GetResult<Prisma.$NodeAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NodeAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NodeAssignments
     * const nodeAssignments = await prisma.nodeAssignment.findMany()
     * 
     * // Get first 10 NodeAssignments
     * const nodeAssignments = await prisma.nodeAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nodeAssignmentWithIdOnly = await prisma.nodeAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NodeAssignmentFindManyArgs>(args?: SelectSubset<T, NodeAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NodeAssignment.
     * @param {NodeAssignmentCreateArgs} args - Arguments to create a NodeAssignment.
     * @example
     * // Create one NodeAssignment
     * const NodeAssignment = await prisma.nodeAssignment.create({
     *   data: {
     *     // ... data to create a NodeAssignment
     *   }
     * })
     * 
     */
    create<T extends NodeAssignmentCreateArgs>(args: SelectSubset<T, NodeAssignmentCreateArgs<ExtArgs>>): Prisma__NodeAssignmentClient<$Result.GetResult<Prisma.$NodeAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NodeAssignments.
     * @param {NodeAssignmentCreateManyArgs} args - Arguments to create many NodeAssignments.
     * @example
     * // Create many NodeAssignments
     * const nodeAssignment = await prisma.nodeAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NodeAssignmentCreateManyArgs>(args?: SelectSubset<T, NodeAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NodeAssignments and returns the data saved in the database.
     * @param {NodeAssignmentCreateManyAndReturnArgs} args - Arguments to create many NodeAssignments.
     * @example
     * // Create many NodeAssignments
     * const nodeAssignment = await prisma.nodeAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NodeAssignments and only return the `id`
     * const nodeAssignmentWithIdOnly = await prisma.nodeAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NodeAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, NodeAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NodeAssignment.
     * @param {NodeAssignmentDeleteArgs} args - Arguments to delete one NodeAssignment.
     * @example
     * // Delete one NodeAssignment
     * const NodeAssignment = await prisma.nodeAssignment.delete({
     *   where: {
     *     // ... filter to delete one NodeAssignment
     *   }
     * })
     * 
     */
    delete<T extends NodeAssignmentDeleteArgs>(args: SelectSubset<T, NodeAssignmentDeleteArgs<ExtArgs>>): Prisma__NodeAssignmentClient<$Result.GetResult<Prisma.$NodeAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NodeAssignment.
     * @param {NodeAssignmentUpdateArgs} args - Arguments to update one NodeAssignment.
     * @example
     * // Update one NodeAssignment
     * const nodeAssignment = await prisma.nodeAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NodeAssignmentUpdateArgs>(args: SelectSubset<T, NodeAssignmentUpdateArgs<ExtArgs>>): Prisma__NodeAssignmentClient<$Result.GetResult<Prisma.$NodeAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NodeAssignments.
     * @param {NodeAssignmentDeleteManyArgs} args - Arguments to filter NodeAssignments to delete.
     * @example
     * // Delete a few NodeAssignments
     * const { count } = await prisma.nodeAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NodeAssignmentDeleteManyArgs>(args?: SelectSubset<T, NodeAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NodeAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NodeAssignments
     * const nodeAssignment = await prisma.nodeAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NodeAssignmentUpdateManyArgs>(args: SelectSubset<T, NodeAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NodeAssignments and returns the data updated in the database.
     * @param {NodeAssignmentUpdateManyAndReturnArgs} args - Arguments to update many NodeAssignments.
     * @example
     * // Update many NodeAssignments
     * const nodeAssignment = await prisma.nodeAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NodeAssignments and only return the `id`
     * const nodeAssignmentWithIdOnly = await prisma.nodeAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NodeAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, NodeAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NodeAssignment.
     * @param {NodeAssignmentUpsertArgs} args - Arguments to update or create a NodeAssignment.
     * @example
     * // Update or create a NodeAssignment
     * const nodeAssignment = await prisma.nodeAssignment.upsert({
     *   create: {
     *     // ... data to create a NodeAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NodeAssignment we want to update
     *   }
     * })
     */
    upsert<T extends NodeAssignmentUpsertArgs>(args: SelectSubset<T, NodeAssignmentUpsertArgs<ExtArgs>>): Prisma__NodeAssignmentClient<$Result.GetResult<Prisma.$NodeAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NodeAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeAssignmentCountArgs} args - Arguments to filter NodeAssignments to count.
     * @example
     * // Count the number of NodeAssignments
     * const count = await prisma.nodeAssignment.count({
     *   where: {
     *     // ... the filter for the NodeAssignments we want to count
     *   }
     * })
    **/
    count<T extends NodeAssignmentCountArgs>(
      args?: Subset<T, NodeAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NodeAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NodeAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NodeAssignmentAggregateArgs>(args: Subset<T, NodeAssignmentAggregateArgs>): Prisma.PrismaPromise<GetNodeAssignmentAggregateType<T>>

    /**
     * Group by NodeAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NodeAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NodeAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: NodeAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NodeAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNodeAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NodeAssignment model
   */
  readonly fields: NodeAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NodeAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NodeAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    node<T extends NodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NodeDefaultArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NodeAssignment model
   */
  interface NodeAssignmentFieldRefs {
    readonly id: FieldRef<"NodeAssignment", 'String'>
    readonly nodeId: FieldRef<"NodeAssignment", 'String'>
    readonly userId: FieldRef<"NodeAssignment", 'String'>
    readonly role: FieldRef<"NodeAssignment", 'NodeAssignmentRole'>
    readonly createdAt: FieldRef<"NodeAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"NodeAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NodeAssignment findUnique
   */
  export type NodeAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeAssignment
     */
    select?: NodeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeAssignment
     */
    omit?: NodeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which NodeAssignment to fetch.
     */
    where: NodeAssignmentWhereUniqueInput
  }

  /**
   * NodeAssignment findUniqueOrThrow
   */
  export type NodeAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeAssignment
     */
    select?: NodeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeAssignment
     */
    omit?: NodeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which NodeAssignment to fetch.
     */
    where: NodeAssignmentWhereUniqueInput
  }

  /**
   * NodeAssignment findFirst
   */
  export type NodeAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeAssignment
     */
    select?: NodeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeAssignment
     */
    omit?: NodeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which NodeAssignment to fetch.
     */
    where?: NodeAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeAssignments to fetch.
     */
    orderBy?: NodeAssignmentOrderByWithRelationInput | NodeAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NodeAssignments.
     */
    cursor?: NodeAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NodeAssignments.
     */
    distinct?: NodeAssignmentScalarFieldEnum | NodeAssignmentScalarFieldEnum[]
  }

  /**
   * NodeAssignment findFirstOrThrow
   */
  export type NodeAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeAssignment
     */
    select?: NodeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeAssignment
     */
    omit?: NodeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which NodeAssignment to fetch.
     */
    where?: NodeAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeAssignments to fetch.
     */
    orderBy?: NodeAssignmentOrderByWithRelationInput | NodeAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NodeAssignments.
     */
    cursor?: NodeAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NodeAssignments.
     */
    distinct?: NodeAssignmentScalarFieldEnum | NodeAssignmentScalarFieldEnum[]
  }

  /**
   * NodeAssignment findMany
   */
  export type NodeAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeAssignment
     */
    select?: NodeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeAssignment
     */
    omit?: NodeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which NodeAssignments to fetch.
     */
    where?: NodeAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeAssignments to fetch.
     */
    orderBy?: NodeAssignmentOrderByWithRelationInput | NodeAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NodeAssignments.
     */
    cursor?: NodeAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeAssignments.
     */
    skip?: number
    distinct?: NodeAssignmentScalarFieldEnum | NodeAssignmentScalarFieldEnum[]
  }

  /**
   * NodeAssignment create
   */
  export type NodeAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeAssignment
     */
    select?: NodeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeAssignment
     */
    omit?: NodeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a NodeAssignment.
     */
    data: XOR<NodeAssignmentCreateInput, NodeAssignmentUncheckedCreateInput>
  }

  /**
   * NodeAssignment createMany
   */
  export type NodeAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NodeAssignments.
     */
    data: NodeAssignmentCreateManyInput | NodeAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NodeAssignment createManyAndReturn
   */
  export type NodeAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeAssignment
     */
    select?: NodeAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NodeAssignment
     */
    omit?: NodeAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many NodeAssignments.
     */
    data: NodeAssignmentCreateManyInput | NodeAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NodeAssignment update
   */
  export type NodeAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeAssignment
     */
    select?: NodeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeAssignment
     */
    omit?: NodeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a NodeAssignment.
     */
    data: XOR<NodeAssignmentUpdateInput, NodeAssignmentUncheckedUpdateInput>
    /**
     * Choose, which NodeAssignment to update.
     */
    where: NodeAssignmentWhereUniqueInput
  }

  /**
   * NodeAssignment updateMany
   */
  export type NodeAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NodeAssignments.
     */
    data: XOR<NodeAssignmentUpdateManyMutationInput, NodeAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which NodeAssignments to update
     */
    where?: NodeAssignmentWhereInput
    /**
     * Limit how many NodeAssignments to update.
     */
    limit?: number
  }

  /**
   * NodeAssignment updateManyAndReturn
   */
  export type NodeAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeAssignment
     */
    select?: NodeAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NodeAssignment
     */
    omit?: NodeAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update NodeAssignments.
     */
    data: XOR<NodeAssignmentUpdateManyMutationInput, NodeAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which NodeAssignments to update
     */
    where?: NodeAssignmentWhereInput
    /**
     * Limit how many NodeAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NodeAssignment upsert
   */
  export type NodeAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeAssignment
     */
    select?: NodeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeAssignment
     */
    omit?: NodeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the NodeAssignment to update in case it exists.
     */
    where: NodeAssignmentWhereUniqueInput
    /**
     * In case the NodeAssignment found by the `where` argument doesn't exist, create a new NodeAssignment with this data.
     */
    create: XOR<NodeAssignmentCreateInput, NodeAssignmentUncheckedCreateInput>
    /**
     * In case the NodeAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NodeAssignmentUpdateInput, NodeAssignmentUncheckedUpdateInput>
  }

  /**
   * NodeAssignment delete
   */
  export type NodeAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeAssignment
     */
    select?: NodeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeAssignment
     */
    omit?: NodeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeAssignmentInclude<ExtArgs> | null
    /**
     * Filter which NodeAssignment to delete.
     */
    where: NodeAssignmentWhereUniqueInput
  }

  /**
   * NodeAssignment deleteMany
   */
  export type NodeAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NodeAssignments to delete
     */
    where?: NodeAssignmentWhereInput
    /**
     * Limit how many NodeAssignments to delete.
     */
    limit?: number
  }

  /**
   * NodeAssignment without action
   */
  export type NodeAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeAssignment
     */
    select?: NodeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeAssignment
     */
    omit?: NodeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model NodeDependency
   */

  export type AggregateNodeDependency = {
    _count: NodeDependencyCountAggregateOutputType | null
    _min: NodeDependencyMinAggregateOutputType | null
    _max: NodeDependencyMaxAggregateOutputType | null
  }

  export type NodeDependencyMinAggregateOutputType = {
    id: string | null
    blockedNodeId: string | null
    dependsOnNodeId: string | null
    createdAt: Date | null
  }

  export type NodeDependencyMaxAggregateOutputType = {
    id: string | null
    blockedNodeId: string | null
    dependsOnNodeId: string | null
    createdAt: Date | null
  }

  export type NodeDependencyCountAggregateOutputType = {
    id: number
    blockedNodeId: number
    dependsOnNodeId: number
    createdAt: number
    _all: number
  }


  export type NodeDependencyMinAggregateInputType = {
    id?: true
    blockedNodeId?: true
    dependsOnNodeId?: true
    createdAt?: true
  }

  export type NodeDependencyMaxAggregateInputType = {
    id?: true
    blockedNodeId?: true
    dependsOnNodeId?: true
    createdAt?: true
  }

  export type NodeDependencyCountAggregateInputType = {
    id?: true
    blockedNodeId?: true
    dependsOnNodeId?: true
    createdAt?: true
    _all?: true
  }

  export type NodeDependencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NodeDependency to aggregate.
     */
    where?: NodeDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeDependencies to fetch.
     */
    orderBy?: NodeDependencyOrderByWithRelationInput | NodeDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NodeDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeDependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NodeDependencies
    **/
    _count?: true | NodeDependencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NodeDependencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NodeDependencyMaxAggregateInputType
  }

  export type GetNodeDependencyAggregateType<T extends NodeDependencyAggregateArgs> = {
        [P in keyof T & keyof AggregateNodeDependency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNodeDependency[P]>
      : GetScalarType<T[P], AggregateNodeDependency[P]>
  }




  export type NodeDependencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NodeDependencyWhereInput
    orderBy?: NodeDependencyOrderByWithAggregationInput | NodeDependencyOrderByWithAggregationInput[]
    by: NodeDependencyScalarFieldEnum[] | NodeDependencyScalarFieldEnum
    having?: NodeDependencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NodeDependencyCountAggregateInputType | true
    _min?: NodeDependencyMinAggregateInputType
    _max?: NodeDependencyMaxAggregateInputType
  }

  export type NodeDependencyGroupByOutputType = {
    id: string
    blockedNodeId: string
    dependsOnNodeId: string
    createdAt: Date
    _count: NodeDependencyCountAggregateOutputType | null
    _min: NodeDependencyMinAggregateOutputType | null
    _max: NodeDependencyMaxAggregateOutputType | null
  }

  type GetNodeDependencyGroupByPayload<T extends NodeDependencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NodeDependencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NodeDependencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NodeDependencyGroupByOutputType[P]>
            : GetScalarType<T[P], NodeDependencyGroupByOutputType[P]>
        }
      >
    >


  export type NodeDependencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockedNodeId?: boolean
    dependsOnNodeId?: boolean
    createdAt?: boolean
    blockedNode?: boolean | NodeDefaultArgs<ExtArgs>
    dependsOnNode?: boolean | NodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nodeDependency"]>

  export type NodeDependencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockedNodeId?: boolean
    dependsOnNodeId?: boolean
    createdAt?: boolean
    blockedNode?: boolean | NodeDefaultArgs<ExtArgs>
    dependsOnNode?: boolean | NodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nodeDependency"]>

  export type NodeDependencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockedNodeId?: boolean
    dependsOnNodeId?: boolean
    createdAt?: boolean
    blockedNode?: boolean | NodeDefaultArgs<ExtArgs>
    dependsOnNode?: boolean | NodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nodeDependency"]>

  export type NodeDependencySelectScalar = {
    id?: boolean
    blockedNodeId?: boolean
    dependsOnNodeId?: boolean
    createdAt?: boolean
  }

  export type NodeDependencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "blockedNodeId" | "dependsOnNodeId" | "createdAt", ExtArgs["result"]["nodeDependency"]>
  export type NodeDependencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blockedNode?: boolean | NodeDefaultArgs<ExtArgs>
    dependsOnNode?: boolean | NodeDefaultArgs<ExtArgs>
  }
  export type NodeDependencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blockedNode?: boolean | NodeDefaultArgs<ExtArgs>
    dependsOnNode?: boolean | NodeDefaultArgs<ExtArgs>
  }
  export type NodeDependencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blockedNode?: boolean | NodeDefaultArgs<ExtArgs>
    dependsOnNode?: boolean | NodeDefaultArgs<ExtArgs>
  }

  export type $NodeDependencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NodeDependency"
    objects: {
      blockedNode: Prisma.$NodePayload<ExtArgs>
      dependsOnNode: Prisma.$NodePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      blockedNodeId: string
      dependsOnNodeId: string
      createdAt: Date
    }, ExtArgs["result"]["nodeDependency"]>
    composites: {}
  }

  type NodeDependencyGetPayload<S extends boolean | null | undefined | NodeDependencyDefaultArgs> = $Result.GetResult<Prisma.$NodeDependencyPayload, S>

  type NodeDependencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NodeDependencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NodeDependencyCountAggregateInputType | true
    }

  export interface NodeDependencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NodeDependency'], meta: { name: 'NodeDependency' } }
    /**
     * Find zero or one NodeDependency that matches the filter.
     * @param {NodeDependencyFindUniqueArgs} args - Arguments to find a NodeDependency
     * @example
     * // Get one NodeDependency
     * const nodeDependency = await prisma.nodeDependency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NodeDependencyFindUniqueArgs>(args: SelectSubset<T, NodeDependencyFindUniqueArgs<ExtArgs>>): Prisma__NodeDependencyClient<$Result.GetResult<Prisma.$NodeDependencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NodeDependency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NodeDependencyFindUniqueOrThrowArgs} args - Arguments to find a NodeDependency
     * @example
     * // Get one NodeDependency
     * const nodeDependency = await prisma.nodeDependency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NodeDependencyFindUniqueOrThrowArgs>(args: SelectSubset<T, NodeDependencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NodeDependencyClient<$Result.GetResult<Prisma.$NodeDependencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NodeDependency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeDependencyFindFirstArgs} args - Arguments to find a NodeDependency
     * @example
     * // Get one NodeDependency
     * const nodeDependency = await prisma.nodeDependency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NodeDependencyFindFirstArgs>(args?: SelectSubset<T, NodeDependencyFindFirstArgs<ExtArgs>>): Prisma__NodeDependencyClient<$Result.GetResult<Prisma.$NodeDependencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NodeDependency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeDependencyFindFirstOrThrowArgs} args - Arguments to find a NodeDependency
     * @example
     * // Get one NodeDependency
     * const nodeDependency = await prisma.nodeDependency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NodeDependencyFindFirstOrThrowArgs>(args?: SelectSubset<T, NodeDependencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__NodeDependencyClient<$Result.GetResult<Prisma.$NodeDependencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NodeDependencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeDependencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NodeDependencies
     * const nodeDependencies = await prisma.nodeDependency.findMany()
     * 
     * // Get first 10 NodeDependencies
     * const nodeDependencies = await prisma.nodeDependency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nodeDependencyWithIdOnly = await prisma.nodeDependency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NodeDependencyFindManyArgs>(args?: SelectSubset<T, NodeDependencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeDependencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NodeDependency.
     * @param {NodeDependencyCreateArgs} args - Arguments to create a NodeDependency.
     * @example
     * // Create one NodeDependency
     * const NodeDependency = await prisma.nodeDependency.create({
     *   data: {
     *     // ... data to create a NodeDependency
     *   }
     * })
     * 
     */
    create<T extends NodeDependencyCreateArgs>(args: SelectSubset<T, NodeDependencyCreateArgs<ExtArgs>>): Prisma__NodeDependencyClient<$Result.GetResult<Prisma.$NodeDependencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NodeDependencies.
     * @param {NodeDependencyCreateManyArgs} args - Arguments to create many NodeDependencies.
     * @example
     * // Create many NodeDependencies
     * const nodeDependency = await prisma.nodeDependency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NodeDependencyCreateManyArgs>(args?: SelectSubset<T, NodeDependencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NodeDependencies and returns the data saved in the database.
     * @param {NodeDependencyCreateManyAndReturnArgs} args - Arguments to create many NodeDependencies.
     * @example
     * // Create many NodeDependencies
     * const nodeDependency = await prisma.nodeDependency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NodeDependencies and only return the `id`
     * const nodeDependencyWithIdOnly = await prisma.nodeDependency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NodeDependencyCreateManyAndReturnArgs>(args?: SelectSubset<T, NodeDependencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeDependencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NodeDependency.
     * @param {NodeDependencyDeleteArgs} args - Arguments to delete one NodeDependency.
     * @example
     * // Delete one NodeDependency
     * const NodeDependency = await prisma.nodeDependency.delete({
     *   where: {
     *     // ... filter to delete one NodeDependency
     *   }
     * })
     * 
     */
    delete<T extends NodeDependencyDeleteArgs>(args: SelectSubset<T, NodeDependencyDeleteArgs<ExtArgs>>): Prisma__NodeDependencyClient<$Result.GetResult<Prisma.$NodeDependencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NodeDependency.
     * @param {NodeDependencyUpdateArgs} args - Arguments to update one NodeDependency.
     * @example
     * // Update one NodeDependency
     * const nodeDependency = await prisma.nodeDependency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NodeDependencyUpdateArgs>(args: SelectSubset<T, NodeDependencyUpdateArgs<ExtArgs>>): Prisma__NodeDependencyClient<$Result.GetResult<Prisma.$NodeDependencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NodeDependencies.
     * @param {NodeDependencyDeleteManyArgs} args - Arguments to filter NodeDependencies to delete.
     * @example
     * // Delete a few NodeDependencies
     * const { count } = await prisma.nodeDependency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NodeDependencyDeleteManyArgs>(args?: SelectSubset<T, NodeDependencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NodeDependencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeDependencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NodeDependencies
     * const nodeDependency = await prisma.nodeDependency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NodeDependencyUpdateManyArgs>(args: SelectSubset<T, NodeDependencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NodeDependencies and returns the data updated in the database.
     * @param {NodeDependencyUpdateManyAndReturnArgs} args - Arguments to update many NodeDependencies.
     * @example
     * // Update many NodeDependencies
     * const nodeDependency = await prisma.nodeDependency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NodeDependencies and only return the `id`
     * const nodeDependencyWithIdOnly = await prisma.nodeDependency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NodeDependencyUpdateManyAndReturnArgs>(args: SelectSubset<T, NodeDependencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodeDependencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NodeDependency.
     * @param {NodeDependencyUpsertArgs} args - Arguments to update or create a NodeDependency.
     * @example
     * // Update or create a NodeDependency
     * const nodeDependency = await prisma.nodeDependency.upsert({
     *   create: {
     *     // ... data to create a NodeDependency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NodeDependency we want to update
     *   }
     * })
     */
    upsert<T extends NodeDependencyUpsertArgs>(args: SelectSubset<T, NodeDependencyUpsertArgs<ExtArgs>>): Prisma__NodeDependencyClient<$Result.GetResult<Prisma.$NodeDependencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NodeDependencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeDependencyCountArgs} args - Arguments to filter NodeDependencies to count.
     * @example
     * // Count the number of NodeDependencies
     * const count = await prisma.nodeDependency.count({
     *   where: {
     *     // ... the filter for the NodeDependencies we want to count
     *   }
     * })
    **/
    count<T extends NodeDependencyCountArgs>(
      args?: Subset<T, NodeDependencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NodeDependencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NodeDependency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeDependencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NodeDependencyAggregateArgs>(args: Subset<T, NodeDependencyAggregateArgs>): Prisma.PrismaPromise<GetNodeDependencyAggregateType<T>>

    /**
     * Group by NodeDependency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NodeDependencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NodeDependencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NodeDependencyGroupByArgs['orderBy'] }
        : { orderBy?: NodeDependencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NodeDependencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNodeDependencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NodeDependency model
   */
  readonly fields: NodeDependencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NodeDependency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NodeDependencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blockedNode<T extends NodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NodeDefaultArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dependsOnNode<T extends NodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NodeDefaultArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NodeDependency model
   */
  interface NodeDependencyFieldRefs {
    readonly id: FieldRef<"NodeDependency", 'String'>
    readonly blockedNodeId: FieldRef<"NodeDependency", 'String'>
    readonly dependsOnNodeId: FieldRef<"NodeDependency", 'String'>
    readonly createdAt: FieldRef<"NodeDependency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NodeDependency findUnique
   */
  export type NodeDependencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeDependency
     */
    select?: NodeDependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeDependency
     */
    omit?: NodeDependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeDependencyInclude<ExtArgs> | null
    /**
     * Filter, which NodeDependency to fetch.
     */
    where: NodeDependencyWhereUniqueInput
  }

  /**
   * NodeDependency findUniqueOrThrow
   */
  export type NodeDependencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeDependency
     */
    select?: NodeDependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeDependency
     */
    omit?: NodeDependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeDependencyInclude<ExtArgs> | null
    /**
     * Filter, which NodeDependency to fetch.
     */
    where: NodeDependencyWhereUniqueInput
  }

  /**
   * NodeDependency findFirst
   */
  export type NodeDependencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeDependency
     */
    select?: NodeDependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeDependency
     */
    omit?: NodeDependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeDependencyInclude<ExtArgs> | null
    /**
     * Filter, which NodeDependency to fetch.
     */
    where?: NodeDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeDependencies to fetch.
     */
    orderBy?: NodeDependencyOrderByWithRelationInput | NodeDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NodeDependencies.
     */
    cursor?: NodeDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeDependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NodeDependencies.
     */
    distinct?: NodeDependencyScalarFieldEnum | NodeDependencyScalarFieldEnum[]
  }

  /**
   * NodeDependency findFirstOrThrow
   */
  export type NodeDependencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeDependency
     */
    select?: NodeDependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeDependency
     */
    omit?: NodeDependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeDependencyInclude<ExtArgs> | null
    /**
     * Filter, which NodeDependency to fetch.
     */
    where?: NodeDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeDependencies to fetch.
     */
    orderBy?: NodeDependencyOrderByWithRelationInput | NodeDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NodeDependencies.
     */
    cursor?: NodeDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeDependencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NodeDependencies.
     */
    distinct?: NodeDependencyScalarFieldEnum | NodeDependencyScalarFieldEnum[]
  }

  /**
   * NodeDependency findMany
   */
  export type NodeDependencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeDependency
     */
    select?: NodeDependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeDependency
     */
    omit?: NodeDependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeDependencyInclude<ExtArgs> | null
    /**
     * Filter, which NodeDependencies to fetch.
     */
    where?: NodeDependencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NodeDependencies to fetch.
     */
    orderBy?: NodeDependencyOrderByWithRelationInput | NodeDependencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NodeDependencies.
     */
    cursor?: NodeDependencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NodeDependencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NodeDependencies.
     */
    skip?: number
    distinct?: NodeDependencyScalarFieldEnum | NodeDependencyScalarFieldEnum[]
  }

  /**
   * NodeDependency create
   */
  export type NodeDependencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeDependency
     */
    select?: NodeDependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeDependency
     */
    omit?: NodeDependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeDependencyInclude<ExtArgs> | null
    /**
     * The data needed to create a NodeDependency.
     */
    data: XOR<NodeDependencyCreateInput, NodeDependencyUncheckedCreateInput>
  }

  /**
   * NodeDependency createMany
   */
  export type NodeDependencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NodeDependencies.
     */
    data: NodeDependencyCreateManyInput | NodeDependencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NodeDependency createManyAndReturn
   */
  export type NodeDependencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeDependency
     */
    select?: NodeDependencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NodeDependency
     */
    omit?: NodeDependencyOmit<ExtArgs> | null
    /**
     * The data used to create many NodeDependencies.
     */
    data: NodeDependencyCreateManyInput | NodeDependencyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeDependencyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NodeDependency update
   */
  export type NodeDependencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeDependency
     */
    select?: NodeDependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeDependency
     */
    omit?: NodeDependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeDependencyInclude<ExtArgs> | null
    /**
     * The data needed to update a NodeDependency.
     */
    data: XOR<NodeDependencyUpdateInput, NodeDependencyUncheckedUpdateInput>
    /**
     * Choose, which NodeDependency to update.
     */
    where: NodeDependencyWhereUniqueInput
  }

  /**
   * NodeDependency updateMany
   */
  export type NodeDependencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NodeDependencies.
     */
    data: XOR<NodeDependencyUpdateManyMutationInput, NodeDependencyUncheckedUpdateManyInput>
    /**
     * Filter which NodeDependencies to update
     */
    where?: NodeDependencyWhereInput
    /**
     * Limit how many NodeDependencies to update.
     */
    limit?: number
  }

  /**
   * NodeDependency updateManyAndReturn
   */
  export type NodeDependencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeDependency
     */
    select?: NodeDependencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NodeDependency
     */
    omit?: NodeDependencyOmit<ExtArgs> | null
    /**
     * The data used to update NodeDependencies.
     */
    data: XOR<NodeDependencyUpdateManyMutationInput, NodeDependencyUncheckedUpdateManyInput>
    /**
     * Filter which NodeDependencies to update
     */
    where?: NodeDependencyWhereInput
    /**
     * Limit how many NodeDependencies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeDependencyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NodeDependency upsert
   */
  export type NodeDependencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeDependency
     */
    select?: NodeDependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeDependency
     */
    omit?: NodeDependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeDependencyInclude<ExtArgs> | null
    /**
     * The filter to search for the NodeDependency to update in case it exists.
     */
    where: NodeDependencyWhereUniqueInput
    /**
     * In case the NodeDependency found by the `where` argument doesn't exist, create a new NodeDependency with this data.
     */
    create: XOR<NodeDependencyCreateInput, NodeDependencyUncheckedCreateInput>
    /**
     * In case the NodeDependency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NodeDependencyUpdateInput, NodeDependencyUncheckedUpdateInput>
  }

  /**
   * NodeDependency delete
   */
  export type NodeDependencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeDependency
     */
    select?: NodeDependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeDependency
     */
    omit?: NodeDependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeDependencyInclude<ExtArgs> | null
    /**
     * Filter which NodeDependency to delete.
     */
    where: NodeDependencyWhereUniqueInput
  }

  /**
   * NodeDependency deleteMany
   */
  export type NodeDependencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NodeDependencies to delete
     */
    where?: NodeDependencyWhereInput
    /**
     * Limit how many NodeDependencies to delete.
     */
    limit?: number
  }

  /**
   * NodeDependency without action
   */
  export type NodeDependencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NodeDependency
     */
    select?: NodeDependencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the NodeDependency
     */
    omit?: NodeDependencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NodeDependencyInclude<ExtArgs> | null
  }


  /**
   * Model KpiDefinition
   */

  export type AggregateKpiDefinition = {
    _count: KpiDefinitionCountAggregateOutputType | null
    _avg: KpiDefinitionAvgAggregateOutputType | null
    _sum: KpiDefinitionSumAggregateOutputType | null
    _min: KpiDefinitionMinAggregateOutputType | null
    _max: KpiDefinitionMaxAggregateOutputType | null
  }

  export type KpiDefinitionAvgAggregateOutputType = {
    baselineValue: number | null
    targetValue: number | null
    weight: number | null
  }

  export type KpiDefinitionSumAggregateOutputType = {
    baselineValue: number | null
    targetValue: number | null
    weight: number | null
  }

  export type KpiDefinitionMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    primaryNodeId: string | null
    ownerUserId: string | null
    name: string | null
    description: string | null
    formula: string | null
    unit: string | null
    direction: $Enums.KpiDirection | null
    aggregation: $Enums.KpiAggregationMethod | null
    periodType: $Enums.KpiPeriodType | null
    baselineValue: number | null
    targetValue: number | null
    weight: number | null
    status: $Enums.KpiDefinitionStatus | null
  }

  export type KpiDefinitionMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    primaryNodeId: string | null
    ownerUserId: string | null
    name: string | null
    description: string | null
    formula: string | null
    unit: string | null
    direction: $Enums.KpiDirection | null
    aggregation: $Enums.KpiAggregationMethod | null
    periodType: $Enums.KpiPeriodType | null
    baselineValue: number | null
    targetValue: number | null
    weight: number | null
    status: $Enums.KpiDefinitionStatus | null
  }

  export type KpiDefinitionCountAggregateOutputType = {
    id: number
    orgId: number
    primaryNodeId: number
    ownerUserId: number
    name: number
    description: number
    formula: number
    unit: number
    direction: number
    aggregation: number
    periodType: number
    baselineValue: number
    targetValue: number
    weight: number
    status: number
    _all: number
  }


  export type KpiDefinitionAvgAggregateInputType = {
    baselineValue?: true
    targetValue?: true
    weight?: true
  }

  export type KpiDefinitionSumAggregateInputType = {
    baselineValue?: true
    targetValue?: true
    weight?: true
  }

  export type KpiDefinitionMinAggregateInputType = {
    id?: true
    orgId?: true
    primaryNodeId?: true
    ownerUserId?: true
    name?: true
    description?: true
    formula?: true
    unit?: true
    direction?: true
    aggregation?: true
    periodType?: true
    baselineValue?: true
    targetValue?: true
    weight?: true
    status?: true
  }

  export type KpiDefinitionMaxAggregateInputType = {
    id?: true
    orgId?: true
    primaryNodeId?: true
    ownerUserId?: true
    name?: true
    description?: true
    formula?: true
    unit?: true
    direction?: true
    aggregation?: true
    periodType?: true
    baselineValue?: true
    targetValue?: true
    weight?: true
    status?: true
  }

  export type KpiDefinitionCountAggregateInputType = {
    id?: true
    orgId?: true
    primaryNodeId?: true
    ownerUserId?: true
    name?: true
    description?: true
    formula?: true
    unit?: true
    direction?: true
    aggregation?: true
    periodType?: true
    baselineValue?: true
    targetValue?: true
    weight?: true
    status?: true
    _all?: true
  }

  export type KpiDefinitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KpiDefinition to aggregate.
     */
    where?: KpiDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiDefinitions to fetch.
     */
    orderBy?: KpiDefinitionOrderByWithRelationInput | KpiDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KpiDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KpiDefinitions
    **/
    _count?: true | KpiDefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KpiDefinitionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KpiDefinitionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KpiDefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KpiDefinitionMaxAggregateInputType
  }

  export type GetKpiDefinitionAggregateType<T extends KpiDefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregateKpiDefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKpiDefinition[P]>
      : GetScalarType<T[P], AggregateKpiDefinition[P]>
  }




  export type KpiDefinitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KpiDefinitionWhereInput
    orderBy?: KpiDefinitionOrderByWithAggregationInput | KpiDefinitionOrderByWithAggregationInput[]
    by: KpiDefinitionScalarFieldEnum[] | KpiDefinitionScalarFieldEnum
    having?: KpiDefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KpiDefinitionCountAggregateInputType | true
    _avg?: KpiDefinitionAvgAggregateInputType
    _sum?: KpiDefinitionSumAggregateInputType
    _min?: KpiDefinitionMinAggregateInputType
    _max?: KpiDefinitionMaxAggregateInputType
  }

  export type KpiDefinitionGroupByOutputType = {
    id: string
    orgId: string
    primaryNodeId: string
    ownerUserId: string | null
    name: string
    description: string | null
    formula: string | null
    unit: string | null
    direction: $Enums.KpiDirection
    aggregation: $Enums.KpiAggregationMethod
    periodType: $Enums.KpiPeriodType
    baselineValue: number | null
    targetValue: number | null
    weight: number | null
    status: $Enums.KpiDefinitionStatus
    _count: KpiDefinitionCountAggregateOutputType | null
    _avg: KpiDefinitionAvgAggregateOutputType | null
    _sum: KpiDefinitionSumAggregateOutputType | null
    _min: KpiDefinitionMinAggregateOutputType | null
    _max: KpiDefinitionMaxAggregateOutputType | null
  }

  type GetKpiDefinitionGroupByPayload<T extends KpiDefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KpiDefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KpiDefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KpiDefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], KpiDefinitionGroupByOutputType[P]>
        }
      >
    >


  export type KpiDefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    primaryNodeId?: boolean
    ownerUserId?: boolean
    name?: boolean
    description?: boolean
    formula?: boolean
    unit?: boolean
    direction?: boolean
    aggregation?: boolean
    periodType?: boolean
    baselineValue?: boolean
    targetValue?: boolean
    weight?: boolean
    status?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    primaryNode?: boolean | NodeDefaultArgs<ExtArgs>
    ownerUser?: boolean | KpiDefinition$ownerUserArgs<ExtArgs>
    variables?: boolean | KpiDefinition$variablesArgs<ExtArgs>
    values?: boolean | KpiDefinition$valuesArgs<ExtArgs>
    _count?: boolean | KpiDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kpiDefinition"]>

  export type KpiDefinitionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    primaryNodeId?: boolean
    ownerUserId?: boolean
    name?: boolean
    description?: boolean
    formula?: boolean
    unit?: boolean
    direction?: boolean
    aggregation?: boolean
    periodType?: boolean
    baselineValue?: boolean
    targetValue?: boolean
    weight?: boolean
    status?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    primaryNode?: boolean | NodeDefaultArgs<ExtArgs>
    ownerUser?: boolean | KpiDefinition$ownerUserArgs<ExtArgs>
  }, ExtArgs["result"]["kpiDefinition"]>

  export type KpiDefinitionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    primaryNodeId?: boolean
    ownerUserId?: boolean
    name?: boolean
    description?: boolean
    formula?: boolean
    unit?: boolean
    direction?: boolean
    aggregation?: boolean
    periodType?: boolean
    baselineValue?: boolean
    targetValue?: boolean
    weight?: boolean
    status?: boolean
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    primaryNode?: boolean | NodeDefaultArgs<ExtArgs>
    ownerUser?: boolean | KpiDefinition$ownerUserArgs<ExtArgs>
  }, ExtArgs["result"]["kpiDefinition"]>

  export type KpiDefinitionSelectScalar = {
    id?: boolean
    orgId?: boolean
    primaryNodeId?: boolean
    ownerUserId?: boolean
    name?: boolean
    description?: boolean
    formula?: boolean
    unit?: boolean
    direction?: boolean
    aggregation?: boolean
    periodType?: boolean
    baselineValue?: boolean
    targetValue?: boolean
    weight?: boolean
    status?: boolean
  }

  export type KpiDefinitionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "primaryNodeId" | "ownerUserId" | "name" | "description" | "formula" | "unit" | "direction" | "aggregation" | "periodType" | "baselineValue" | "targetValue" | "weight" | "status", ExtArgs["result"]["kpiDefinition"]>
  export type KpiDefinitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    primaryNode?: boolean | NodeDefaultArgs<ExtArgs>
    ownerUser?: boolean | KpiDefinition$ownerUserArgs<ExtArgs>
    variables?: boolean | KpiDefinition$variablesArgs<ExtArgs>
    values?: boolean | KpiDefinition$valuesArgs<ExtArgs>
    _count?: boolean | KpiDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KpiDefinitionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    primaryNode?: boolean | NodeDefaultArgs<ExtArgs>
    ownerUser?: boolean | KpiDefinition$ownerUserArgs<ExtArgs>
  }
  export type KpiDefinitionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    org?: boolean | OrganizationDefaultArgs<ExtArgs>
    primaryNode?: boolean | NodeDefaultArgs<ExtArgs>
    ownerUser?: boolean | KpiDefinition$ownerUserArgs<ExtArgs>
  }

  export type $KpiDefinitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KpiDefinition"
    objects: {
      org: Prisma.$OrganizationPayload<ExtArgs>
      primaryNode: Prisma.$NodePayload<ExtArgs>
      ownerUser: Prisma.$UserPayload<ExtArgs> | null
      variables: Prisma.$KpiVariablePayload<ExtArgs>[]
      values: Prisma.$KpiValuePeriodPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      primaryNodeId: string
      ownerUserId: string | null
      name: string
      description: string | null
      formula: string | null
      unit: string | null
      direction: $Enums.KpiDirection
      aggregation: $Enums.KpiAggregationMethod
      periodType: $Enums.KpiPeriodType
      baselineValue: number | null
      targetValue: number | null
      weight: number | null
      status: $Enums.KpiDefinitionStatus
    }, ExtArgs["result"]["kpiDefinition"]>
    composites: {}
  }

  type KpiDefinitionGetPayload<S extends boolean | null | undefined | KpiDefinitionDefaultArgs> = $Result.GetResult<Prisma.$KpiDefinitionPayload, S>

  type KpiDefinitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KpiDefinitionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KpiDefinitionCountAggregateInputType | true
    }

  export interface KpiDefinitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KpiDefinition'], meta: { name: 'KpiDefinition' } }
    /**
     * Find zero or one KpiDefinition that matches the filter.
     * @param {KpiDefinitionFindUniqueArgs} args - Arguments to find a KpiDefinition
     * @example
     * // Get one KpiDefinition
     * const kpiDefinition = await prisma.kpiDefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KpiDefinitionFindUniqueArgs>(args: SelectSubset<T, KpiDefinitionFindUniqueArgs<ExtArgs>>): Prisma__KpiDefinitionClient<$Result.GetResult<Prisma.$KpiDefinitionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KpiDefinition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KpiDefinitionFindUniqueOrThrowArgs} args - Arguments to find a KpiDefinition
     * @example
     * // Get one KpiDefinition
     * const kpiDefinition = await prisma.kpiDefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KpiDefinitionFindUniqueOrThrowArgs>(args: SelectSubset<T, KpiDefinitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KpiDefinitionClient<$Result.GetResult<Prisma.$KpiDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KpiDefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiDefinitionFindFirstArgs} args - Arguments to find a KpiDefinition
     * @example
     * // Get one KpiDefinition
     * const kpiDefinition = await prisma.kpiDefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KpiDefinitionFindFirstArgs>(args?: SelectSubset<T, KpiDefinitionFindFirstArgs<ExtArgs>>): Prisma__KpiDefinitionClient<$Result.GetResult<Prisma.$KpiDefinitionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KpiDefinition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiDefinitionFindFirstOrThrowArgs} args - Arguments to find a KpiDefinition
     * @example
     * // Get one KpiDefinition
     * const kpiDefinition = await prisma.kpiDefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KpiDefinitionFindFirstOrThrowArgs>(args?: SelectSubset<T, KpiDefinitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__KpiDefinitionClient<$Result.GetResult<Prisma.$KpiDefinitionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KpiDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiDefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KpiDefinitions
     * const kpiDefinitions = await prisma.kpiDefinition.findMany()
     * 
     * // Get first 10 KpiDefinitions
     * const kpiDefinitions = await prisma.kpiDefinition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kpiDefinitionWithIdOnly = await prisma.kpiDefinition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KpiDefinitionFindManyArgs>(args?: SelectSubset<T, KpiDefinitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KpiDefinition.
     * @param {KpiDefinitionCreateArgs} args - Arguments to create a KpiDefinition.
     * @example
     * // Create one KpiDefinition
     * const KpiDefinition = await prisma.kpiDefinition.create({
     *   data: {
     *     // ... data to create a KpiDefinition
     *   }
     * })
     * 
     */
    create<T extends KpiDefinitionCreateArgs>(args: SelectSubset<T, KpiDefinitionCreateArgs<ExtArgs>>): Prisma__KpiDefinitionClient<$Result.GetResult<Prisma.$KpiDefinitionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KpiDefinitions.
     * @param {KpiDefinitionCreateManyArgs} args - Arguments to create many KpiDefinitions.
     * @example
     * // Create many KpiDefinitions
     * const kpiDefinition = await prisma.kpiDefinition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KpiDefinitionCreateManyArgs>(args?: SelectSubset<T, KpiDefinitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KpiDefinitions and returns the data saved in the database.
     * @param {KpiDefinitionCreateManyAndReturnArgs} args - Arguments to create many KpiDefinitions.
     * @example
     * // Create many KpiDefinitions
     * const kpiDefinition = await prisma.kpiDefinition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KpiDefinitions and only return the `id`
     * const kpiDefinitionWithIdOnly = await prisma.kpiDefinition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KpiDefinitionCreateManyAndReturnArgs>(args?: SelectSubset<T, KpiDefinitionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiDefinitionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KpiDefinition.
     * @param {KpiDefinitionDeleteArgs} args - Arguments to delete one KpiDefinition.
     * @example
     * // Delete one KpiDefinition
     * const KpiDefinition = await prisma.kpiDefinition.delete({
     *   where: {
     *     // ... filter to delete one KpiDefinition
     *   }
     * })
     * 
     */
    delete<T extends KpiDefinitionDeleteArgs>(args: SelectSubset<T, KpiDefinitionDeleteArgs<ExtArgs>>): Prisma__KpiDefinitionClient<$Result.GetResult<Prisma.$KpiDefinitionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KpiDefinition.
     * @param {KpiDefinitionUpdateArgs} args - Arguments to update one KpiDefinition.
     * @example
     * // Update one KpiDefinition
     * const kpiDefinition = await prisma.kpiDefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KpiDefinitionUpdateArgs>(args: SelectSubset<T, KpiDefinitionUpdateArgs<ExtArgs>>): Prisma__KpiDefinitionClient<$Result.GetResult<Prisma.$KpiDefinitionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KpiDefinitions.
     * @param {KpiDefinitionDeleteManyArgs} args - Arguments to filter KpiDefinitions to delete.
     * @example
     * // Delete a few KpiDefinitions
     * const { count } = await prisma.kpiDefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KpiDefinitionDeleteManyArgs>(args?: SelectSubset<T, KpiDefinitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KpiDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KpiDefinitions
     * const kpiDefinition = await prisma.kpiDefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KpiDefinitionUpdateManyArgs>(args: SelectSubset<T, KpiDefinitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KpiDefinitions and returns the data updated in the database.
     * @param {KpiDefinitionUpdateManyAndReturnArgs} args - Arguments to update many KpiDefinitions.
     * @example
     * // Update many KpiDefinitions
     * const kpiDefinition = await prisma.kpiDefinition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KpiDefinitions and only return the `id`
     * const kpiDefinitionWithIdOnly = await prisma.kpiDefinition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KpiDefinitionUpdateManyAndReturnArgs>(args: SelectSubset<T, KpiDefinitionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiDefinitionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KpiDefinition.
     * @param {KpiDefinitionUpsertArgs} args - Arguments to update or create a KpiDefinition.
     * @example
     * // Update or create a KpiDefinition
     * const kpiDefinition = await prisma.kpiDefinition.upsert({
     *   create: {
     *     // ... data to create a KpiDefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KpiDefinition we want to update
     *   }
     * })
     */
    upsert<T extends KpiDefinitionUpsertArgs>(args: SelectSubset<T, KpiDefinitionUpsertArgs<ExtArgs>>): Prisma__KpiDefinitionClient<$Result.GetResult<Prisma.$KpiDefinitionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KpiDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiDefinitionCountArgs} args - Arguments to filter KpiDefinitions to count.
     * @example
     * // Count the number of KpiDefinitions
     * const count = await prisma.kpiDefinition.count({
     *   where: {
     *     // ... the filter for the KpiDefinitions we want to count
     *   }
     * })
    **/
    count<T extends KpiDefinitionCountArgs>(
      args?: Subset<T, KpiDefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KpiDefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KpiDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiDefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KpiDefinitionAggregateArgs>(args: Subset<T, KpiDefinitionAggregateArgs>): Prisma.PrismaPromise<GetKpiDefinitionAggregateType<T>>

    /**
     * Group by KpiDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiDefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KpiDefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KpiDefinitionGroupByArgs['orderBy'] }
        : { orderBy?: KpiDefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KpiDefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKpiDefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KpiDefinition model
   */
  readonly fields: KpiDefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KpiDefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KpiDefinitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    org<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    primaryNode<T extends NodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NodeDefaultArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ownerUser<T extends KpiDefinition$ownerUserArgs<ExtArgs> = {}>(args?: Subset<T, KpiDefinition$ownerUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    variables<T extends KpiDefinition$variablesArgs<ExtArgs> = {}>(args?: Subset<T, KpiDefinition$variablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiVariablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    values<T extends KpiDefinition$valuesArgs<ExtArgs> = {}>(args?: Subset<T, KpiDefinition$valuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiValuePeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KpiDefinition model
   */
  interface KpiDefinitionFieldRefs {
    readonly id: FieldRef<"KpiDefinition", 'String'>
    readonly orgId: FieldRef<"KpiDefinition", 'String'>
    readonly primaryNodeId: FieldRef<"KpiDefinition", 'String'>
    readonly ownerUserId: FieldRef<"KpiDefinition", 'String'>
    readonly name: FieldRef<"KpiDefinition", 'String'>
    readonly description: FieldRef<"KpiDefinition", 'String'>
    readonly formula: FieldRef<"KpiDefinition", 'String'>
    readonly unit: FieldRef<"KpiDefinition", 'String'>
    readonly direction: FieldRef<"KpiDefinition", 'KpiDirection'>
    readonly aggregation: FieldRef<"KpiDefinition", 'KpiAggregationMethod'>
    readonly periodType: FieldRef<"KpiDefinition", 'KpiPeriodType'>
    readonly baselineValue: FieldRef<"KpiDefinition", 'Float'>
    readonly targetValue: FieldRef<"KpiDefinition", 'Float'>
    readonly weight: FieldRef<"KpiDefinition", 'Float'>
    readonly status: FieldRef<"KpiDefinition", 'KpiDefinitionStatus'>
  }
    

  // Custom InputTypes
  /**
   * KpiDefinition findUnique
   */
  export type KpiDefinitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiDefinition
     */
    select?: KpiDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiDefinition
     */
    omit?: KpiDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which KpiDefinition to fetch.
     */
    where: KpiDefinitionWhereUniqueInput
  }

  /**
   * KpiDefinition findUniqueOrThrow
   */
  export type KpiDefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiDefinition
     */
    select?: KpiDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiDefinition
     */
    omit?: KpiDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which KpiDefinition to fetch.
     */
    where: KpiDefinitionWhereUniqueInput
  }

  /**
   * KpiDefinition findFirst
   */
  export type KpiDefinitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiDefinition
     */
    select?: KpiDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiDefinition
     */
    omit?: KpiDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which KpiDefinition to fetch.
     */
    where?: KpiDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiDefinitions to fetch.
     */
    orderBy?: KpiDefinitionOrderByWithRelationInput | KpiDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KpiDefinitions.
     */
    cursor?: KpiDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KpiDefinitions.
     */
    distinct?: KpiDefinitionScalarFieldEnum | KpiDefinitionScalarFieldEnum[]
  }

  /**
   * KpiDefinition findFirstOrThrow
   */
  export type KpiDefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiDefinition
     */
    select?: KpiDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiDefinition
     */
    omit?: KpiDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which KpiDefinition to fetch.
     */
    where?: KpiDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiDefinitions to fetch.
     */
    orderBy?: KpiDefinitionOrderByWithRelationInput | KpiDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KpiDefinitions.
     */
    cursor?: KpiDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KpiDefinitions.
     */
    distinct?: KpiDefinitionScalarFieldEnum | KpiDefinitionScalarFieldEnum[]
  }

  /**
   * KpiDefinition findMany
   */
  export type KpiDefinitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiDefinition
     */
    select?: KpiDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiDefinition
     */
    omit?: KpiDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which KpiDefinitions to fetch.
     */
    where?: KpiDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiDefinitions to fetch.
     */
    orderBy?: KpiDefinitionOrderByWithRelationInput | KpiDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KpiDefinitions.
     */
    cursor?: KpiDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiDefinitions.
     */
    skip?: number
    distinct?: KpiDefinitionScalarFieldEnum | KpiDefinitionScalarFieldEnum[]
  }

  /**
   * KpiDefinition create
   */
  export type KpiDefinitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiDefinition
     */
    select?: KpiDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiDefinition
     */
    omit?: KpiDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to create a KpiDefinition.
     */
    data: XOR<KpiDefinitionCreateInput, KpiDefinitionUncheckedCreateInput>
  }

  /**
   * KpiDefinition createMany
   */
  export type KpiDefinitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KpiDefinitions.
     */
    data: KpiDefinitionCreateManyInput | KpiDefinitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KpiDefinition createManyAndReturn
   */
  export type KpiDefinitionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiDefinition
     */
    select?: KpiDefinitionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KpiDefinition
     */
    omit?: KpiDefinitionOmit<ExtArgs> | null
    /**
     * The data used to create many KpiDefinitions.
     */
    data: KpiDefinitionCreateManyInput | KpiDefinitionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiDefinitionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KpiDefinition update
   */
  export type KpiDefinitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiDefinition
     */
    select?: KpiDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiDefinition
     */
    omit?: KpiDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to update a KpiDefinition.
     */
    data: XOR<KpiDefinitionUpdateInput, KpiDefinitionUncheckedUpdateInput>
    /**
     * Choose, which KpiDefinition to update.
     */
    where: KpiDefinitionWhereUniqueInput
  }

  /**
   * KpiDefinition updateMany
   */
  export type KpiDefinitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KpiDefinitions.
     */
    data: XOR<KpiDefinitionUpdateManyMutationInput, KpiDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which KpiDefinitions to update
     */
    where?: KpiDefinitionWhereInput
    /**
     * Limit how many KpiDefinitions to update.
     */
    limit?: number
  }

  /**
   * KpiDefinition updateManyAndReturn
   */
  export type KpiDefinitionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiDefinition
     */
    select?: KpiDefinitionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KpiDefinition
     */
    omit?: KpiDefinitionOmit<ExtArgs> | null
    /**
     * The data used to update KpiDefinitions.
     */
    data: XOR<KpiDefinitionUpdateManyMutationInput, KpiDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which KpiDefinitions to update
     */
    where?: KpiDefinitionWhereInput
    /**
     * Limit how many KpiDefinitions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiDefinitionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KpiDefinition upsert
   */
  export type KpiDefinitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiDefinition
     */
    select?: KpiDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiDefinition
     */
    omit?: KpiDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiDefinitionInclude<ExtArgs> | null
    /**
     * The filter to search for the KpiDefinition to update in case it exists.
     */
    where: KpiDefinitionWhereUniqueInput
    /**
     * In case the KpiDefinition found by the `where` argument doesn't exist, create a new KpiDefinition with this data.
     */
    create: XOR<KpiDefinitionCreateInput, KpiDefinitionUncheckedCreateInput>
    /**
     * In case the KpiDefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KpiDefinitionUpdateInput, KpiDefinitionUncheckedUpdateInput>
  }

  /**
   * KpiDefinition delete
   */
  export type KpiDefinitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiDefinition
     */
    select?: KpiDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiDefinition
     */
    omit?: KpiDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiDefinitionInclude<ExtArgs> | null
    /**
     * Filter which KpiDefinition to delete.
     */
    where: KpiDefinitionWhereUniqueInput
  }

  /**
   * KpiDefinition deleteMany
   */
  export type KpiDefinitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KpiDefinitions to delete
     */
    where?: KpiDefinitionWhereInput
    /**
     * Limit how many KpiDefinitions to delete.
     */
    limit?: number
  }

  /**
   * KpiDefinition.ownerUser
   */
  export type KpiDefinition$ownerUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * KpiDefinition.variables
   */
  export type KpiDefinition$variablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariable
     */
    select?: KpiVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariable
     */
    omit?: KpiVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableInclude<ExtArgs> | null
    where?: KpiVariableWhereInput
    orderBy?: KpiVariableOrderByWithRelationInput | KpiVariableOrderByWithRelationInput[]
    cursor?: KpiVariableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KpiVariableScalarFieldEnum | KpiVariableScalarFieldEnum[]
  }

  /**
   * KpiDefinition.values
   */
  export type KpiDefinition$valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiValuePeriod
     */
    select?: KpiValuePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiValuePeriod
     */
    omit?: KpiValuePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiValuePeriodInclude<ExtArgs> | null
    where?: KpiValuePeriodWhereInput
    orderBy?: KpiValuePeriodOrderByWithRelationInput | KpiValuePeriodOrderByWithRelationInput[]
    cursor?: KpiValuePeriodWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KpiValuePeriodScalarFieldEnum | KpiValuePeriodScalarFieldEnum[]
  }

  /**
   * KpiDefinition without action
   */
  export type KpiDefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiDefinition
     */
    select?: KpiDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiDefinition
     */
    omit?: KpiDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiDefinitionInclude<ExtArgs> | null
  }


  /**
   * Model KpiVariable
   */

  export type AggregateKpiVariable = {
    _count: KpiVariableCountAggregateOutputType | null
    _min: KpiVariableMinAggregateOutputType | null
    _max: KpiVariableMaxAggregateOutputType | null
  }

  export type KpiVariableMinAggregateOutputType = {
    id: string | null
    kpiId: string | null
    code: string | null
    displayName: string | null
    dataType: $Enums.KpiVariableDataType | null
    isRequired: boolean | null
  }

  export type KpiVariableMaxAggregateOutputType = {
    id: string | null
    kpiId: string | null
    code: string | null
    displayName: string | null
    dataType: $Enums.KpiVariableDataType | null
    isRequired: boolean | null
  }

  export type KpiVariableCountAggregateOutputType = {
    id: number
    kpiId: number
    code: number
    displayName: number
    dataType: number
    isRequired: number
    _all: number
  }


  export type KpiVariableMinAggregateInputType = {
    id?: true
    kpiId?: true
    code?: true
    displayName?: true
    dataType?: true
    isRequired?: true
  }

  export type KpiVariableMaxAggregateInputType = {
    id?: true
    kpiId?: true
    code?: true
    displayName?: true
    dataType?: true
    isRequired?: true
  }

  export type KpiVariableCountAggregateInputType = {
    id?: true
    kpiId?: true
    code?: true
    displayName?: true
    dataType?: true
    isRequired?: true
    _all?: true
  }

  export type KpiVariableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KpiVariable to aggregate.
     */
    where?: KpiVariableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiVariables to fetch.
     */
    orderBy?: KpiVariableOrderByWithRelationInput | KpiVariableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KpiVariableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiVariables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiVariables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KpiVariables
    **/
    _count?: true | KpiVariableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KpiVariableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KpiVariableMaxAggregateInputType
  }

  export type GetKpiVariableAggregateType<T extends KpiVariableAggregateArgs> = {
        [P in keyof T & keyof AggregateKpiVariable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKpiVariable[P]>
      : GetScalarType<T[P], AggregateKpiVariable[P]>
  }




  export type KpiVariableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KpiVariableWhereInput
    orderBy?: KpiVariableOrderByWithAggregationInput | KpiVariableOrderByWithAggregationInput[]
    by: KpiVariableScalarFieldEnum[] | KpiVariableScalarFieldEnum
    having?: KpiVariableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KpiVariableCountAggregateInputType | true
    _min?: KpiVariableMinAggregateInputType
    _max?: KpiVariableMaxAggregateInputType
  }

  export type KpiVariableGroupByOutputType = {
    id: string
    kpiId: string
    code: string
    displayName: string
    dataType: $Enums.KpiVariableDataType
    isRequired: boolean
    _count: KpiVariableCountAggregateOutputType | null
    _min: KpiVariableMinAggregateOutputType | null
    _max: KpiVariableMaxAggregateOutputType | null
  }

  type GetKpiVariableGroupByPayload<T extends KpiVariableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KpiVariableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KpiVariableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KpiVariableGroupByOutputType[P]>
            : GetScalarType<T[P], KpiVariableGroupByOutputType[P]>
        }
      >
    >


  export type KpiVariableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kpiId?: boolean
    code?: boolean
    displayName?: boolean
    dataType?: boolean
    isRequired?: boolean
    kpi?: boolean | KpiDefinitionDefaultArgs<ExtArgs>
    values?: boolean | KpiVariable$valuesArgs<ExtArgs>
    _count?: boolean | KpiVariableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kpiVariable"]>

  export type KpiVariableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kpiId?: boolean
    code?: boolean
    displayName?: boolean
    dataType?: boolean
    isRequired?: boolean
    kpi?: boolean | KpiDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kpiVariable"]>

  export type KpiVariableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kpiId?: boolean
    code?: boolean
    displayName?: boolean
    dataType?: boolean
    isRequired?: boolean
    kpi?: boolean | KpiDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kpiVariable"]>

  export type KpiVariableSelectScalar = {
    id?: boolean
    kpiId?: boolean
    code?: boolean
    displayName?: boolean
    dataType?: boolean
    isRequired?: boolean
  }

  export type KpiVariableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "kpiId" | "code" | "displayName" | "dataType" | "isRequired", ExtArgs["result"]["kpiVariable"]>
  export type KpiVariableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kpi?: boolean | KpiDefinitionDefaultArgs<ExtArgs>
    values?: boolean | KpiVariable$valuesArgs<ExtArgs>
    _count?: boolean | KpiVariableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KpiVariableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kpi?: boolean | KpiDefinitionDefaultArgs<ExtArgs>
  }
  export type KpiVariableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kpi?: boolean | KpiDefinitionDefaultArgs<ExtArgs>
  }

  export type $KpiVariablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KpiVariable"
    objects: {
      kpi: Prisma.$KpiDefinitionPayload<ExtArgs>
      values: Prisma.$KpiVariableValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      kpiId: string
      code: string
      displayName: string
      dataType: $Enums.KpiVariableDataType
      isRequired: boolean
    }, ExtArgs["result"]["kpiVariable"]>
    composites: {}
  }

  type KpiVariableGetPayload<S extends boolean | null | undefined | KpiVariableDefaultArgs> = $Result.GetResult<Prisma.$KpiVariablePayload, S>

  type KpiVariableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KpiVariableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KpiVariableCountAggregateInputType | true
    }

  export interface KpiVariableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KpiVariable'], meta: { name: 'KpiVariable' } }
    /**
     * Find zero or one KpiVariable that matches the filter.
     * @param {KpiVariableFindUniqueArgs} args - Arguments to find a KpiVariable
     * @example
     * // Get one KpiVariable
     * const kpiVariable = await prisma.kpiVariable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KpiVariableFindUniqueArgs>(args: SelectSubset<T, KpiVariableFindUniqueArgs<ExtArgs>>): Prisma__KpiVariableClient<$Result.GetResult<Prisma.$KpiVariablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KpiVariable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KpiVariableFindUniqueOrThrowArgs} args - Arguments to find a KpiVariable
     * @example
     * // Get one KpiVariable
     * const kpiVariable = await prisma.kpiVariable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KpiVariableFindUniqueOrThrowArgs>(args: SelectSubset<T, KpiVariableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KpiVariableClient<$Result.GetResult<Prisma.$KpiVariablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KpiVariable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiVariableFindFirstArgs} args - Arguments to find a KpiVariable
     * @example
     * // Get one KpiVariable
     * const kpiVariable = await prisma.kpiVariable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KpiVariableFindFirstArgs>(args?: SelectSubset<T, KpiVariableFindFirstArgs<ExtArgs>>): Prisma__KpiVariableClient<$Result.GetResult<Prisma.$KpiVariablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KpiVariable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiVariableFindFirstOrThrowArgs} args - Arguments to find a KpiVariable
     * @example
     * // Get one KpiVariable
     * const kpiVariable = await prisma.kpiVariable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KpiVariableFindFirstOrThrowArgs>(args?: SelectSubset<T, KpiVariableFindFirstOrThrowArgs<ExtArgs>>): Prisma__KpiVariableClient<$Result.GetResult<Prisma.$KpiVariablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KpiVariables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiVariableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KpiVariables
     * const kpiVariables = await prisma.kpiVariable.findMany()
     * 
     * // Get first 10 KpiVariables
     * const kpiVariables = await prisma.kpiVariable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kpiVariableWithIdOnly = await prisma.kpiVariable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KpiVariableFindManyArgs>(args?: SelectSubset<T, KpiVariableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiVariablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KpiVariable.
     * @param {KpiVariableCreateArgs} args - Arguments to create a KpiVariable.
     * @example
     * // Create one KpiVariable
     * const KpiVariable = await prisma.kpiVariable.create({
     *   data: {
     *     // ... data to create a KpiVariable
     *   }
     * })
     * 
     */
    create<T extends KpiVariableCreateArgs>(args: SelectSubset<T, KpiVariableCreateArgs<ExtArgs>>): Prisma__KpiVariableClient<$Result.GetResult<Prisma.$KpiVariablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KpiVariables.
     * @param {KpiVariableCreateManyArgs} args - Arguments to create many KpiVariables.
     * @example
     * // Create many KpiVariables
     * const kpiVariable = await prisma.kpiVariable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KpiVariableCreateManyArgs>(args?: SelectSubset<T, KpiVariableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KpiVariables and returns the data saved in the database.
     * @param {KpiVariableCreateManyAndReturnArgs} args - Arguments to create many KpiVariables.
     * @example
     * // Create many KpiVariables
     * const kpiVariable = await prisma.kpiVariable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KpiVariables and only return the `id`
     * const kpiVariableWithIdOnly = await prisma.kpiVariable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KpiVariableCreateManyAndReturnArgs>(args?: SelectSubset<T, KpiVariableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiVariablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KpiVariable.
     * @param {KpiVariableDeleteArgs} args - Arguments to delete one KpiVariable.
     * @example
     * // Delete one KpiVariable
     * const KpiVariable = await prisma.kpiVariable.delete({
     *   where: {
     *     // ... filter to delete one KpiVariable
     *   }
     * })
     * 
     */
    delete<T extends KpiVariableDeleteArgs>(args: SelectSubset<T, KpiVariableDeleteArgs<ExtArgs>>): Prisma__KpiVariableClient<$Result.GetResult<Prisma.$KpiVariablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KpiVariable.
     * @param {KpiVariableUpdateArgs} args - Arguments to update one KpiVariable.
     * @example
     * // Update one KpiVariable
     * const kpiVariable = await prisma.kpiVariable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KpiVariableUpdateArgs>(args: SelectSubset<T, KpiVariableUpdateArgs<ExtArgs>>): Prisma__KpiVariableClient<$Result.GetResult<Prisma.$KpiVariablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KpiVariables.
     * @param {KpiVariableDeleteManyArgs} args - Arguments to filter KpiVariables to delete.
     * @example
     * // Delete a few KpiVariables
     * const { count } = await prisma.kpiVariable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KpiVariableDeleteManyArgs>(args?: SelectSubset<T, KpiVariableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KpiVariables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiVariableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KpiVariables
     * const kpiVariable = await prisma.kpiVariable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KpiVariableUpdateManyArgs>(args: SelectSubset<T, KpiVariableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KpiVariables and returns the data updated in the database.
     * @param {KpiVariableUpdateManyAndReturnArgs} args - Arguments to update many KpiVariables.
     * @example
     * // Update many KpiVariables
     * const kpiVariable = await prisma.kpiVariable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KpiVariables and only return the `id`
     * const kpiVariableWithIdOnly = await prisma.kpiVariable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KpiVariableUpdateManyAndReturnArgs>(args: SelectSubset<T, KpiVariableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiVariablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KpiVariable.
     * @param {KpiVariableUpsertArgs} args - Arguments to update or create a KpiVariable.
     * @example
     * // Update or create a KpiVariable
     * const kpiVariable = await prisma.kpiVariable.upsert({
     *   create: {
     *     // ... data to create a KpiVariable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KpiVariable we want to update
     *   }
     * })
     */
    upsert<T extends KpiVariableUpsertArgs>(args: SelectSubset<T, KpiVariableUpsertArgs<ExtArgs>>): Prisma__KpiVariableClient<$Result.GetResult<Prisma.$KpiVariablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KpiVariables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiVariableCountArgs} args - Arguments to filter KpiVariables to count.
     * @example
     * // Count the number of KpiVariables
     * const count = await prisma.kpiVariable.count({
     *   where: {
     *     // ... the filter for the KpiVariables we want to count
     *   }
     * })
    **/
    count<T extends KpiVariableCountArgs>(
      args?: Subset<T, KpiVariableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KpiVariableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KpiVariable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiVariableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KpiVariableAggregateArgs>(args: Subset<T, KpiVariableAggregateArgs>): Prisma.PrismaPromise<GetKpiVariableAggregateType<T>>

    /**
     * Group by KpiVariable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiVariableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KpiVariableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KpiVariableGroupByArgs['orderBy'] }
        : { orderBy?: KpiVariableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KpiVariableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKpiVariableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KpiVariable model
   */
  readonly fields: KpiVariableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KpiVariable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KpiVariableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kpi<T extends KpiDefinitionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KpiDefinitionDefaultArgs<ExtArgs>>): Prisma__KpiDefinitionClient<$Result.GetResult<Prisma.$KpiDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    values<T extends KpiVariable$valuesArgs<ExtArgs> = {}>(args?: Subset<T, KpiVariable$valuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiVariableValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KpiVariable model
   */
  interface KpiVariableFieldRefs {
    readonly id: FieldRef<"KpiVariable", 'String'>
    readonly kpiId: FieldRef<"KpiVariable", 'String'>
    readonly code: FieldRef<"KpiVariable", 'String'>
    readonly displayName: FieldRef<"KpiVariable", 'String'>
    readonly dataType: FieldRef<"KpiVariable", 'KpiVariableDataType'>
    readonly isRequired: FieldRef<"KpiVariable", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * KpiVariable findUnique
   */
  export type KpiVariableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariable
     */
    select?: KpiVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariable
     */
    omit?: KpiVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableInclude<ExtArgs> | null
    /**
     * Filter, which KpiVariable to fetch.
     */
    where: KpiVariableWhereUniqueInput
  }

  /**
   * KpiVariable findUniqueOrThrow
   */
  export type KpiVariableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariable
     */
    select?: KpiVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariable
     */
    omit?: KpiVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableInclude<ExtArgs> | null
    /**
     * Filter, which KpiVariable to fetch.
     */
    where: KpiVariableWhereUniqueInput
  }

  /**
   * KpiVariable findFirst
   */
  export type KpiVariableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariable
     */
    select?: KpiVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariable
     */
    omit?: KpiVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableInclude<ExtArgs> | null
    /**
     * Filter, which KpiVariable to fetch.
     */
    where?: KpiVariableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiVariables to fetch.
     */
    orderBy?: KpiVariableOrderByWithRelationInput | KpiVariableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KpiVariables.
     */
    cursor?: KpiVariableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiVariables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiVariables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KpiVariables.
     */
    distinct?: KpiVariableScalarFieldEnum | KpiVariableScalarFieldEnum[]
  }

  /**
   * KpiVariable findFirstOrThrow
   */
  export type KpiVariableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariable
     */
    select?: KpiVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariable
     */
    omit?: KpiVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableInclude<ExtArgs> | null
    /**
     * Filter, which KpiVariable to fetch.
     */
    where?: KpiVariableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiVariables to fetch.
     */
    orderBy?: KpiVariableOrderByWithRelationInput | KpiVariableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KpiVariables.
     */
    cursor?: KpiVariableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiVariables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiVariables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KpiVariables.
     */
    distinct?: KpiVariableScalarFieldEnum | KpiVariableScalarFieldEnum[]
  }

  /**
   * KpiVariable findMany
   */
  export type KpiVariableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariable
     */
    select?: KpiVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariable
     */
    omit?: KpiVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableInclude<ExtArgs> | null
    /**
     * Filter, which KpiVariables to fetch.
     */
    where?: KpiVariableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiVariables to fetch.
     */
    orderBy?: KpiVariableOrderByWithRelationInput | KpiVariableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KpiVariables.
     */
    cursor?: KpiVariableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiVariables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiVariables.
     */
    skip?: number
    distinct?: KpiVariableScalarFieldEnum | KpiVariableScalarFieldEnum[]
  }

  /**
   * KpiVariable create
   */
  export type KpiVariableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariable
     */
    select?: KpiVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariable
     */
    omit?: KpiVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableInclude<ExtArgs> | null
    /**
     * The data needed to create a KpiVariable.
     */
    data: XOR<KpiVariableCreateInput, KpiVariableUncheckedCreateInput>
  }

  /**
   * KpiVariable createMany
   */
  export type KpiVariableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KpiVariables.
     */
    data: KpiVariableCreateManyInput | KpiVariableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KpiVariable createManyAndReturn
   */
  export type KpiVariableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariable
     */
    select?: KpiVariableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariable
     */
    omit?: KpiVariableOmit<ExtArgs> | null
    /**
     * The data used to create many KpiVariables.
     */
    data: KpiVariableCreateManyInput | KpiVariableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KpiVariable update
   */
  export type KpiVariableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariable
     */
    select?: KpiVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariable
     */
    omit?: KpiVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableInclude<ExtArgs> | null
    /**
     * The data needed to update a KpiVariable.
     */
    data: XOR<KpiVariableUpdateInput, KpiVariableUncheckedUpdateInput>
    /**
     * Choose, which KpiVariable to update.
     */
    where: KpiVariableWhereUniqueInput
  }

  /**
   * KpiVariable updateMany
   */
  export type KpiVariableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KpiVariables.
     */
    data: XOR<KpiVariableUpdateManyMutationInput, KpiVariableUncheckedUpdateManyInput>
    /**
     * Filter which KpiVariables to update
     */
    where?: KpiVariableWhereInput
    /**
     * Limit how many KpiVariables to update.
     */
    limit?: number
  }

  /**
   * KpiVariable updateManyAndReturn
   */
  export type KpiVariableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariable
     */
    select?: KpiVariableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariable
     */
    omit?: KpiVariableOmit<ExtArgs> | null
    /**
     * The data used to update KpiVariables.
     */
    data: XOR<KpiVariableUpdateManyMutationInput, KpiVariableUncheckedUpdateManyInput>
    /**
     * Filter which KpiVariables to update
     */
    where?: KpiVariableWhereInput
    /**
     * Limit how many KpiVariables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KpiVariable upsert
   */
  export type KpiVariableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariable
     */
    select?: KpiVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariable
     */
    omit?: KpiVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableInclude<ExtArgs> | null
    /**
     * The filter to search for the KpiVariable to update in case it exists.
     */
    where: KpiVariableWhereUniqueInput
    /**
     * In case the KpiVariable found by the `where` argument doesn't exist, create a new KpiVariable with this data.
     */
    create: XOR<KpiVariableCreateInput, KpiVariableUncheckedCreateInput>
    /**
     * In case the KpiVariable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KpiVariableUpdateInput, KpiVariableUncheckedUpdateInput>
  }

  /**
   * KpiVariable delete
   */
  export type KpiVariableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariable
     */
    select?: KpiVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariable
     */
    omit?: KpiVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableInclude<ExtArgs> | null
    /**
     * Filter which KpiVariable to delete.
     */
    where: KpiVariableWhereUniqueInput
  }

  /**
   * KpiVariable deleteMany
   */
  export type KpiVariableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KpiVariables to delete
     */
    where?: KpiVariableWhereInput
    /**
     * Limit how many KpiVariables to delete.
     */
    limit?: number
  }

  /**
   * KpiVariable.values
   */
  export type KpiVariable$valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariableValue
     */
    select?: KpiVariableValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariableValue
     */
    omit?: KpiVariableValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableValueInclude<ExtArgs> | null
    where?: KpiVariableValueWhereInput
    orderBy?: KpiVariableValueOrderByWithRelationInput | KpiVariableValueOrderByWithRelationInput[]
    cursor?: KpiVariableValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KpiVariableValueScalarFieldEnum | KpiVariableValueScalarFieldEnum[]
  }

  /**
   * KpiVariable without action
   */
  export type KpiVariableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariable
     */
    select?: KpiVariableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariable
     */
    omit?: KpiVariableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableInclude<ExtArgs> | null
  }


  /**
   * Model KpiValuePeriod
   */

  export type AggregateKpiValuePeriod = {
    _count: KpiValuePeriodCountAggregateOutputType | null
    _avg: KpiValuePeriodAvgAggregateOutputType | null
    _sum: KpiValuePeriodSumAggregateOutputType | null
    _min: KpiValuePeriodMinAggregateOutputType | null
    _max: KpiValuePeriodMaxAggregateOutputType | null
  }

  export type KpiValuePeriodAvgAggregateOutputType = {
    calculatedValue: number | null
  }

  export type KpiValuePeriodSumAggregateOutputType = {
    calculatedValue: number | null
  }

  export type KpiValuePeriodMinAggregateOutputType = {
    id: string | null
    kpiId: string | null
    periodStart: Date | null
    periodEnd: Date | null
    calculatedValue: number | null
    status: $Enums.KpiValueStatus | null
    note: string | null
    enteredBy: string | null
    approvedBy: string | null
    submittedAt: Date | null
    approvedAt: Date | null
    lockedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KpiValuePeriodMaxAggregateOutputType = {
    id: string | null
    kpiId: string | null
    periodStart: Date | null
    periodEnd: Date | null
    calculatedValue: number | null
    status: $Enums.KpiValueStatus | null
    note: string | null
    enteredBy: string | null
    approvedBy: string | null
    submittedAt: Date | null
    approvedAt: Date | null
    lockedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KpiValuePeriodCountAggregateOutputType = {
    id: number
    kpiId: number
    periodStart: number
    periodEnd: number
    calculatedValue: number
    status: number
    note: number
    enteredBy: number
    approvedBy: number
    submittedAt: number
    approvedAt: number
    lockedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KpiValuePeriodAvgAggregateInputType = {
    calculatedValue?: true
  }

  export type KpiValuePeriodSumAggregateInputType = {
    calculatedValue?: true
  }

  export type KpiValuePeriodMinAggregateInputType = {
    id?: true
    kpiId?: true
    periodStart?: true
    periodEnd?: true
    calculatedValue?: true
    status?: true
    note?: true
    enteredBy?: true
    approvedBy?: true
    submittedAt?: true
    approvedAt?: true
    lockedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KpiValuePeriodMaxAggregateInputType = {
    id?: true
    kpiId?: true
    periodStart?: true
    periodEnd?: true
    calculatedValue?: true
    status?: true
    note?: true
    enteredBy?: true
    approvedBy?: true
    submittedAt?: true
    approvedAt?: true
    lockedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KpiValuePeriodCountAggregateInputType = {
    id?: true
    kpiId?: true
    periodStart?: true
    periodEnd?: true
    calculatedValue?: true
    status?: true
    note?: true
    enteredBy?: true
    approvedBy?: true
    submittedAt?: true
    approvedAt?: true
    lockedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KpiValuePeriodAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KpiValuePeriod to aggregate.
     */
    where?: KpiValuePeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiValuePeriods to fetch.
     */
    orderBy?: KpiValuePeriodOrderByWithRelationInput | KpiValuePeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KpiValuePeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiValuePeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiValuePeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KpiValuePeriods
    **/
    _count?: true | KpiValuePeriodCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KpiValuePeriodAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KpiValuePeriodSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KpiValuePeriodMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KpiValuePeriodMaxAggregateInputType
  }

  export type GetKpiValuePeriodAggregateType<T extends KpiValuePeriodAggregateArgs> = {
        [P in keyof T & keyof AggregateKpiValuePeriod]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKpiValuePeriod[P]>
      : GetScalarType<T[P], AggregateKpiValuePeriod[P]>
  }




  export type KpiValuePeriodGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KpiValuePeriodWhereInput
    orderBy?: KpiValuePeriodOrderByWithAggregationInput | KpiValuePeriodOrderByWithAggregationInput[]
    by: KpiValuePeriodScalarFieldEnum[] | KpiValuePeriodScalarFieldEnum
    having?: KpiValuePeriodScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KpiValuePeriodCountAggregateInputType | true
    _avg?: KpiValuePeriodAvgAggregateInputType
    _sum?: KpiValuePeriodSumAggregateInputType
    _min?: KpiValuePeriodMinAggregateInputType
    _max?: KpiValuePeriodMaxAggregateInputType
  }

  export type KpiValuePeriodGroupByOutputType = {
    id: string
    kpiId: string
    periodStart: Date
    periodEnd: Date
    calculatedValue: number | null
    status: $Enums.KpiValueStatus
    note: string | null
    enteredBy: string | null
    approvedBy: string | null
    submittedAt: Date | null
    approvedAt: Date | null
    lockedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: KpiValuePeriodCountAggregateOutputType | null
    _avg: KpiValuePeriodAvgAggregateOutputType | null
    _sum: KpiValuePeriodSumAggregateOutputType | null
    _min: KpiValuePeriodMinAggregateOutputType | null
    _max: KpiValuePeriodMaxAggregateOutputType | null
  }

  type GetKpiValuePeriodGroupByPayload<T extends KpiValuePeriodGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KpiValuePeriodGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KpiValuePeriodGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KpiValuePeriodGroupByOutputType[P]>
            : GetScalarType<T[P], KpiValuePeriodGroupByOutputType[P]>
        }
      >
    >


  export type KpiValuePeriodSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kpiId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    calculatedValue?: boolean
    status?: boolean
    note?: boolean
    enteredBy?: boolean
    approvedBy?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    lockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kpi?: boolean | KpiDefinitionDefaultArgs<ExtArgs>
    enteredByUser?: boolean | KpiValuePeriod$enteredByUserArgs<ExtArgs>
    approvedByUser?: boolean | KpiValuePeriod$approvedByUserArgs<ExtArgs>
    variableValues?: boolean | KpiValuePeriod$variableValuesArgs<ExtArgs>
    _count?: boolean | KpiValuePeriodCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kpiValuePeriod"]>

  export type KpiValuePeriodSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kpiId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    calculatedValue?: boolean
    status?: boolean
    note?: boolean
    enteredBy?: boolean
    approvedBy?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    lockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kpi?: boolean | KpiDefinitionDefaultArgs<ExtArgs>
    enteredByUser?: boolean | KpiValuePeriod$enteredByUserArgs<ExtArgs>
    approvedByUser?: boolean | KpiValuePeriod$approvedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["kpiValuePeriod"]>

  export type KpiValuePeriodSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kpiId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    calculatedValue?: boolean
    status?: boolean
    note?: boolean
    enteredBy?: boolean
    approvedBy?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    lockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kpi?: boolean | KpiDefinitionDefaultArgs<ExtArgs>
    enteredByUser?: boolean | KpiValuePeriod$enteredByUserArgs<ExtArgs>
    approvedByUser?: boolean | KpiValuePeriod$approvedByUserArgs<ExtArgs>
  }, ExtArgs["result"]["kpiValuePeriod"]>

  export type KpiValuePeriodSelectScalar = {
    id?: boolean
    kpiId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    calculatedValue?: boolean
    status?: boolean
    note?: boolean
    enteredBy?: boolean
    approvedBy?: boolean
    submittedAt?: boolean
    approvedAt?: boolean
    lockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KpiValuePeriodOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "kpiId" | "periodStart" | "periodEnd" | "calculatedValue" | "status" | "note" | "enteredBy" | "approvedBy" | "submittedAt" | "approvedAt" | "lockedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["kpiValuePeriod"]>
  export type KpiValuePeriodInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kpi?: boolean | KpiDefinitionDefaultArgs<ExtArgs>
    enteredByUser?: boolean | KpiValuePeriod$enteredByUserArgs<ExtArgs>
    approvedByUser?: boolean | KpiValuePeriod$approvedByUserArgs<ExtArgs>
    variableValues?: boolean | KpiValuePeriod$variableValuesArgs<ExtArgs>
    _count?: boolean | KpiValuePeriodCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KpiValuePeriodIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kpi?: boolean | KpiDefinitionDefaultArgs<ExtArgs>
    enteredByUser?: boolean | KpiValuePeriod$enteredByUserArgs<ExtArgs>
    approvedByUser?: boolean | KpiValuePeriod$approvedByUserArgs<ExtArgs>
  }
  export type KpiValuePeriodIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kpi?: boolean | KpiDefinitionDefaultArgs<ExtArgs>
    enteredByUser?: boolean | KpiValuePeriod$enteredByUserArgs<ExtArgs>
    approvedByUser?: boolean | KpiValuePeriod$approvedByUserArgs<ExtArgs>
  }

  export type $KpiValuePeriodPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KpiValuePeriod"
    objects: {
      kpi: Prisma.$KpiDefinitionPayload<ExtArgs>
      enteredByUser: Prisma.$UserPayload<ExtArgs> | null
      approvedByUser: Prisma.$UserPayload<ExtArgs> | null
      variableValues: Prisma.$KpiVariableValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      kpiId: string
      periodStart: Date
      periodEnd: Date
      calculatedValue: number | null
      status: $Enums.KpiValueStatus
      note: string | null
      enteredBy: string | null
      approvedBy: string | null
      submittedAt: Date | null
      approvedAt: Date | null
      lockedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["kpiValuePeriod"]>
    composites: {}
  }

  type KpiValuePeriodGetPayload<S extends boolean | null | undefined | KpiValuePeriodDefaultArgs> = $Result.GetResult<Prisma.$KpiValuePeriodPayload, S>

  type KpiValuePeriodCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KpiValuePeriodFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KpiValuePeriodCountAggregateInputType | true
    }

  export interface KpiValuePeriodDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KpiValuePeriod'], meta: { name: 'KpiValuePeriod' } }
    /**
     * Find zero or one KpiValuePeriod that matches the filter.
     * @param {KpiValuePeriodFindUniqueArgs} args - Arguments to find a KpiValuePeriod
     * @example
     * // Get one KpiValuePeriod
     * const kpiValuePeriod = await prisma.kpiValuePeriod.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KpiValuePeriodFindUniqueArgs>(args: SelectSubset<T, KpiValuePeriodFindUniqueArgs<ExtArgs>>): Prisma__KpiValuePeriodClient<$Result.GetResult<Prisma.$KpiValuePeriodPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KpiValuePeriod that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KpiValuePeriodFindUniqueOrThrowArgs} args - Arguments to find a KpiValuePeriod
     * @example
     * // Get one KpiValuePeriod
     * const kpiValuePeriod = await prisma.kpiValuePeriod.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KpiValuePeriodFindUniqueOrThrowArgs>(args: SelectSubset<T, KpiValuePeriodFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KpiValuePeriodClient<$Result.GetResult<Prisma.$KpiValuePeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KpiValuePeriod that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiValuePeriodFindFirstArgs} args - Arguments to find a KpiValuePeriod
     * @example
     * // Get one KpiValuePeriod
     * const kpiValuePeriod = await prisma.kpiValuePeriod.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KpiValuePeriodFindFirstArgs>(args?: SelectSubset<T, KpiValuePeriodFindFirstArgs<ExtArgs>>): Prisma__KpiValuePeriodClient<$Result.GetResult<Prisma.$KpiValuePeriodPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KpiValuePeriod that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiValuePeriodFindFirstOrThrowArgs} args - Arguments to find a KpiValuePeriod
     * @example
     * // Get one KpiValuePeriod
     * const kpiValuePeriod = await prisma.kpiValuePeriod.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KpiValuePeriodFindFirstOrThrowArgs>(args?: SelectSubset<T, KpiValuePeriodFindFirstOrThrowArgs<ExtArgs>>): Prisma__KpiValuePeriodClient<$Result.GetResult<Prisma.$KpiValuePeriodPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KpiValuePeriods that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiValuePeriodFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KpiValuePeriods
     * const kpiValuePeriods = await prisma.kpiValuePeriod.findMany()
     * 
     * // Get first 10 KpiValuePeriods
     * const kpiValuePeriods = await prisma.kpiValuePeriod.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kpiValuePeriodWithIdOnly = await prisma.kpiValuePeriod.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KpiValuePeriodFindManyArgs>(args?: SelectSubset<T, KpiValuePeriodFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiValuePeriodPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KpiValuePeriod.
     * @param {KpiValuePeriodCreateArgs} args - Arguments to create a KpiValuePeriod.
     * @example
     * // Create one KpiValuePeriod
     * const KpiValuePeriod = await prisma.kpiValuePeriod.create({
     *   data: {
     *     // ... data to create a KpiValuePeriod
     *   }
     * })
     * 
     */
    create<T extends KpiValuePeriodCreateArgs>(args: SelectSubset<T, KpiValuePeriodCreateArgs<ExtArgs>>): Prisma__KpiValuePeriodClient<$Result.GetResult<Prisma.$KpiValuePeriodPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KpiValuePeriods.
     * @param {KpiValuePeriodCreateManyArgs} args - Arguments to create many KpiValuePeriods.
     * @example
     * // Create many KpiValuePeriods
     * const kpiValuePeriod = await prisma.kpiValuePeriod.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KpiValuePeriodCreateManyArgs>(args?: SelectSubset<T, KpiValuePeriodCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KpiValuePeriods and returns the data saved in the database.
     * @param {KpiValuePeriodCreateManyAndReturnArgs} args - Arguments to create many KpiValuePeriods.
     * @example
     * // Create many KpiValuePeriods
     * const kpiValuePeriod = await prisma.kpiValuePeriod.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KpiValuePeriods and only return the `id`
     * const kpiValuePeriodWithIdOnly = await prisma.kpiValuePeriod.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KpiValuePeriodCreateManyAndReturnArgs>(args?: SelectSubset<T, KpiValuePeriodCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiValuePeriodPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KpiValuePeriod.
     * @param {KpiValuePeriodDeleteArgs} args - Arguments to delete one KpiValuePeriod.
     * @example
     * // Delete one KpiValuePeriod
     * const KpiValuePeriod = await prisma.kpiValuePeriod.delete({
     *   where: {
     *     // ... filter to delete one KpiValuePeriod
     *   }
     * })
     * 
     */
    delete<T extends KpiValuePeriodDeleteArgs>(args: SelectSubset<T, KpiValuePeriodDeleteArgs<ExtArgs>>): Prisma__KpiValuePeriodClient<$Result.GetResult<Prisma.$KpiValuePeriodPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KpiValuePeriod.
     * @param {KpiValuePeriodUpdateArgs} args - Arguments to update one KpiValuePeriod.
     * @example
     * // Update one KpiValuePeriod
     * const kpiValuePeriod = await prisma.kpiValuePeriod.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KpiValuePeriodUpdateArgs>(args: SelectSubset<T, KpiValuePeriodUpdateArgs<ExtArgs>>): Prisma__KpiValuePeriodClient<$Result.GetResult<Prisma.$KpiValuePeriodPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KpiValuePeriods.
     * @param {KpiValuePeriodDeleteManyArgs} args - Arguments to filter KpiValuePeriods to delete.
     * @example
     * // Delete a few KpiValuePeriods
     * const { count } = await prisma.kpiValuePeriod.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KpiValuePeriodDeleteManyArgs>(args?: SelectSubset<T, KpiValuePeriodDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KpiValuePeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiValuePeriodUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KpiValuePeriods
     * const kpiValuePeriod = await prisma.kpiValuePeriod.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KpiValuePeriodUpdateManyArgs>(args: SelectSubset<T, KpiValuePeriodUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KpiValuePeriods and returns the data updated in the database.
     * @param {KpiValuePeriodUpdateManyAndReturnArgs} args - Arguments to update many KpiValuePeriods.
     * @example
     * // Update many KpiValuePeriods
     * const kpiValuePeriod = await prisma.kpiValuePeriod.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KpiValuePeriods and only return the `id`
     * const kpiValuePeriodWithIdOnly = await prisma.kpiValuePeriod.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KpiValuePeriodUpdateManyAndReturnArgs>(args: SelectSubset<T, KpiValuePeriodUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiValuePeriodPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KpiValuePeriod.
     * @param {KpiValuePeriodUpsertArgs} args - Arguments to update or create a KpiValuePeriod.
     * @example
     * // Update or create a KpiValuePeriod
     * const kpiValuePeriod = await prisma.kpiValuePeriod.upsert({
     *   create: {
     *     // ... data to create a KpiValuePeriod
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KpiValuePeriod we want to update
     *   }
     * })
     */
    upsert<T extends KpiValuePeriodUpsertArgs>(args: SelectSubset<T, KpiValuePeriodUpsertArgs<ExtArgs>>): Prisma__KpiValuePeriodClient<$Result.GetResult<Prisma.$KpiValuePeriodPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KpiValuePeriods.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiValuePeriodCountArgs} args - Arguments to filter KpiValuePeriods to count.
     * @example
     * // Count the number of KpiValuePeriods
     * const count = await prisma.kpiValuePeriod.count({
     *   where: {
     *     // ... the filter for the KpiValuePeriods we want to count
     *   }
     * })
    **/
    count<T extends KpiValuePeriodCountArgs>(
      args?: Subset<T, KpiValuePeriodCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KpiValuePeriodCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KpiValuePeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiValuePeriodAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KpiValuePeriodAggregateArgs>(args: Subset<T, KpiValuePeriodAggregateArgs>): Prisma.PrismaPromise<GetKpiValuePeriodAggregateType<T>>

    /**
     * Group by KpiValuePeriod.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiValuePeriodGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KpiValuePeriodGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KpiValuePeriodGroupByArgs['orderBy'] }
        : { orderBy?: KpiValuePeriodGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KpiValuePeriodGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKpiValuePeriodGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KpiValuePeriod model
   */
  readonly fields: KpiValuePeriodFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KpiValuePeriod.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KpiValuePeriodClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kpi<T extends KpiDefinitionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KpiDefinitionDefaultArgs<ExtArgs>>): Prisma__KpiDefinitionClient<$Result.GetResult<Prisma.$KpiDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    enteredByUser<T extends KpiValuePeriod$enteredByUserArgs<ExtArgs> = {}>(args?: Subset<T, KpiValuePeriod$enteredByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    approvedByUser<T extends KpiValuePeriod$approvedByUserArgs<ExtArgs> = {}>(args?: Subset<T, KpiValuePeriod$approvedByUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    variableValues<T extends KpiValuePeriod$variableValuesArgs<ExtArgs> = {}>(args?: Subset<T, KpiValuePeriod$variableValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiVariableValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KpiValuePeriod model
   */
  interface KpiValuePeriodFieldRefs {
    readonly id: FieldRef<"KpiValuePeriod", 'String'>
    readonly kpiId: FieldRef<"KpiValuePeriod", 'String'>
    readonly periodStart: FieldRef<"KpiValuePeriod", 'DateTime'>
    readonly periodEnd: FieldRef<"KpiValuePeriod", 'DateTime'>
    readonly calculatedValue: FieldRef<"KpiValuePeriod", 'Float'>
    readonly status: FieldRef<"KpiValuePeriod", 'KpiValueStatus'>
    readonly note: FieldRef<"KpiValuePeriod", 'String'>
    readonly enteredBy: FieldRef<"KpiValuePeriod", 'String'>
    readonly approvedBy: FieldRef<"KpiValuePeriod", 'String'>
    readonly submittedAt: FieldRef<"KpiValuePeriod", 'DateTime'>
    readonly approvedAt: FieldRef<"KpiValuePeriod", 'DateTime'>
    readonly lockedAt: FieldRef<"KpiValuePeriod", 'DateTime'>
    readonly createdAt: FieldRef<"KpiValuePeriod", 'DateTime'>
    readonly updatedAt: FieldRef<"KpiValuePeriod", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KpiValuePeriod findUnique
   */
  export type KpiValuePeriodFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiValuePeriod
     */
    select?: KpiValuePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiValuePeriod
     */
    omit?: KpiValuePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiValuePeriodInclude<ExtArgs> | null
    /**
     * Filter, which KpiValuePeriod to fetch.
     */
    where: KpiValuePeriodWhereUniqueInput
  }

  /**
   * KpiValuePeriod findUniqueOrThrow
   */
  export type KpiValuePeriodFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiValuePeriod
     */
    select?: KpiValuePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiValuePeriod
     */
    omit?: KpiValuePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiValuePeriodInclude<ExtArgs> | null
    /**
     * Filter, which KpiValuePeriod to fetch.
     */
    where: KpiValuePeriodWhereUniqueInput
  }

  /**
   * KpiValuePeriod findFirst
   */
  export type KpiValuePeriodFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiValuePeriod
     */
    select?: KpiValuePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiValuePeriod
     */
    omit?: KpiValuePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiValuePeriodInclude<ExtArgs> | null
    /**
     * Filter, which KpiValuePeriod to fetch.
     */
    where?: KpiValuePeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiValuePeriods to fetch.
     */
    orderBy?: KpiValuePeriodOrderByWithRelationInput | KpiValuePeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KpiValuePeriods.
     */
    cursor?: KpiValuePeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiValuePeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiValuePeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KpiValuePeriods.
     */
    distinct?: KpiValuePeriodScalarFieldEnum | KpiValuePeriodScalarFieldEnum[]
  }

  /**
   * KpiValuePeriod findFirstOrThrow
   */
  export type KpiValuePeriodFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiValuePeriod
     */
    select?: KpiValuePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiValuePeriod
     */
    omit?: KpiValuePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiValuePeriodInclude<ExtArgs> | null
    /**
     * Filter, which KpiValuePeriod to fetch.
     */
    where?: KpiValuePeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiValuePeriods to fetch.
     */
    orderBy?: KpiValuePeriodOrderByWithRelationInput | KpiValuePeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KpiValuePeriods.
     */
    cursor?: KpiValuePeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiValuePeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiValuePeriods.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KpiValuePeriods.
     */
    distinct?: KpiValuePeriodScalarFieldEnum | KpiValuePeriodScalarFieldEnum[]
  }

  /**
   * KpiValuePeriod findMany
   */
  export type KpiValuePeriodFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiValuePeriod
     */
    select?: KpiValuePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiValuePeriod
     */
    omit?: KpiValuePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiValuePeriodInclude<ExtArgs> | null
    /**
     * Filter, which KpiValuePeriods to fetch.
     */
    where?: KpiValuePeriodWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiValuePeriods to fetch.
     */
    orderBy?: KpiValuePeriodOrderByWithRelationInput | KpiValuePeriodOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KpiValuePeriods.
     */
    cursor?: KpiValuePeriodWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiValuePeriods from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiValuePeriods.
     */
    skip?: number
    distinct?: KpiValuePeriodScalarFieldEnum | KpiValuePeriodScalarFieldEnum[]
  }

  /**
   * KpiValuePeriod create
   */
  export type KpiValuePeriodCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiValuePeriod
     */
    select?: KpiValuePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiValuePeriod
     */
    omit?: KpiValuePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiValuePeriodInclude<ExtArgs> | null
    /**
     * The data needed to create a KpiValuePeriod.
     */
    data: XOR<KpiValuePeriodCreateInput, KpiValuePeriodUncheckedCreateInput>
  }

  /**
   * KpiValuePeriod createMany
   */
  export type KpiValuePeriodCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KpiValuePeriods.
     */
    data: KpiValuePeriodCreateManyInput | KpiValuePeriodCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KpiValuePeriod createManyAndReturn
   */
  export type KpiValuePeriodCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiValuePeriod
     */
    select?: KpiValuePeriodSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KpiValuePeriod
     */
    omit?: KpiValuePeriodOmit<ExtArgs> | null
    /**
     * The data used to create many KpiValuePeriods.
     */
    data: KpiValuePeriodCreateManyInput | KpiValuePeriodCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiValuePeriodIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KpiValuePeriod update
   */
  export type KpiValuePeriodUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiValuePeriod
     */
    select?: KpiValuePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiValuePeriod
     */
    omit?: KpiValuePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiValuePeriodInclude<ExtArgs> | null
    /**
     * The data needed to update a KpiValuePeriod.
     */
    data: XOR<KpiValuePeriodUpdateInput, KpiValuePeriodUncheckedUpdateInput>
    /**
     * Choose, which KpiValuePeriod to update.
     */
    where: KpiValuePeriodWhereUniqueInput
  }

  /**
   * KpiValuePeriod updateMany
   */
  export type KpiValuePeriodUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KpiValuePeriods.
     */
    data: XOR<KpiValuePeriodUpdateManyMutationInput, KpiValuePeriodUncheckedUpdateManyInput>
    /**
     * Filter which KpiValuePeriods to update
     */
    where?: KpiValuePeriodWhereInput
    /**
     * Limit how many KpiValuePeriods to update.
     */
    limit?: number
  }

  /**
   * KpiValuePeriod updateManyAndReturn
   */
  export type KpiValuePeriodUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiValuePeriod
     */
    select?: KpiValuePeriodSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KpiValuePeriod
     */
    omit?: KpiValuePeriodOmit<ExtArgs> | null
    /**
     * The data used to update KpiValuePeriods.
     */
    data: XOR<KpiValuePeriodUpdateManyMutationInput, KpiValuePeriodUncheckedUpdateManyInput>
    /**
     * Filter which KpiValuePeriods to update
     */
    where?: KpiValuePeriodWhereInput
    /**
     * Limit how many KpiValuePeriods to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiValuePeriodIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KpiValuePeriod upsert
   */
  export type KpiValuePeriodUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiValuePeriod
     */
    select?: KpiValuePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiValuePeriod
     */
    omit?: KpiValuePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiValuePeriodInclude<ExtArgs> | null
    /**
     * The filter to search for the KpiValuePeriod to update in case it exists.
     */
    where: KpiValuePeriodWhereUniqueInput
    /**
     * In case the KpiValuePeriod found by the `where` argument doesn't exist, create a new KpiValuePeriod with this data.
     */
    create: XOR<KpiValuePeriodCreateInput, KpiValuePeriodUncheckedCreateInput>
    /**
     * In case the KpiValuePeriod was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KpiValuePeriodUpdateInput, KpiValuePeriodUncheckedUpdateInput>
  }

  /**
   * KpiValuePeriod delete
   */
  export type KpiValuePeriodDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiValuePeriod
     */
    select?: KpiValuePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiValuePeriod
     */
    omit?: KpiValuePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiValuePeriodInclude<ExtArgs> | null
    /**
     * Filter which KpiValuePeriod to delete.
     */
    where: KpiValuePeriodWhereUniqueInput
  }

  /**
   * KpiValuePeriod deleteMany
   */
  export type KpiValuePeriodDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KpiValuePeriods to delete
     */
    where?: KpiValuePeriodWhereInput
    /**
     * Limit how many KpiValuePeriods to delete.
     */
    limit?: number
  }

  /**
   * KpiValuePeriod.enteredByUser
   */
  export type KpiValuePeriod$enteredByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * KpiValuePeriod.approvedByUser
   */
  export type KpiValuePeriod$approvedByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * KpiValuePeriod.variableValues
   */
  export type KpiValuePeriod$variableValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariableValue
     */
    select?: KpiVariableValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariableValue
     */
    omit?: KpiVariableValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableValueInclude<ExtArgs> | null
    where?: KpiVariableValueWhereInput
    orderBy?: KpiVariableValueOrderByWithRelationInput | KpiVariableValueOrderByWithRelationInput[]
    cursor?: KpiVariableValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KpiVariableValueScalarFieldEnum | KpiVariableValueScalarFieldEnum[]
  }

  /**
   * KpiValuePeriod without action
   */
  export type KpiValuePeriodDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiValuePeriod
     */
    select?: KpiValuePeriodSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiValuePeriod
     */
    omit?: KpiValuePeriodOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiValuePeriodInclude<ExtArgs> | null
  }


  /**
   * Model KpiVariableValue
   */

  export type AggregateKpiVariableValue = {
    _count: KpiVariableValueCountAggregateOutputType | null
    _avg: KpiVariableValueAvgAggregateOutputType | null
    _sum: KpiVariableValueSumAggregateOutputType | null
    _min: KpiVariableValueMinAggregateOutputType | null
    _max: KpiVariableValueMaxAggregateOutputType | null
  }

  export type KpiVariableValueAvgAggregateOutputType = {
    value: number | null
  }

  export type KpiVariableValueSumAggregateOutputType = {
    value: number | null
  }

  export type KpiVariableValueMinAggregateOutputType = {
    id: string | null
    kpiValueId: string | null
    kpiVariableId: string | null
    value: number | null
  }

  export type KpiVariableValueMaxAggregateOutputType = {
    id: string | null
    kpiValueId: string | null
    kpiVariableId: string | null
    value: number | null
  }

  export type KpiVariableValueCountAggregateOutputType = {
    id: number
    kpiValueId: number
    kpiVariableId: number
    value: number
    _all: number
  }


  export type KpiVariableValueAvgAggregateInputType = {
    value?: true
  }

  export type KpiVariableValueSumAggregateInputType = {
    value?: true
  }

  export type KpiVariableValueMinAggregateInputType = {
    id?: true
    kpiValueId?: true
    kpiVariableId?: true
    value?: true
  }

  export type KpiVariableValueMaxAggregateInputType = {
    id?: true
    kpiValueId?: true
    kpiVariableId?: true
    value?: true
  }

  export type KpiVariableValueCountAggregateInputType = {
    id?: true
    kpiValueId?: true
    kpiVariableId?: true
    value?: true
    _all?: true
  }

  export type KpiVariableValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KpiVariableValue to aggregate.
     */
    where?: KpiVariableValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiVariableValues to fetch.
     */
    orderBy?: KpiVariableValueOrderByWithRelationInput | KpiVariableValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KpiVariableValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiVariableValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiVariableValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KpiVariableValues
    **/
    _count?: true | KpiVariableValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KpiVariableValueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KpiVariableValueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KpiVariableValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KpiVariableValueMaxAggregateInputType
  }

  export type GetKpiVariableValueAggregateType<T extends KpiVariableValueAggregateArgs> = {
        [P in keyof T & keyof AggregateKpiVariableValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKpiVariableValue[P]>
      : GetScalarType<T[P], AggregateKpiVariableValue[P]>
  }




  export type KpiVariableValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KpiVariableValueWhereInput
    orderBy?: KpiVariableValueOrderByWithAggregationInput | KpiVariableValueOrderByWithAggregationInput[]
    by: KpiVariableValueScalarFieldEnum[] | KpiVariableValueScalarFieldEnum
    having?: KpiVariableValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KpiVariableValueCountAggregateInputType | true
    _avg?: KpiVariableValueAvgAggregateInputType
    _sum?: KpiVariableValueSumAggregateInputType
    _min?: KpiVariableValueMinAggregateInputType
    _max?: KpiVariableValueMaxAggregateInputType
  }

  export type KpiVariableValueGroupByOutputType = {
    id: string
    kpiValueId: string
    kpiVariableId: string
    value: number
    _count: KpiVariableValueCountAggregateOutputType | null
    _avg: KpiVariableValueAvgAggregateOutputType | null
    _sum: KpiVariableValueSumAggregateOutputType | null
    _min: KpiVariableValueMinAggregateOutputType | null
    _max: KpiVariableValueMaxAggregateOutputType | null
  }

  type GetKpiVariableValueGroupByPayload<T extends KpiVariableValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KpiVariableValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KpiVariableValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KpiVariableValueGroupByOutputType[P]>
            : GetScalarType<T[P], KpiVariableValueGroupByOutputType[P]>
        }
      >
    >


  export type KpiVariableValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kpiValueId?: boolean
    kpiVariableId?: boolean
    value?: boolean
    kpiValue?: boolean | KpiValuePeriodDefaultArgs<ExtArgs>
    kpiVariable?: boolean | KpiVariableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kpiVariableValue"]>

  export type KpiVariableValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kpiValueId?: boolean
    kpiVariableId?: boolean
    value?: boolean
    kpiValue?: boolean | KpiValuePeriodDefaultArgs<ExtArgs>
    kpiVariable?: boolean | KpiVariableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kpiVariableValue"]>

  export type KpiVariableValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kpiValueId?: boolean
    kpiVariableId?: boolean
    value?: boolean
    kpiValue?: boolean | KpiValuePeriodDefaultArgs<ExtArgs>
    kpiVariable?: boolean | KpiVariableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kpiVariableValue"]>

  export type KpiVariableValueSelectScalar = {
    id?: boolean
    kpiValueId?: boolean
    kpiVariableId?: boolean
    value?: boolean
  }

  export type KpiVariableValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "kpiValueId" | "kpiVariableId" | "value", ExtArgs["result"]["kpiVariableValue"]>
  export type KpiVariableValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kpiValue?: boolean | KpiValuePeriodDefaultArgs<ExtArgs>
    kpiVariable?: boolean | KpiVariableDefaultArgs<ExtArgs>
  }
  export type KpiVariableValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kpiValue?: boolean | KpiValuePeriodDefaultArgs<ExtArgs>
    kpiVariable?: boolean | KpiVariableDefaultArgs<ExtArgs>
  }
  export type KpiVariableValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kpiValue?: boolean | KpiValuePeriodDefaultArgs<ExtArgs>
    kpiVariable?: boolean | KpiVariableDefaultArgs<ExtArgs>
  }

  export type $KpiVariableValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KpiVariableValue"
    objects: {
      kpiValue: Prisma.$KpiValuePeriodPayload<ExtArgs>
      kpiVariable: Prisma.$KpiVariablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      kpiValueId: string
      kpiVariableId: string
      value: number
    }, ExtArgs["result"]["kpiVariableValue"]>
    composites: {}
  }

  type KpiVariableValueGetPayload<S extends boolean | null | undefined | KpiVariableValueDefaultArgs> = $Result.GetResult<Prisma.$KpiVariableValuePayload, S>

  type KpiVariableValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KpiVariableValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KpiVariableValueCountAggregateInputType | true
    }

  export interface KpiVariableValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KpiVariableValue'], meta: { name: 'KpiVariableValue' } }
    /**
     * Find zero or one KpiVariableValue that matches the filter.
     * @param {KpiVariableValueFindUniqueArgs} args - Arguments to find a KpiVariableValue
     * @example
     * // Get one KpiVariableValue
     * const kpiVariableValue = await prisma.kpiVariableValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KpiVariableValueFindUniqueArgs>(args: SelectSubset<T, KpiVariableValueFindUniqueArgs<ExtArgs>>): Prisma__KpiVariableValueClient<$Result.GetResult<Prisma.$KpiVariableValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KpiVariableValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KpiVariableValueFindUniqueOrThrowArgs} args - Arguments to find a KpiVariableValue
     * @example
     * // Get one KpiVariableValue
     * const kpiVariableValue = await prisma.kpiVariableValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KpiVariableValueFindUniqueOrThrowArgs>(args: SelectSubset<T, KpiVariableValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KpiVariableValueClient<$Result.GetResult<Prisma.$KpiVariableValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KpiVariableValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiVariableValueFindFirstArgs} args - Arguments to find a KpiVariableValue
     * @example
     * // Get one KpiVariableValue
     * const kpiVariableValue = await prisma.kpiVariableValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KpiVariableValueFindFirstArgs>(args?: SelectSubset<T, KpiVariableValueFindFirstArgs<ExtArgs>>): Prisma__KpiVariableValueClient<$Result.GetResult<Prisma.$KpiVariableValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KpiVariableValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiVariableValueFindFirstOrThrowArgs} args - Arguments to find a KpiVariableValue
     * @example
     * // Get one KpiVariableValue
     * const kpiVariableValue = await prisma.kpiVariableValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KpiVariableValueFindFirstOrThrowArgs>(args?: SelectSubset<T, KpiVariableValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__KpiVariableValueClient<$Result.GetResult<Prisma.$KpiVariableValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KpiVariableValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiVariableValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KpiVariableValues
     * const kpiVariableValues = await prisma.kpiVariableValue.findMany()
     * 
     * // Get first 10 KpiVariableValues
     * const kpiVariableValues = await prisma.kpiVariableValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kpiVariableValueWithIdOnly = await prisma.kpiVariableValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KpiVariableValueFindManyArgs>(args?: SelectSubset<T, KpiVariableValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiVariableValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KpiVariableValue.
     * @param {KpiVariableValueCreateArgs} args - Arguments to create a KpiVariableValue.
     * @example
     * // Create one KpiVariableValue
     * const KpiVariableValue = await prisma.kpiVariableValue.create({
     *   data: {
     *     // ... data to create a KpiVariableValue
     *   }
     * })
     * 
     */
    create<T extends KpiVariableValueCreateArgs>(args: SelectSubset<T, KpiVariableValueCreateArgs<ExtArgs>>): Prisma__KpiVariableValueClient<$Result.GetResult<Prisma.$KpiVariableValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KpiVariableValues.
     * @param {KpiVariableValueCreateManyArgs} args - Arguments to create many KpiVariableValues.
     * @example
     * // Create many KpiVariableValues
     * const kpiVariableValue = await prisma.kpiVariableValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KpiVariableValueCreateManyArgs>(args?: SelectSubset<T, KpiVariableValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KpiVariableValues and returns the data saved in the database.
     * @param {KpiVariableValueCreateManyAndReturnArgs} args - Arguments to create many KpiVariableValues.
     * @example
     * // Create many KpiVariableValues
     * const kpiVariableValue = await prisma.kpiVariableValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KpiVariableValues and only return the `id`
     * const kpiVariableValueWithIdOnly = await prisma.kpiVariableValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KpiVariableValueCreateManyAndReturnArgs>(args?: SelectSubset<T, KpiVariableValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiVariableValuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KpiVariableValue.
     * @param {KpiVariableValueDeleteArgs} args - Arguments to delete one KpiVariableValue.
     * @example
     * // Delete one KpiVariableValue
     * const KpiVariableValue = await prisma.kpiVariableValue.delete({
     *   where: {
     *     // ... filter to delete one KpiVariableValue
     *   }
     * })
     * 
     */
    delete<T extends KpiVariableValueDeleteArgs>(args: SelectSubset<T, KpiVariableValueDeleteArgs<ExtArgs>>): Prisma__KpiVariableValueClient<$Result.GetResult<Prisma.$KpiVariableValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KpiVariableValue.
     * @param {KpiVariableValueUpdateArgs} args - Arguments to update one KpiVariableValue.
     * @example
     * // Update one KpiVariableValue
     * const kpiVariableValue = await prisma.kpiVariableValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KpiVariableValueUpdateArgs>(args: SelectSubset<T, KpiVariableValueUpdateArgs<ExtArgs>>): Prisma__KpiVariableValueClient<$Result.GetResult<Prisma.$KpiVariableValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KpiVariableValues.
     * @param {KpiVariableValueDeleteManyArgs} args - Arguments to filter KpiVariableValues to delete.
     * @example
     * // Delete a few KpiVariableValues
     * const { count } = await prisma.kpiVariableValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KpiVariableValueDeleteManyArgs>(args?: SelectSubset<T, KpiVariableValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KpiVariableValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiVariableValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KpiVariableValues
     * const kpiVariableValue = await prisma.kpiVariableValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KpiVariableValueUpdateManyArgs>(args: SelectSubset<T, KpiVariableValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KpiVariableValues and returns the data updated in the database.
     * @param {KpiVariableValueUpdateManyAndReturnArgs} args - Arguments to update many KpiVariableValues.
     * @example
     * // Update many KpiVariableValues
     * const kpiVariableValue = await prisma.kpiVariableValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KpiVariableValues and only return the `id`
     * const kpiVariableValueWithIdOnly = await prisma.kpiVariableValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KpiVariableValueUpdateManyAndReturnArgs>(args: SelectSubset<T, KpiVariableValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KpiVariableValuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KpiVariableValue.
     * @param {KpiVariableValueUpsertArgs} args - Arguments to update or create a KpiVariableValue.
     * @example
     * // Update or create a KpiVariableValue
     * const kpiVariableValue = await prisma.kpiVariableValue.upsert({
     *   create: {
     *     // ... data to create a KpiVariableValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KpiVariableValue we want to update
     *   }
     * })
     */
    upsert<T extends KpiVariableValueUpsertArgs>(args: SelectSubset<T, KpiVariableValueUpsertArgs<ExtArgs>>): Prisma__KpiVariableValueClient<$Result.GetResult<Prisma.$KpiVariableValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KpiVariableValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiVariableValueCountArgs} args - Arguments to filter KpiVariableValues to count.
     * @example
     * // Count the number of KpiVariableValues
     * const count = await prisma.kpiVariableValue.count({
     *   where: {
     *     // ... the filter for the KpiVariableValues we want to count
     *   }
     * })
    **/
    count<T extends KpiVariableValueCountArgs>(
      args?: Subset<T, KpiVariableValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KpiVariableValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KpiVariableValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiVariableValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KpiVariableValueAggregateArgs>(args: Subset<T, KpiVariableValueAggregateArgs>): Prisma.PrismaPromise<GetKpiVariableValueAggregateType<T>>

    /**
     * Group by KpiVariableValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KpiVariableValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KpiVariableValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KpiVariableValueGroupByArgs['orderBy'] }
        : { orderBy?: KpiVariableValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KpiVariableValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKpiVariableValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KpiVariableValue model
   */
  readonly fields: KpiVariableValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KpiVariableValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KpiVariableValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kpiValue<T extends KpiValuePeriodDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KpiValuePeriodDefaultArgs<ExtArgs>>): Prisma__KpiValuePeriodClient<$Result.GetResult<Prisma.$KpiValuePeriodPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    kpiVariable<T extends KpiVariableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KpiVariableDefaultArgs<ExtArgs>>): Prisma__KpiVariableClient<$Result.GetResult<Prisma.$KpiVariablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KpiVariableValue model
   */
  interface KpiVariableValueFieldRefs {
    readonly id: FieldRef<"KpiVariableValue", 'String'>
    readonly kpiValueId: FieldRef<"KpiVariableValue", 'String'>
    readonly kpiVariableId: FieldRef<"KpiVariableValue", 'String'>
    readonly value: FieldRef<"KpiVariableValue", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * KpiVariableValue findUnique
   */
  export type KpiVariableValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariableValue
     */
    select?: KpiVariableValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariableValue
     */
    omit?: KpiVariableValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableValueInclude<ExtArgs> | null
    /**
     * Filter, which KpiVariableValue to fetch.
     */
    where: KpiVariableValueWhereUniqueInput
  }

  /**
   * KpiVariableValue findUniqueOrThrow
   */
  export type KpiVariableValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariableValue
     */
    select?: KpiVariableValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariableValue
     */
    omit?: KpiVariableValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableValueInclude<ExtArgs> | null
    /**
     * Filter, which KpiVariableValue to fetch.
     */
    where: KpiVariableValueWhereUniqueInput
  }

  /**
   * KpiVariableValue findFirst
   */
  export type KpiVariableValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariableValue
     */
    select?: KpiVariableValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariableValue
     */
    omit?: KpiVariableValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableValueInclude<ExtArgs> | null
    /**
     * Filter, which KpiVariableValue to fetch.
     */
    where?: KpiVariableValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiVariableValues to fetch.
     */
    orderBy?: KpiVariableValueOrderByWithRelationInput | KpiVariableValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KpiVariableValues.
     */
    cursor?: KpiVariableValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiVariableValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiVariableValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KpiVariableValues.
     */
    distinct?: KpiVariableValueScalarFieldEnum | KpiVariableValueScalarFieldEnum[]
  }

  /**
   * KpiVariableValue findFirstOrThrow
   */
  export type KpiVariableValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariableValue
     */
    select?: KpiVariableValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariableValue
     */
    omit?: KpiVariableValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableValueInclude<ExtArgs> | null
    /**
     * Filter, which KpiVariableValue to fetch.
     */
    where?: KpiVariableValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiVariableValues to fetch.
     */
    orderBy?: KpiVariableValueOrderByWithRelationInput | KpiVariableValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KpiVariableValues.
     */
    cursor?: KpiVariableValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiVariableValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiVariableValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KpiVariableValues.
     */
    distinct?: KpiVariableValueScalarFieldEnum | KpiVariableValueScalarFieldEnum[]
  }

  /**
   * KpiVariableValue findMany
   */
  export type KpiVariableValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariableValue
     */
    select?: KpiVariableValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariableValue
     */
    omit?: KpiVariableValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableValueInclude<ExtArgs> | null
    /**
     * Filter, which KpiVariableValues to fetch.
     */
    where?: KpiVariableValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KpiVariableValues to fetch.
     */
    orderBy?: KpiVariableValueOrderByWithRelationInput | KpiVariableValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KpiVariableValues.
     */
    cursor?: KpiVariableValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KpiVariableValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KpiVariableValues.
     */
    skip?: number
    distinct?: KpiVariableValueScalarFieldEnum | KpiVariableValueScalarFieldEnum[]
  }

  /**
   * KpiVariableValue create
   */
  export type KpiVariableValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariableValue
     */
    select?: KpiVariableValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariableValue
     */
    omit?: KpiVariableValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableValueInclude<ExtArgs> | null
    /**
     * The data needed to create a KpiVariableValue.
     */
    data: XOR<KpiVariableValueCreateInput, KpiVariableValueUncheckedCreateInput>
  }

  /**
   * KpiVariableValue createMany
   */
  export type KpiVariableValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KpiVariableValues.
     */
    data: KpiVariableValueCreateManyInput | KpiVariableValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KpiVariableValue createManyAndReturn
   */
  export type KpiVariableValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariableValue
     */
    select?: KpiVariableValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariableValue
     */
    omit?: KpiVariableValueOmit<ExtArgs> | null
    /**
     * The data used to create many KpiVariableValues.
     */
    data: KpiVariableValueCreateManyInput | KpiVariableValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KpiVariableValue update
   */
  export type KpiVariableValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariableValue
     */
    select?: KpiVariableValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariableValue
     */
    omit?: KpiVariableValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableValueInclude<ExtArgs> | null
    /**
     * The data needed to update a KpiVariableValue.
     */
    data: XOR<KpiVariableValueUpdateInput, KpiVariableValueUncheckedUpdateInput>
    /**
     * Choose, which KpiVariableValue to update.
     */
    where: KpiVariableValueWhereUniqueInput
  }

  /**
   * KpiVariableValue updateMany
   */
  export type KpiVariableValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KpiVariableValues.
     */
    data: XOR<KpiVariableValueUpdateManyMutationInput, KpiVariableValueUncheckedUpdateManyInput>
    /**
     * Filter which KpiVariableValues to update
     */
    where?: KpiVariableValueWhereInput
    /**
     * Limit how many KpiVariableValues to update.
     */
    limit?: number
  }

  /**
   * KpiVariableValue updateManyAndReturn
   */
  export type KpiVariableValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariableValue
     */
    select?: KpiVariableValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariableValue
     */
    omit?: KpiVariableValueOmit<ExtArgs> | null
    /**
     * The data used to update KpiVariableValues.
     */
    data: XOR<KpiVariableValueUpdateManyMutationInput, KpiVariableValueUncheckedUpdateManyInput>
    /**
     * Filter which KpiVariableValues to update
     */
    where?: KpiVariableValueWhereInput
    /**
     * Limit how many KpiVariableValues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KpiVariableValue upsert
   */
  export type KpiVariableValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariableValue
     */
    select?: KpiVariableValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariableValue
     */
    omit?: KpiVariableValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableValueInclude<ExtArgs> | null
    /**
     * The filter to search for the KpiVariableValue to update in case it exists.
     */
    where: KpiVariableValueWhereUniqueInput
    /**
     * In case the KpiVariableValue found by the `where` argument doesn't exist, create a new KpiVariableValue with this data.
     */
    create: XOR<KpiVariableValueCreateInput, KpiVariableValueUncheckedCreateInput>
    /**
     * In case the KpiVariableValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KpiVariableValueUpdateInput, KpiVariableValueUncheckedUpdateInput>
  }

  /**
   * KpiVariableValue delete
   */
  export type KpiVariableValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariableValue
     */
    select?: KpiVariableValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariableValue
     */
    omit?: KpiVariableValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableValueInclude<ExtArgs> | null
    /**
     * Filter which KpiVariableValue to delete.
     */
    where: KpiVariableValueWhereUniqueInput
  }

  /**
   * KpiVariableValue deleteMany
   */
  export type KpiVariableValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KpiVariableValues to delete
     */
    where?: KpiVariableValueWhereInput
    /**
     * Limit how many KpiVariableValues to delete.
     */
    limit?: number
  }

  /**
   * KpiVariableValue without action
   */
  export type KpiVariableValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KpiVariableValue
     */
    select?: KpiVariableValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KpiVariableValue
     */
    omit?: KpiVariableValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KpiVariableValueInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    domain: 'domain',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    name: 'name',
    code: 'code',
    parentId: 'parentId',
    managerId: 'managerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    email: 'email',
    emailVerified: 'emailVerified',
    name: 'name',
    role: 'role',
    managerId: 'managerId',
    departmentId: 'departmentId',
    title: 'title',
    image: 'image',
    hashedPassword: 'hashedPassword',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    expiresAt: 'expiresAt',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const UserPreferenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    locale: 'locale',
    theme: 'theme',
    notifications: 'notifications',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPreferenceScalarFieldEnum = (typeof UserPreferenceScalarFieldEnum)[keyof typeof UserPreferenceScalarFieldEnum]


  export const ChangeRequestScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    entityType: 'entityType',
    entityId: 'entityId',
    payload: 'payload',
    status: 'status',
    requestedBy: 'requestedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    decidedAt: 'decidedAt',
    deletedAt: 'deletedAt'
  };

  export type ChangeRequestScalarFieldEnum = (typeof ChangeRequestScalarFieldEnum)[keyof typeof ChangeRequestScalarFieldEnum]


  export const ChangeApprovalScalarFieldEnum: {
    id: 'id',
    changeRequestId: 'changeRequestId',
    approverId: 'approverId',
    status: 'status',
    comment: 'comment',
    createdAt: 'createdAt',
    decidedAt: 'decidedAt'
  };

  export type ChangeApprovalScalarFieldEnum = (typeof ChangeApprovalScalarFieldEnum)[keyof typeof ChangeApprovalScalarFieldEnum]


  export const NodeTypeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    displayName: 'displayName',
    levelOrder: 'levelOrder',
    canHaveKpis: 'canHaveKpis'
  };

  export type NodeTypeScalarFieldEnum = (typeof NodeTypeScalarFieldEnum)[keyof typeof NodeTypeScalarFieldEnum]


  export const NodeScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    nodeTypeId: 'nodeTypeId',
    parentId: 'parentId',
    name: 'name',
    description: 'description',
    ownerUserId: 'ownerUserId',
    status: 'status',
    progress: 'progress',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type NodeScalarFieldEnum = (typeof NodeScalarFieldEnum)[keyof typeof NodeScalarFieldEnum]


  export const NodeAssignmentScalarFieldEnum: {
    id: 'id',
    nodeId: 'nodeId',
    userId: 'userId',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NodeAssignmentScalarFieldEnum = (typeof NodeAssignmentScalarFieldEnum)[keyof typeof NodeAssignmentScalarFieldEnum]


  export const NodeDependencyScalarFieldEnum: {
    id: 'id',
    blockedNodeId: 'blockedNodeId',
    dependsOnNodeId: 'dependsOnNodeId',
    createdAt: 'createdAt'
  };

  export type NodeDependencyScalarFieldEnum = (typeof NodeDependencyScalarFieldEnum)[keyof typeof NodeDependencyScalarFieldEnum]


  export const KpiDefinitionScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    primaryNodeId: 'primaryNodeId',
    ownerUserId: 'ownerUserId',
    name: 'name',
    description: 'description',
    formula: 'formula',
    unit: 'unit',
    direction: 'direction',
    aggregation: 'aggregation',
    periodType: 'periodType',
    baselineValue: 'baselineValue',
    targetValue: 'targetValue',
    weight: 'weight',
    status: 'status'
  };

  export type KpiDefinitionScalarFieldEnum = (typeof KpiDefinitionScalarFieldEnum)[keyof typeof KpiDefinitionScalarFieldEnum]


  export const KpiVariableScalarFieldEnum: {
    id: 'id',
    kpiId: 'kpiId',
    code: 'code',
    displayName: 'displayName',
    dataType: 'dataType',
    isRequired: 'isRequired'
  };

  export type KpiVariableScalarFieldEnum = (typeof KpiVariableScalarFieldEnum)[keyof typeof KpiVariableScalarFieldEnum]


  export const KpiValuePeriodScalarFieldEnum: {
    id: 'id',
    kpiId: 'kpiId',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    calculatedValue: 'calculatedValue',
    status: 'status',
    note: 'note',
    enteredBy: 'enteredBy',
    approvedBy: 'approvedBy',
    submittedAt: 'submittedAt',
    approvedAt: 'approvedAt',
    lockedAt: 'lockedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KpiValuePeriodScalarFieldEnum = (typeof KpiValuePeriodScalarFieldEnum)[keyof typeof KpiValuePeriodScalarFieldEnum]


  export const KpiVariableValueScalarFieldEnum: {
    id: 'id',
    kpiValueId: 'kpiValueId',
    kpiVariableId: 'kpiVariableId',
    value: 'value'
  };

  export type KpiVariableValueScalarFieldEnum = (typeof KpiVariableValueScalarFieldEnum)[keyof typeof KpiVariableValueScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ApprovalStatus'
   */
  export type EnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus'>
    


  /**
   * Reference to a field of type 'ApprovalStatus[]'
   */
  export type ListEnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus[]'>
    


  /**
   * Reference to a field of type 'NodeTypeCode'
   */
  export type EnumNodeTypeCodeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NodeTypeCode'>
    


  /**
   * Reference to a field of type 'NodeTypeCode[]'
   */
  export type ListEnumNodeTypeCodeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NodeTypeCode[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'NodeAssignmentRole'
   */
  export type EnumNodeAssignmentRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NodeAssignmentRole'>
    


  /**
   * Reference to a field of type 'NodeAssignmentRole[]'
   */
  export type ListEnumNodeAssignmentRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NodeAssignmentRole[]'>
    


  /**
   * Reference to a field of type 'KpiDirection'
   */
  export type EnumKpiDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KpiDirection'>
    


  /**
   * Reference to a field of type 'KpiDirection[]'
   */
  export type ListEnumKpiDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KpiDirection[]'>
    


  /**
   * Reference to a field of type 'KpiAggregationMethod'
   */
  export type EnumKpiAggregationMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KpiAggregationMethod'>
    


  /**
   * Reference to a field of type 'KpiAggregationMethod[]'
   */
  export type ListEnumKpiAggregationMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KpiAggregationMethod[]'>
    


  /**
   * Reference to a field of type 'KpiPeriodType'
   */
  export type EnumKpiPeriodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KpiPeriodType'>
    


  /**
   * Reference to a field of type 'KpiPeriodType[]'
   */
  export type ListEnumKpiPeriodTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KpiPeriodType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'KpiDefinitionStatus'
   */
  export type EnumKpiDefinitionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KpiDefinitionStatus'>
    


  /**
   * Reference to a field of type 'KpiDefinitionStatus[]'
   */
  export type ListEnumKpiDefinitionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KpiDefinitionStatus[]'>
    


  /**
   * Reference to a field of type 'KpiVariableDataType'
   */
  export type EnumKpiVariableDataTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KpiVariableDataType'>
    


  /**
   * Reference to a field of type 'KpiVariableDataType[]'
   */
  export type ListEnumKpiVariableDataTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KpiVariableDataType[]'>
    


  /**
   * Reference to a field of type 'KpiValueStatus'
   */
  export type EnumKpiValueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KpiValueStatus'>
    


  /**
   * Reference to a field of type 'KpiValueStatus[]'
   */
  export type ListEnumKpiValueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KpiValueStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    domain?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Organization"> | Date | string | null
    users?: UserListRelationFilter
    departments?: DepartmentListRelationFilter
    nodes?: NodeListRelationFilter
    kpis?: KpiDefinitionListRelationFilter
    changeRequests?: ChangeRequestListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    users?: UserOrderByRelationAggregateInput
    departments?: DepartmentOrderByRelationAggregateInput
    nodes?: NodeOrderByRelationAggregateInput
    kpis?: KpiDefinitionOrderByRelationAggregateInput
    changeRequests?: ChangeRequestOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    domain?: StringNullableFilter<"Organization"> | string | null
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Organization"> | Date | string | null
    users?: UserListRelationFilter
    departments?: DepartmentListRelationFilter
    nodes?: NodeListRelationFilter
    kpis?: KpiDefinitionListRelationFilter
    changeRequests?: ChangeRequestListRelationFilter
  }, "id">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    domain?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Organization"> | Date | string | null
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    orgId?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    code?: StringNullableFilter<"Department"> | string | null
    parentId?: StringNullableFilter<"Department"> | string | null
    managerId?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Department"> | Date | string | null
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    parent?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    children?: DepartmentListRelationFilter
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    users?: UserListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    org?: OrganizationOrderByWithRelationInput
    parent?: DepartmentOrderByWithRelationInput
    children?: DepartmentOrderByRelationAggregateInput
    manager?: UserOrderByWithRelationInput
    users?: UserOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    dept_name_org_soft_unique?: DepartmentDept_name_org_soft_uniqueCompoundUniqueInput
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    orgId?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    code?: StringNullableFilter<"Department"> | string | null
    parentId?: StringNullableFilter<"Department"> | string | null
    managerId?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Department"> | Date | string | null
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    parent?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    children?: DepartmentListRelationFilter
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    users?: UserListRelationFilter
  }, "id" | "dept_name_org_soft_unique">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    orgId?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    code?: StringNullableWithAggregatesFilter<"Department"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"Department"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"Department"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Department"> | Date | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    orgId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    managerId?: StringNullableFilter<"User"> | string | null
    departmentId?: StringNullableFilter<"User"> | string | null
    title?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    hashedPassword?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    directReports?: UserListRelationFilter
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    managedDepartments?: DepartmentListRelationFilter
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    preferences?: XOR<UserPreferenceNullableScalarRelationFilter, UserPreferenceWhereInput> | null
    approvals?: ChangeApprovalListRelationFilter
    changeRequests?: ChangeRequestListRelationFilter
    ownedNodes?: NodeListRelationFilter
    nodeAssignments?: NodeAssignmentListRelationFilter
    kpiValuesEntered?: KpiValuePeriodListRelationFilter
    kpiValuesApproved?: KpiValuePeriodListRelationFilter
    ownedKpis?: KpiDefinitionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
    role?: SortOrder
    managerId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    hashedPassword?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    org?: OrganizationOrderByWithRelationInput
    manager?: UserOrderByWithRelationInput
    directReports?: UserOrderByRelationAggregateInput
    department?: DepartmentOrderByWithRelationInput
    managedDepartments?: DepartmentOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    preferences?: UserPreferenceOrderByWithRelationInput
    approvals?: ChangeApprovalOrderByRelationAggregateInput
    changeRequests?: ChangeRequestOrderByRelationAggregateInput
    ownedNodes?: NodeOrderByRelationAggregateInput
    nodeAssignments?: NodeAssignmentOrderByRelationAggregateInput
    kpiValuesEntered?: KpiValuePeriodOrderByRelationAggregateInput
    kpiValuesApproved?: KpiValuePeriodOrderByRelationAggregateInput
    ownedKpis?: KpiDefinitionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_email_org_unique?: UserUser_email_org_uniqueCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    orgId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    managerId?: StringNullableFilter<"User"> | string | null
    departmentId?: StringNullableFilter<"User"> | string | null
    title?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    hashedPassword?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    manager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    directReports?: UserListRelationFilter
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    managedDepartments?: DepartmentListRelationFilter
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    preferences?: XOR<UserPreferenceNullableScalarRelationFilter, UserPreferenceWhereInput> | null
    approvals?: ChangeApprovalListRelationFilter
    changeRequests?: ChangeRequestListRelationFilter
    ownedNodes?: NodeListRelationFilter
    nodeAssignments?: NodeAssignmentListRelationFilter
    kpiValuesEntered?: KpiValuePeriodListRelationFilter
    kpiValuesApproved?: KpiValuePeriodListRelationFilter
    ownedKpis?: KpiDefinitionListRelationFilter
  }, "id" | "user_email_org_unique">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
    role?: SortOrder
    managerId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    hashedPassword?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    orgId?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    managerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    departmentId?: StringNullableWithAggregatesFilter<"User"> | string | null
    title?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    hashedPassword?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    token?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userId?: StringWithAggregatesFilter<"Session"> | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeFilter<"Verification"> | Date | string
    updatedAt?: DateTimeFilter<"Verification"> | Date | string
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
  }

  export type UserPreferenceWhereInput = {
    AND?: UserPreferenceWhereInput | UserPreferenceWhereInput[]
    OR?: UserPreferenceWhereInput[]
    NOT?: UserPreferenceWhereInput | UserPreferenceWhereInput[]
    id?: StringFilter<"UserPreference"> | string
    userId?: StringFilter<"UserPreference"> | string
    locale?: StringFilter<"UserPreference"> | string
    theme?: StringFilter<"UserPreference"> | string
    notifications?: JsonNullableFilter<"UserPreference">
    createdAt?: DateTimeFilter<"UserPreference"> | Date | string
    updatedAt?: DateTimeFilter<"UserPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPreferenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    locale?: SortOrder
    theme?: SortOrder
    notifications?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPreferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserPreferenceWhereInput | UserPreferenceWhereInput[]
    OR?: UserPreferenceWhereInput[]
    NOT?: UserPreferenceWhereInput | UserPreferenceWhereInput[]
    locale?: StringFilter<"UserPreference"> | string
    theme?: StringFilter<"UserPreference"> | string
    notifications?: JsonNullableFilter<"UserPreference">
    createdAt?: DateTimeFilter<"UserPreference"> | Date | string
    updatedAt?: DateTimeFilter<"UserPreference"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserPreferenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    locale?: SortOrder
    theme?: SortOrder
    notifications?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPreferenceCountOrderByAggregateInput
    _max?: UserPreferenceMaxOrderByAggregateInput
    _min?: UserPreferenceMinOrderByAggregateInput
  }

  export type UserPreferenceScalarWhereWithAggregatesInput = {
    AND?: UserPreferenceScalarWhereWithAggregatesInput | UserPreferenceScalarWhereWithAggregatesInput[]
    OR?: UserPreferenceScalarWhereWithAggregatesInput[]
    NOT?: UserPreferenceScalarWhereWithAggregatesInput | UserPreferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPreference"> | string
    userId?: StringWithAggregatesFilter<"UserPreference"> | string
    locale?: StringWithAggregatesFilter<"UserPreference"> | string
    theme?: StringWithAggregatesFilter<"UserPreference"> | string
    notifications?: JsonNullableWithAggregatesFilter<"UserPreference">
    createdAt?: DateTimeWithAggregatesFilter<"UserPreference"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPreference"> | Date | string
  }

  export type ChangeRequestWhereInput = {
    AND?: ChangeRequestWhereInput | ChangeRequestWhereInput[]
    OR?: ChangeRequestWhereInput[]
    NOT?: ChangeRequestWhereInput | ChangeRequestWhereInput[]
    id?: StringFilter<"ChangeRequest"> | string
    orgId?: StringFilter<"ChangeRequest"> | string
    entityType?: StringFilter<"ChangeRequest"> | string
    entityId?: StringFilter<"ChangeRequest"> | string
    payload?: JsonFilter<"ChangeRequest">
    status?: EnumApprovalStatusFilter<"ChangeRequest"> | $Enums.ApprovalStatus
    requestedBy?: StringFilter<"ChangeRequest"> | string
    createdAt?: DateTimeFilter<"ChangeRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ChangeRequest"> | Date | string
    decidedAt?: DateTimeNullableFilter<"ChangeRequest"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"ChangeRequest"> | Date | string | null
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    requester?: XOR<UserScalarRelationFilter, UserWhereInput>
    approvals?: ChangeApprovalListRelationFilter
  }

  export type ChangeRequestOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    requestedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    decidedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    org?: OrganizationOrderByWithRelationInput
    requester?: UserOrderByWithRelationInput
    approvals?: ChangeApprovalOrderByRelationAggregateInput
  }

  export type ChangeRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChangeRequestWhereInput | ChangeRequestWhereInput[]
    OR?: ChangeRequestWhereInput[]
    NOT?: ChangeRequestWhereInput | ChangeRequestWhereInput[]
    orgId?: StringFilter<"ChangeRequest"> | string
    entityType?: StringFilter<"ChangeRequest"> | string
    entityId?: StringFilter<"ChangeRequest"> | string
    payload?: JsonFilter<"ChangeRequest">
    status?: EnumApprovalStatusFilter<"ChangeRequest"> | $Enums.ApprovalStatus
    requestedBy?: StringFilter<"ChangeRequest"> | string
    createdAt?: DateTimeFilter<"ChangeRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ChangeRequest"> | Date | string
    decidedAt?: DateTimeNullableFilter<"ChangeRequest"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"ChangeRequest"> | Date | string | null
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    requester?: XOR<UserScalarRelationFilter, UserWhereInput>
    approvals?: ChangeApprovalListRelationFilter
  }, "id">

  export type ChangeRequestOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    requestedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    decidedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ChangeRequestCountOrderByAggregateInput
    _max?: ChangeRequestMaxOrderByAggregateInput
    _min?: ChangeRequestMinOrderByAggregateInput
  }

  export type ChangeRequestScalarWhereWithAggregatesInput = {
    AND?: ChangeRequestScalarWhereWithAggregatesInput | ChangeRequestScalarWhereWithAggregatesInput[]
    OR?: ChangeRequestScalarWhereWithAggregatesInput[]
    NOT?: ChangeRequestScalarWhereWithAggregatesInput | ChangeRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChangeRequest"> | string
    orgId?: StringWithAggregatesFilter<"ChangeRequest"> | string
    entityType?: StringWithAggregatesFilter<"ChangeRequest"> | string
    entityId?: StringWithAggregatesFilter<"ChangeRequest"> | string
    payload?: JsonWithAggregatesFilter<"ChangeRequest">
    status?: EnumApprovalStatusWithAggregatesFilter<"ChangeRequest"> | $Enums.ApprovalStatus
    requestedBy?: StringWithAggregatesFilter<"ChangeRequest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChangeRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChangeRequest"> | Date | string
    decidedAt?: DateTimeNullableWithAggregatesFilter<"ChangeRequest"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ChangeRequest"> | Date | string | null
  }

  export type ChangeApprovalWhereInput = {
    AND?: ChangeApprovalWhereInput | ChangeApprovalWhereInput[]
    OR?: ChangeApprovalWhereInput[]
    NOT?: ChangeApprovalWhereInput | ChangeApprovalWhereInput[]
    id?: StringFilter<"ChangeApproval"> | string
    changeRequestId?: StringFilter<"ChangeApproval"> | string
    approverId?: StringFilter<"ChangeApproval"> | string
    status?: EnumApprovalStatusFilter<"ChangeApproval"> | $Enums.ApprovalStatus
    comment?: StringNullableFilter<"ChangeApproval"> | string | null
    createdAt?: DateTimeFilter<"ChangeApproval"> | Date | string
    decidedAt?: DateTimeNullableFilter<"ChangeApproval"> | Date | string | null
    changeRequest?: XOR<ChangeRequestScalarRelationFilter, ChangeRequestWhereInput>
    approver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ChangeApprovalOrderByWithRelationInput = {
    id?: SortOrder
    changeRequestId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    decidedAt?: SortOrderInput | SortOrder
    changeRequest?: ChangeRequestOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
  }

  export type ChangeApprovalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    approval_once_per_user?: ChangeApprovalApproval_once_per_userCompoundUniqueInput
    AND?: ChangeApprovalWhereInput | ChangeApprovalWhereInput[]
    OR?: ChangeApprovalWhereInput[]
    NOT?: ChangeApprovalWhereInput | ChangeApprovalWhereInput[]
    changeRequestId?: StringFilter<"ChangeApproval"> | string
    approverId?: StringFilter<"ChangeApproval"> | string
    status?: EnumApprovalStatusFilter<"ChangeApproval"> | $Enums.ApprovalStatus
    comment?: StringNullableFilter<"ChangeApproval"> | string | null
    createdAt?: DateTimeFilter<"ChangeApproval"> | Date | string
    decidedAt?: DateTimeNullableFilter<"ChangeApproval"> | Date | string | null
    changeRequest?: XOR<ChangeRequestScalarRelationFilter, ChangeRequestWhereInput>
    approver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "approval_once_per_user">

  export type ChangeApprovalOrderByWithAggregationInput = {
    id?: SortOrder
    changeRequestId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    decidedAt?: SortOrderInput | SortOrder
    _count?: ChangeApprovalCountOrderByAggregateInput
    _max?: ChangeApprovalMaxOrderByAggregateInput
    _min?: ChangeApprovalMinOrderByAggregateInput
  }

  export type ChangeApprovalScalarWhereWithAggregatesInput = {
    AND?: ChangeApprovalScalarWhereWithAggregatesInput | ChangeApprovalScalarWhereWithAggregatesInput[]
    OR?: ChangeApprovalScalarWhereWithAggregatesInput[]
    NOT?: ChangeApprovalScalarWhereWithAggregatesInput | ChangeApprovalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChangeApproval"> | string
    changeRequestId?: StringWithAggregatesFilter<"ChangeApproval"> | string
    approverId?: StringWithAggregatesFilter<"ChangeApproval"> | string
    status?: EnumApprovalStatusWithAggregatesFilter<"ChangeApproval"> | $Enums.ApprovalStatus
    comment?: StringNullableWithAggregatesFilter<"ChangeApproval"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChangeApproval"> | Date | string
    decidedAt?: DateTimeNullableWithAggregatesFilter<"ChangeApproval"> | Date | string | null
  }

  export type NodeTypeWhereInput = {
    AND?: NodeTypeWhereInput | NodeTypeWhereInput[]
    OR?: NodeTypeWhereInput[]
    NOT?: NodeTypeWhereInput | NodeTypeWhereInput[]
    id?: StringFilter<"NodeType"> | string
    code?: EnumNodeTypeCodeFilter<"NodeType"> | $Enums.NodeTypeCode
    displayName?: StringFilter<"NodeType"> | string
    levelOrder?: IntFilter<"NodeType"> | number
    canHaveKpis?: BoolFilter<"NodeType"> | boolean
    nodes?: NodeListRelationFilter
  }

  export type NodeTypeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    displayName?: SortOrder
    levelOrder?: SortOrder
    canHaveKpis?: SortOrder
    nodes?: NodeOrderByRelationAggregateInput
  }

  export type NodeTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: $Enums.NodeTypeCode
    AND?: NodeTypeWhereInput | NodeTypeWhereInput[]
    OR?: NodeTypeWhereInput[]
    NOT?: NodeTypeWhereInput | NodeTypeWhereInput[]
    displayName?: StringFilter<"NodeType"> | string
    levelOrder?: IntFilter<"NodeType"> | number
    canHaveKpis?: BoolFilter<"NodeType"> | boolean
    nodes?: NodeListRelationFilter
  }, "id" | "code">

  export type NodeTypeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    displayName?: SortOrder
    levelOrder?: SortOrder
    canHaveKpis?: SortOrder
    _count?: NodeTypeCountOrderByAggregateInput
    _avg?: NodeTypeAvgOrderByAggregateInput
    _max?: NodeTypeMaxOrderByAggregateInput
    _min?: NodeTypeMinOrderByAggregateInput
    _sum?: NodeTypeSumOrderByAggregateInput
  }

  export type NodeTypeScalarWhereWithAggregatesInput = {
    AND?: NodeTypeScalarWhereWithAggregatesInput | NodeTypeScalarWhereWithAggregatesInput[]
    OR?: NodeTypeScalarWhereWithAggregatesInput[]
    NOT?: NodeTypeScalarWhereWithAggregatesInput | NodeTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NodeType"> | string
    code?: EnumNodeTypeCodeWithAggregatesFilter<"NodeType"> | $Enums.NodeTypeCode
    displayName?: StringWithAggregatesFilter<"NodeType"> | string
    levelOrder?: IntWithAggregatesFilter<"NodeType"> | number
    canHaveKpis?: BoolWithAggregatesFilter<"NodeType"> | boolean
  }

  export type NodeWhereInput = {
    AND?: NodeWhereInput | NodeWhereInput[]
    OR?: NodeWhereInput[]
    NOT?: NodeWhereInput | NodeWhereInput[]
    id?: StringFilter<"Node"> | string
    orgId?: StringFilter<"Node"> | string
    nodeTypeId?: StringFilter<"Node"> | string
    parentId?: StringNullableFilter<"Node"> | string | null
    name?: StringFilter<"Node"> | string
    description?: StringNullableFilter<"Node"> | string | null
    ownerUserId?: StringNullableFilter<"Node"> | string | null
    status?: EnumStatusFilter<"Node"> | $Enums.Status
    progress?: IntFilter<"Node"> | number
    startDate?: DateTimeNullableFilter<"Node"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Node"> | Date | string | null
    createdAt?: DateTimeFilter<"Node"> | Date | string
    updatedAt?: DateTimeFilter<"Node"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Node"> | Date | string | null
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    nodeType?: XOR<NodeTypeScalarRelationFilter, NodeTypeWhereInput>
    parent?: XOR<NodeNullableScalarRelationFilter, NodeWhereInput> | null
    children?: NodeListRelationFilter
    ownerUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    assignments?: NodeAssignmentListRelationFilter
    outgoingDeps?: NodeDependencyListRelationFilter
    incomingDeps?: NodeDependencyListRelationFilter
    kpis?: KpiDefinitionListRelationFilter
  }

  export type NodeOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    nodeTypeId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ownerUserId?: SortOrderInput | SortOrder
    status?: SortOrder
    progress?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    org?: OrganizationOrderByWithRelationInput
    nodeType?: NodeTypeOrderByWithRelationInput
    parent?: NodeOrderByWithRelationInput
    children?: NodeOrderByRelationAggregateInput
    ownerUser?: UserOrderByWithRelationInput
    assignments?: NodeAssignmentOrderByRelationAggregateInput
    outgoingDeps?: NodeDependencyOrderByRelationAggregateInput
    incomingDeps?: NodeDependencyOrderByRelationAggregateInput
    kpis?: KpiDefinitionOrderByRelationAggregateInput
  }

  export type NodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NodeWhereInput | NodeWhereInput[]
    OR?: NodeWhereInput[]
    NOT?: NodeWhereInput | NodeWhereInput[]
    orgId?: StringFilter<"Node"> | string
    nodeTypeId?: StringFilter<"Node"> | string
    parentId?: StringNullableFilter<"Node"> | string | null
    name?: StringFilter<"Node"> | string
    description?: StringNullableFilter<"Node"> | string | null
    ownerUserId?: StringNullableFilter<"Node"> | string | null
    status?: EnumStatusFilter<"Node"> | $Enums.Status
    progress?: IntFilter<"Node"> | number
    startDate?: DateTimeNullableFilter<"Node"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Node"> | Date | string | null
    createdAt?: DateTimeFilter<"Node"> | Date | string
    updatedAt?: DateTimeFilter<"Node"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Node"> | Date | string | null
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    nodeType?: XOR<NodeTypeScalarRelationFilter, NodeTypeWhereInput>
    parent?: XOR<NodeNullableScalarRelationFilter, NodeWhereInput> | null
    children?: NodeListRelationFilter
    ownerUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    assignments?: NodeAssignmentListRelationFilter
    outgoingDeps?: NodeDependencyListRelationFilter
    incomingDeps?: NodeDependencyListRelationFilter
    kpis?: KpiDefinitionListRelationFilter
  }, "id">

  export type NodeOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    nodeTypeId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ownerUserId?: SortOrderInput | SortOrder
    status?: SortOrder
    progress?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: NodeCountOrderByAggregateInput
    _avg?: NodeAvgOrderByAggregateInput
    _max?: NodeMaxOrderByAggregateInput
    _min?: NodeMinOrderByAggregateInput
    _sum?: NodeSumOrderByAggregateInput
  }

  export type NodeScalarWhereWithAggregatesInput = {
    AND?: NodeScalarWhereWithAggregatesInput | NodeScalarWhereWithAggregatesInput[]
    OR?: NodeScalarWhereWithAggregatesInput[]
    NOT?: NodeScalarWhereWithAggregatesInput | NodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Node"> | string
    orgId?: StringWithAggregatesFilter<"Node"> | string
    nodeTypeId?: StringWithAggregatesFilter<"Node"> | string
    parentId?: StringNullableWithAggregatesFilter<"Node"> | string | null
    name?: StringWithAggregatesFilter<"Node"> | string
    description?: StringNullableWithAggregatesFilter<"Node"> | string | null
    ownerUserId?: StringNullableWithAggregatesFilter<"Node"> | string | null
    status?: EnumStatusWithAggregatesFilter<"Node"> | $Enums.Status
    progress?: IntWithAggregatesFilter<"Node"> | number
    startDate?: DateTimeNullableWithAggregatesFilter<"Node"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Node"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Node"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Node"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Node"> | Date | string | null
  }

  export type NodeAssignmentWhereInput = {
    AND?: NodeAssignmentWhereInput | NodeAssignmentWhereInput[]
    OR?: NodeAssignmentWhereInput[]
    NOT?: NodeAssignmentWhereInput | NodeAssignmentWhereInput[]
    id?: StringFilter<"NodeAssignment"> | string
    nodeId?: StringFilter<"NodeAssignment"> | string
    userId?: StringFilter<"NodeAssignment"> | string
    role?: EnumNodeAssignmentRoleFilter<"NodeAssignment"> | $Enums.NodeAssignmentRole
    createdAt?: DateTimeFilter<"NodeAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"NodeAssignment"> | Date | string
    node?: XOR<NodeScalarRelationFilter, NodeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NodeAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    nodeId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    node?: NodeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type NodeAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    node_user_role_unique?: NodeAssignmentNode_user_role_uniqueCompoundUniqueInput
    AND?: NodeAssignmentWhereInput | NodeAssignmentWhereInput[]
    OR?: NodeAssignmentWhereInput[]
    NOT?: NodeAssignmentWhereInput | NodeAssignmentWhereInput[]
    nodeId?: StringFilter<"NodeAssignment"> | string
    userId?: StringFilter<"NodeAssignment"> | string
    role?: EnumNodeAssignmentRoleFilter<"NodeAssignment"> | $Enums.NodeAssignmentRole
    createdAt?: DateTimeFilter<"NodeAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"NodeAssignment"> | Date | string
    node?: XOR<NodeScalarRelationFilter, NodeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "node_user_role_unique">

  export type NodeAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    nodeId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NodeAssignmentCountOrderByAggregateInput
    _max?: NodeAssignmentMaxOrderByAggregateInput
    _min?: NodeAssignmentMinOrderByAggregateInput
  }

  export type NodeAssignmentScalarWhereWithAggregatesInput = {
    AND?: NodeAssignmentScalarWhereWithAggregatesInput | NodeAssignmentScalarWhereWithAggregatesInput[]
    OR?: NodeAssignmentScalarWhereWithAggregatesInput[]
    NOT?: NodeAssignmentScalarWhereWithAggregatesInput | NodeAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NodeAssignment"> | string
    nodeId?: StringWithAggregatesFilter<"NodeAssignment"> | string
    userId?: StringWithAggregatesFilter<"NodeAssignment"> | string
    role?: EnumNodeAssignmentRoleWithAggregatesFilter<"NodeAssignment"> | $Enums.NodeAssignmentRole
    createdAt?: DateTimeWithAggregatesFilter<"NodeAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NodeAssignment"> | Date | string
  }

  export type NodeDependencyWhereInput = {
    AND?: NodeDependencyWhereInput | NodeDependencyWhereInput[]
    OR?: NodeDependencyWhereInput[]
    NOT?: NodeDependencyWhereInput | NodeDependencyWhereInput[]
    id?: StringFilter<"NodeDependency"> | string
    blockedNodeId?: StringFilter<"NodeDependency"> | string
    dependsOnNodeId?: StringFilter<"NodeDependency"> | string
    createdAt?: DateTimeFilter<"NodeDependency"> | Date | string
    blockedNode?: XOR<NodeScalarRelationFilter, NodeWhereInput>
    dependsOnNode?: XOR<NodeScalarRelationFilter, NodeWhereInput>
  }

  export type NodeDependencyOrderByWithRelationInput = {
    id?: SortOrder
    blockedNodeId?: SortOrder
    dependsOnNodeId?: SortOrder
    createdAt?: SortOrder
    blockedNode?: NodeOrderByWithRelationInput
    dependsOnNode?: NodeOrderByWithRelationInput
  }

  export type NodeDependencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    node_dep_unique?: NodeDependencyNode_dep_uniqueCompoundUniqueInput
    AND?: NodeDependencyWhereInput | NodeDependencyWhereInput[]
    OR?: NodeDependencyWhereInput[]
    NOT?: NodeDependencyWhereInput | NodeDependencyWhereInput[]
    blockedNodeId?: StringFilter<"NodeDependency"> | string
    dependsOnNodeId?: StringFilter<"NodeDependency"> | string
    createdAt?: DateTimeFilter<"NodeDependency"> | Date | string
    blockedNode?: XOR<NodeScalarRelationFilter, NodeWhereInput>
    dependsOnNode?: XOR<NodeScalarRelationFilter, NodeWhereInput>
  }, "id" | "node_dep_unique">

  export type NodeDependencyOrderByWithAggregationInput = {
    id?: SortOrder
    blockedNodeId?: SortOrder
    dependsOnNodeId?: SortOrder
    createdAt?: SortOrder
    _count?: NodeDependencyCountOrderByAggregateInput
    _max?: NodeDependencyMaxOrderByAggregateInput
    _min?: NodeDependencyMinOrderByAggregateInput
  }

  export type NodeDependencyScalarWhereWithAggregatesInput = {
    AND?: NodeDependencyScalarWhereWithAggregatesInput | NodeDependencyScalarWhereWithAggregatesInput[]
    OR?: NodeDependencyScalarWhereWithAggregatesInput[]
    NOT?: NodeDependencyScalarWhereWithAggregatesInput | NodeDependencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NodeDependency"> | string
    blockedNodeId?: StringWithAggregatesFilter<"NodeDependency"> | string
    dependsOnNodeId?: StringWithAggregatesFilter<"NodeDependency"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NodeDependency"> | Date | string
  }

  export type KpiDefinitionWhereInput = {
    AND?: KpiDefinitionWhereInput | KpiDefinitionWhereInput[]
    OR?: KpiDefinitionWhereInput[]
    NOT?: KpiDefinitionWhereInput | KpiDefinitionWhereInput[]
    id?: StringFilter<"KpiDefinition"> | string
    orgId?: StringFilter<"KpiDefinition"> | string
    primaryNodeId?: StringFilter<"KpiDefinition"> | string
    ownerUserId?: StringNullableFilter<"KpiDefinition"> | string | null
    name?: StringFilter<"KpiDefinition"> | string
    description?: StringNullableFilter<"KpiDefinition"> | string | null
    formula?: StringNullableFilter<"KpiDefinition"> | string | null
    unit?: StringNullableFilter<"KpiDefinition"> | string | null
    direction?: EnumKpiDirectionFilter<"KpiDefinition"> | $Enums.KpiDirection
    aggregation?: EnumKpiAggregationMethodFilter<"KpiDefinition"> | $Enums.KpiAggregationMethod
    periodType?: EnumKpiPeriodTypeFilter<"KpiDefinition"> | $Enums.KpiPeriodType
    baselineValue?: FloatNullableFilter<"KpiDefinition"> | number | null
    targetValue?: FloatNullableFilter<"KpiDefinition"> | number | null
    weight?: FloatNullableFilter<"KpiDefinition"> | number | null
    status?: EnumKpiDefinitionStatusFilter<"KpiDefinition"> | $Enums.KpiDefinitionStatus
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    primaryNode?: XOR<NodeScalarRelationFilter, NodeWhereInput>
    ownerUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    variables?: KpiVariableListRelationFilter
    values?: KpiValuePeriodListRelationFilter
  }

  export type KpiDefinitionOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    primaryNodeId?: SortOrder
    ownerUserId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    formula?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    direction?: SortOrder
    aggregation?: SortOrder
    periodType?: SortOrder
    baselineValue?: SortOrderInput | SortOrder
    targetValue?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    status?: SortOrder
    org?: OrganizationOrderByWithRelationInput
    primaryNode?: NodeOrderByWithRelationInput
    ownerUser?: UserOrderByWithRelationInput
    variables?: KpiVariableOrderByRelationAggregateInput
    values?: KpiValuePeriodOrderByRelationAggregateInput
  }

  export type KpiDefinitionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KpiDefinitionWhereInput | KpiDefinitionWhereInput[]
    OR?: KpiDefinitionWhereInput[]
    NOT?: KpiDefinitionWhereInput | KpiDefinitionWhereInput[]
    orgId?: StringFilter<"KpiDefinition"> | string
    primaryNodeId?: StringFilter<"KpiDefinition"> | string
    ownerUserId?: StringNullableFilter<"KpiDefinition"> | string | null
    name?: StringFilter<"KpiDefinition"> | string
    description?: StringNullableFilter<"KpiDefinition"> | string | null
    formula?: StringNullableFilter<"KpiDefinition"> | string | null
    unit?: StringNullableFilter<"KpiDefinition"> | string | null
    direction?: EnumKpiDirectionFilter<"KpiDefinition"> | $Enums.KpiDirection
    aggregation?: EnumKpiAggregationMethodFilter<"KpiDefinition"> | $Enums.KpiAggregationMethod
    periodType?: EnumKpiPeriodTypeFilter<"KpiDefinition"> | $Enums.KpiPeriodType
    baselineValue?: FloatNullableFilter<"KpiDefinition"> | number | null
    targetValue?: FloatNullableFilter<"KpiDefinition"> | number | null
    weight?: FloatNullableFilter<"KpiDefinition"> | number | null
    status?: EnumKpiDefinitionStatusFilter<"KpiDefinition"> | $Enums.KpiDefinitionStatus
    org?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    primaryNode?: XOR<NodeScalarRelationFilter, NodeWhereInput>
    ownerUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    variables?: KpiVariableListRelationFilter
    values?: KpiValuePeriodListRelationFilter
  }, "id">

  export type KpiDefinitionOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    primaryNodeId?: SortOrder
    ownerUserId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    formula?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    direction?: SortOrder
    aggregation?: SortOrder
    periodType?: SortOrder
    baselineValue?: SortOrderInput | SortOrder
    targetValue?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: KpiDefinitionCountOrderByAggregateInput
    _avg?: KpiDefinitionAvgOrderByAggregateInput
    _max?: KpiDefinitionMaxOrderByAggregateInput
    _min?: KpiDefinitionMinOrderByAggregateInput
    _sum?: KpiDefinitionSumOrderByAggregateInput
  }

  export type KpiDefinitionScalarWhereWithAggregatesInput = {
    AND?: KpiDefinitionScalarWhereWithAggregatesInput | KpiDefinitionScalarWhereWithAggregatesInput[]
    OR?: KpiDefinitionScalarWhereWithAggregatesInput[]
    NOT?: KpiDefinitionScalarWhereWithAggregatesInput | KpiDefinitionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KpiDefinition"> | string
    orgId?: StringWithAggregatesFilter<"KpiDefinition"> | string
    primaryNodeId?: StringWithAggregatesFilter<"KpiDefinition"> | string
    ownerUserId?: StringNullableWithAggregatesFilter<"KpiDefinition"> | string | null
    name?: StringWithAggregatesFilter<"KpiDefinition"> | string
    description?: StringNullableWithAggregatesFilter<"KpiDefinition"> | string | null
    formula?: StringNullableWithAggregatesFilter<"KpiDefinition"> | string | null
    unit?: StringNullableWithAggregatesFilter<"KpiDefinition"> | string | null
    direction?: EnumKpiDirectionWithAggregatesFilter<"KpiDefinition"> | $Enums.KpiDirection
    aggregation?: EnumKpiAggregationMethodWithAggregatesFilter<"KpiDefinition"> | $Enums.KpiAggregationMethod
    periodType?: EnumKpiPeriodTypeWithAggregatesFilter<"KpiDefinition"> | $Enums.KpiPeriodType
    baselineValue?: FloatNullableWithAggregatesFilter<"KpiDefinition"> | number | null
    targetValue?: FloatNullableWithAggregatesFilter<"KpiDefinition"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"KpiDefinition"> | number | null
    status?: EnumKpiDefinitionStatusWithAggregatesFilter<"KpiDefinition"> | $Enums.KpiDefinitionStatus
  }

  export type KpiVariableWhereInput = {
    AND?: KpiVariableWhereInput | KpiVariableWhereInput[]
    OR?: KpiVariableWhereInput[]
    NOT?: KpiVariableWhereInput | KpiVariableWhereInput[]
    id?: StringFilter<"KpiVariable"> | string
    kpiId?: StringFilter<"KpiVariable"> | string
    code?: StringFilter<"KpiVariable"> | string
    displayName?: StringFilter<"KpiVariable"> | string
    dataType?: EnumKpiVariableDataTypeFilter<"KpiVariable"> | $Enums.KpiVariableDataType
    isRequired?: BoolFilter<"KpiVariable"> | boolean
    kpi?: XOR<KpiDefinitionScalarRelationFilter, KpiDefinitionWhereInput>
    values?: KpiVariableValueListRelationFilter
  }

  export type KpiVariableOrderByWithRelationInput = {
    id?: SortOrder
    kpiId?: SortOrder
    code?: SortOrder
    displayName?: SortOrder
    dataType?: SortOrder
    isRequired?: SortOrder
    kpi?: KpiDefinitionOrderByWithRelationInput
    values?: KpiVariableValueOrderByRelationAggregateInput
  }

  export type KpiVariableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    kpiId_code?: KpiVariableKpiIdCodeCompoundUniqueInput
    AND?: KpiVariableWhereInput | KpiVariableWhereInput[]
    OR?: KpiVariableWhereInput[]
    NOT?: KpiVariableWhereInput | KpiVariableWhereInput[]
    kpiId?: StringFilter<"KpiVariable"> | string
    code?: StringFilter<"KpiVariable"> | string
    displayName?: StringFilter<"KpiVariable"> | string
    dataType?: EnumKpiVariableDataTypeFilter<"KpiVariable"> | $Enums.KpiVariableDataType
    isRequired?: BoolFilter<"KpiVariable"> | boolean
    kpi?: XOR<KpiDefinitionScalarRelationFilter, KpiDefinitionWhereInput>
    values?: KpiVariableValueListRelationFilter
  }, "id" | "kpiId_code">

  export type KpiVariableOrderByWithAggregationInput = {
    id?: SortOrder
    kpiId?: SortOrder
    code?: SortOrder
    displayName?: SortOrder
    dataType?: SortOrder
    isRequired?: SortOrder
    _count?: KpiVariableCountOrderByAggregateInput
    _max?: KpiVariableMaxOrderByAggregateInput
    _min?: KpiVariableMinOrderByAggregateInput
  }

  export type KpiVariableScalarWhereWithAggregatesInput = {
    AND?: KpiVariableScalarWhereWithAggregatesInput | KpiVariableScalarWhereWithAggregatesInput[]
    OR?: KpiVariableScalarWhereWithAggregatesInput[]
    NOT?: KpiVariableScalarWhereWithAggregatesInput | KpiVariableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KpiVariable"> | string
    kpiId?: StringWithAggregatesFilter<"KpiVariable"> | string
    code?: StringWithAggregatesFilter<"KpiVariable"> | string
    displayName?: StringWithAggregatesFilter<"KpiVariable"> | string
    dataType?: EnumKpiVariableDataTypeWithAggregatesFilter<"KpiVariable"> | $Enums.KpiVariableDataType
    isRequired?: BoolWithAggregatesFilter<"KpiVariable"> | boolean
  }

  export type KpiValuePeriodWhereInput = {
    AND?: KpiValuePeriodWhereInput | KpiValuePeriodWhereInput[]
    OR?: KpiValuePeriodWhereInput[]
    NOT?: KpiValuePeriodWhereInput | KpiValuePeriodWhereInput[]
    id?: StringFilter<"KpiValuePeriod"> | string
    kpiId?: StringFilter<"KpiValuePeriod"> | string
    periodStart?: DateTimeFilter<"KpiValuePeriod"> | Date | string
    periodEnd?: DateTimeFilter<"KpiValuePeriod"> | Date | string
    calculatedValue?: FloatNullableFilter<"KpiValuePeriod"> | number | null
    status?: EnumKpiValueStatusFilter<"KpiValuePeriod"> | $Enums.KpiValueStatus
    note?: StringNullableFilter<"KpiValuePeriod"> | string | null
    enteredBy?: StringNullableFilter<"KpiValuePeriod"> | string | null
    approvedBy?: StringNullableFilter<"KpiValuePeriod"> | string | null
    submittedAt?: DateTimeNullableFilter<"KpiValuePeriod"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"KpiValuePeriod"> | Date | string | null
    lockedAt?: DateTimeNullableFilter<"KpiValuePeriod"> | Date | string | null
    createdAt?: DateTimeFilter<"KpiValuePeriod"> | Date | string
    updatedAt?: DateTimeFilter<"KpiValuePeriod"> | Date | string
    kpi?: XOR<KpiDefinitionScalarRelationFilter, KpiDefinitionWhereInput>
    enteredByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    approvedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    variableValues?: KpiVariableValueListRelationFilter
  }

  export type KpiValuePeriodOrderByWithRelationInput = {
    id?: SortOrder
    kpiId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    calculatedValue?: SortOrderInput | SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    enteredBy?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kpi?: KpiDefinitionOrderByWithRelationInput
    enteredByUser?: UserOrderByWithRelationInput
    approvedByUser?: UserOrderByWithRelationInput
    variableValues?: KpiVariableValueOrderByRelationAggregateInput
  }

  export type KpiValuePeriodWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    kpiId_periodStart_periodEnd?: KpiValuePeriodKpiIdPeriodStartPeriodEndCompoundUniqueInput
    AND?: KpiValuePeriodWhereInput | KpiValuePeriodWhereInput[]
    OR?: KpiValuePeriodWhereInput[]
    NOT?: KpiValuePeriodWhereInput | KpiValuePeriodWhereInput[]
    kpiId?: StringFilter<"KpiValuePeriod"> | string
    periodStart?: DateTimeFilter<"KpiValuePeriod"> | Date | string
    periodEnd?: DateTimeFilter<"KpiValuePeriod"> | Date | string
    calculatedValue?: FloatNullableFilter<"KpiValuePeriod"> | number | null
    status?: EnumKpiValueStatusFilter<"KpiValuePeriod"> | $Enums.KpiValueStatus
    note?: StringNullableFilter<"KpiValuePeriod"> | string | null
    enteredBy?: StringNullableFilter<"KpiValuePeriod"> | string | null
    approvedBy?: StringNullableFilter<"KpiValuePeriod"> | string | null
    submittedAt?: DateTimeNullableFilter<"KpiValuePeriod"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"KpiValuePeriod"> | Date | string | null
    lockedAt?: DateTimeNullableFilter<"KpiValuePeriod"> | Date | string | null
    createdAt?: DateTimeFilter<"KpiValuePeriod"> | Date | string
    updatedAt?: DateTimeFilter<"KpiValuePeriod"> | Date | string
    kpi?: XOR<KpiDefinitionScalarRelationFilter, KpiDefinitionWhereInput>
    enteredByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    approvedByUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    variableValues?: KpiVariableValueListRelationFilter
  }, "id" | "kpiId_periodStart_periodEnd">

  export type KpiValuePeriodOrderByWithAggregationInput = {
    id?: SortOrder
    kpiId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    calculatedValue?: SortOrderInput | SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    enteredBy?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KpiValuePeriodCountOrderByAggregateInput
    _avg?: KpiValuePeriodAvgOrderByAggregateInput
    _max?: KpiValuePeriodMaxOrderByAggregateInput
    _min?: KpiValuePeriodMinOrderByAggregateInput
    _sum?: KpiValuePeriodSumOrderByAggregateInput
  }

  export type KpiValuePeriodScalarWhereWithAggregatesInput = {
    AND?: KpiValuePeriodScalarWhereWithAggregatesInput | KpiValuePeriodScalarWhereWithAggregatesInput[]
    OR?: KpiValuePeriodScalarWhereWithAggregatesInput[]
    NOT?: KpiValuePeriodScalarWhereWithAggregatesInput | KpiValuePeriodScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KpiValuePeriod"> | string
    kpiId?: StringWithAggregatesFilter<"KpiValuePeriod"> | string
    periodStart?: DateTimeWithAggregatesFilter<"KpiValuePeriod"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"KpiValuePeriod"> | Date | string
    calculatedValue?: FloatNullableWithAggregatesFilter<"KpiValuePeriod"> | number | null
    status?: EnumKpiValueStatusWithAggregatesFilter<"KpiValuePeriod"> | $Enums.KpiValueStatus
    note?: StringNullableWithAggregatesFilter<"KpiValuePeriod"> | string | null
    enteredBy?: StringNullableWithAggregatesFilter<"KpiValuePeriod"> | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"KpiValuePeriod"> | string | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"KpiValuePeriod"> | Date | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"KpiValuePeriod"> | Date | string | null
    lockedAt?: DateTimeNullableWithAggregatesFilter<"KpiValuePeriod"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"KpiValuePeriod"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KpiValuePeriod"> | Date | string
  }

  export type KpiVariableValueWhereInput = {
    AND?: KpiVariableValueWhereInput | KpiVariableValueWhereInput[]
    OR?: KpiVariableValueWhereInput[]
    NOT?: KpiVariableValueWhereInput | KpiVariableValueWhereInput[]
    id?: StringFilter<"KpiVariableValue"> | string
    kpiValueId?: StringFilter<"KpiVariableValue"> | string
    kpiVariableId?: StringFilter<"KpiVariableValue"> | string
    value?: FloatFilter<"KpiVariableValue"> | number
    kpiValue?: XOR<KpiValuePeriodScalarRelationFilter, KpiValuePeriodWhereInput>
    kpiVariable?: XOR<KpiVariableScalarRelationFilter, KpiVariableWhereInput>
  }

  export type KpiVariableValueOrderByWithRelationInput = {
    id?: SortOrder
    kpiValueId?: SortOrder
    kpiVariableId?: SortOrder
    value?: SortOrder
    kpiValue?: KpiValuePeriodOrderByWithRelationInput
    kpiVariable?: KpiVariableOrderByWithRelationInput
  }

  export type KpiVariableValueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    kpiValueId_kpiVariableId?: KpiVariableValueKpiValueIdKpiVariableIdCompoundUniqueInput
    AND?: KpiVariableValueWhereInput | KpiVariableValueWhereInput[]
    OR?: KpiVariableValueWhereInput[]
    NOT?: KpiVariableValueWhereInput | KpiVariableValueWhereInput[]
    kpiValueId?: StringFilter<"KpiVariableValue"> | string
    kpiVariableId?: StringFilter<"KpiVariableValue"> | string
    value?: FloatFilter<"KpiVariableValue"> | number
    kpiValue?: XOR<KpiValuePeriodScalarRelationFilter, KpiValuePeriodWhereInput>
    kpiVariable?: XOR<KpiVariableScalarRelationFilter, KpiVariableWhereInput>
  }, "id" | "kpiValueId_kpiVariableId">

  export type KpiVariableValueOrderByWithAggregationInput = {
    id?: SortOrder
    kpiValueId?: SortOrder
    kpiVariableId?: SortOrder
    value?: SortOrder
    _count?: KpiVariableValueCountOrderByAggregateInput
    _avg?: KpiVariableValueAvgOrderByAggregateInput
    _max?: KpiVariableValueMaxOrderByAggregateInput
    _min?: KpiVariableValueMinOrderByAggregateInput
    _sum?: KpiVariableValueSumOrderByAggregateInput
  }

  export type KpiVariableValueScalarWhereWithAggregatesInput = {
    AND?: KpiVariableValueScalarWhereWithAggregatesInput | KpiVariableValueScalarWhereWithAggregatesInput[]
    OR?: KpiVariableValueScalarWhereWithAggregatesInput[]
    NOT?: KpiVariableValueScalarWhereWithAggregatesInput | KpiVariableValueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KpiVariableValue"> | string
    kpiValueId?: StringWithAggregatesFilter<"KpiVariableValue"> | string
    kpiVariableId?: StringWithAggregatesFilter<"KpiVariableValue"> | string
    value?: FloatWithAggregatesFilter<"KpiVariableValue"> | number
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserCreateNestedManyWithoutOrgInput
    departments?: DepartmentCreateNestedManyWithoutOrgInput
    nodes?: NodeCreateNestedManyWithoutOrgInput
    kpis?: KpiDefinitionCreateNestedManyWithoutOrgInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutOrgInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutOrgInput
    nodes?: NodeUncheckedCreateNestedManyWithoutOrgInput
    kpis?: KpiDefinitionUncheckedCreateNestedManyWithoutOrgInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutOrgNestedInput
    departments?: DepartmentUpdateManyWithoutOrgNestedInput
    nodes?: NodeUpdateManyWithoutOrgNestedInput
    kpis?: KpiDefinitionUpdateManyWithoutOrgNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutOrgNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutOrgNestedInput
    nodes?: NodeUncheckedUpdateManyWithoutOrgNestedInput
    kpis?: KpiDefinitionUncheckedUpdateManyWithoutOrgNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutDepartmentsInput
    parent?: DepartmentCreateNestedOneWithoutChildrenInput
    children?: DepartmentCreateNestedManyWithoutParentInput
    manager?: UserCreateNestedOneWithoutManagedDepartmentsInput
    users?: UserCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    orgId: string
    name: string
    code?: string | null
    parentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: DepartmentUncheckedCreateNestedManyWithoutParentInput
    users?: UserUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput
    parent?: DepartmentUpdateOneWithoutChildrenNestedInput
    children?: DepartmentUpdateManyWithoutParentNestedInput
    manager?: UserUpdateOneWithoutManagedDepartmentsNestedInput
    users?: UserUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: DepartmentUncheckedUpdateManyWithoutParentNestedInput
    users?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    orgId: string
    name: string
    code?: string | null
    parentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutDirectReportsInput
    directReports?: UserCreateNestedManyWithoutManagerInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionCreateNestedManyWithoutOwnerUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    orgId: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    managerId?: string | null
    departmentId?: string | null
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    directReports?: UserUncheckedCreateNestedManyWithoutManagerInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalUncheckedCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeUncheckedCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentUncheckedCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodUncheckedCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodUncheckedCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionUncheckedCreateNestedManyWithoutOwnerUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutDirectReportsNestedInput
    directReports?: UserUpdateManyWithoutManagerNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directReports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUncheckedUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUncheckedUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUncheckedUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUncheckedUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUncheckedUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUncheckedUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    orgId: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    managerId?: string | null
    departmentId?: string | null
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccountCreateInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id?: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUncheckedCreateInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateManyInput = {
    id?: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferenceCreateInput = {
    id?: string
    locale?: string
    theme?: string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPreferencesInput
  }

  export type UserPreferenceUncheckedCreateInput = {
    id?: string
    userId: string
    locale?: string
    theme?: string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPreferencesNestedInput
  }

  export type UserPreferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferenceCreateManyInput = {
    id?: string
    userId: string
    locale?: string
    theme?: string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeRequestCreateInput = {
    id?: string
    entityType: string
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    decidedAt?: Date | string | null
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutChangeRequestsInput
    requester: UserCreateNestedOneWithoutChangeRequestsInput
    approvals?: ChangeApprovalCreateNestedManyWithoutChangeRequestInput
  }

  export type ChangeRequestUncheckedCreateInput = {
    id?: string
    orgId: string
    entityType: string
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.ApprovalStatus
    requestedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    decidedAt?: Date | string | null
    deletedAt?: Date | string | null
    approvals?: ChangeApprovalUncheckedCreateNestedManyWithoutChangeRequestInput
  }

  export type ChangeRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutChangeRequestsNestedInput
    requester?: UserUpdateOneRequiredWithoutChangeRequestsNestedInput
    approvals?: ChangeApprovalUpdateManyWithoutChangeRequestNestedInput
  }

  export type ChangeRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    requestedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvals?: ChangeApprovalUncheckedUpdateManyWithoutChangeRequestNestedInput
  }

  export type ChangeRequestCreateManyInput = {
    id?: string
    orgId: string
    entityType: string
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.ApprovalStatus
    requestedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    decidedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ChangeRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChangeRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    requestedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChangeApprovalCreateInput = {
    id?: string
    status?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    decidedAt?: Date | string | null
    changeRequest: ChangeRequestCreateNestedOneWithoutApprovalsInput
    approver: UserCreateNestedOneWithoutApprovalsInput
  }

  export type ChangeApprovalUncheckedCreateInput = {
    id?: string
    changeRequestId: string
    approverId: string
    status?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    decidedAt?: Date | string | null
  }

  export type ChangeApprovalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changeRequest?: ChangeRequestUpdateOneRequiredWithoutApprovalsNestedInput
    approver?: UserUpdateOneRequiredWithoutApprovalsNestedInput
  }

  export type ChangeApprovalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeRequestId?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChangeApprovalCreateManyInput = {
    id?: string
    changeRequestId: string
    approverId: string
    status?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    decidedAt?: Date | string | null
  }

  export type ChangeApprovalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChangeApprovalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeRequestId?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NodeTypeCreateInput = {
    id?: string
    code: $Enums.NodeTypeCode
    displayName: string
    levelOrder: number
    canHaveKpis?: boolean
    nodes?: NodeCreateNestedManyWithoutNodeTypeInput
  }

  export type NodeTypeUncheckedCreateInput = {
    id?: string
    code: $Enums.NodeTypeCode
    displayName: string
    levelOrder: number
    canHaveKpis?: boolean
    nodes?: NodeUncheckedCreateNestedManyWithoutNodeTypeInput
  }

  export type NodeTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: EnumNodeTypeCodeFieldUpdateOperationsInput | $Enums.NodeTypeCode
    displayName?: StringFieldUpdateOperationsInput | string
    levelOrder?: IntFieldUpdateOperationsInput | number
    canHaveKpis?: BoolFieldUpdateOperationsInput | boolean
    nodes?: NodeUpdateManyWithoutNodeTypeNestedInput
  }

  export type NodeTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: EnumNodeTypeCodeFieldUpdateOperationsInput | $Enums.NodeTypeCode
    displayName?: StringFieldUpdateOperationsInput | string
    levelOrder?: IntFieldUpdateOperationsInput | number
    canHaveKpis?: BoolFieldUpdateOperationsInput | boolean
    nodes?: NodeUncheckedUpdateManyWithoutNodeTypeNestedInput
  }

  export type NodeTypeCreateManyInput = {
    id?: string
    code: $Enums.NodeTypeCode
    displayName: string
    levelOrder: number
    canHaveKpis?: boolean
  }

  export type NodeTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: EnumNodeTypeCodeFieldUpdateOperationsInput | $Enums.NodeTypeCode
    displayName?: StringFieldUpdateOperationsInput | string
    levelOrder?: IntFieldUpdateOperationsInput | number
    canHaveKpis?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NodeTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: EnumNodeTypeCodeFieldUpdateOperationsInput | $Enums.NodeTypeCode
    displayName?: StringFieldUpdateOperationsInput | string
    levelOrder?: IntFieldUpdateOperationsInput | number
    canHaveKpis?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NodeCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutNodesInput
    nodeType: NodeTypeCreateNestedOneWithoutNodesInput
    parent?: NodeCreateNestedOneWithoutChildrenInput
    children?: NodeCreateNestedManyWithoutParentInput
    ownerUser?: UserCreateNestedOneWithoutOwnedNodesInput
    assignments?: NodeAssignmentCreateNestedManyWithoutNodeInput
    outgoingDeps?: NodeDependencyCreateNestedManyWithoutDependsOnNodeInput
    incomingDeps?: NodeDependencyCreateNestedManyWithoutBlockedNodeInput
    kpis?: KpiDefinitionCreateNestedManyWithoutPrimaryNodeInput
  }

  export type NodeUncheckedCreateInput = {
    id?: string
    orgId: string
    nodeTypeId: string
    parentId?: string | null
    name: string
    description?: string | null
    ownerUserId?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: NodeUncheckedCreateNestedManyWithoutParentInput
    assignments?: NodeAssignmentUncheckedCreateNestedManyWithoutNodeInput
    outgoingDeps?: NodeDependencyUncheckedCreateNestedManyWithoutDependsOnNodeInput
    incomingDeps?: NodeDependencyUncheckedCreateNestedManyWithoutBlockedNodeInput
    kpis?: KpiDefinitionUncheckedCreateNestedManyWithoutPrimaryNodeInput
  }

  export type NodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutNodesNestedInput
    nodeType?: NodeTypeUpdateOneRequiredWithoutNodesNestedInput
    parent?: NodeUpdateOneWithoutChildrenNestedInput
    children?: NodeUpdateManyWithoutParentNestedInput
    ownerUser?: UserUpdateOneWithoutOwnedNodesNestedInput
    assignments?: NodeAssignmentUpdateManyWithoutNodeNestedInput
    outgoingDeps?: NodeDependencyUpdateManyWithoutDependsOnNodeNestedInput
    incomingDeps?: NodeDependencyUpdateManyWithoutBlockedNodeNestedInput
    kpis?: KpiDefinitionUpdateManyWithoutPrimaryNodeNestedInput
  }

  export type NodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    nodeTypeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: NodeUncheckedUpdateManyWithoutParentNestedInput
    assignments?: NodeAssignmentUncheckedUpdateManyWithoutNodeNestedInput
    outgoingDeps?: NodeDependencyUncheckedUpdateManyWithoutDependsOnNodeNestedInput
    incomingDeps?: NodeDependencyUncheckedUpdateManyWithoutBlockedNodeNestedInput
    kpis?: KpiDefinitionUncheckedUpdateManyWithoutPrimaryNodeNestedInput
  }

  export type NodeCreateManyInput = {
    id?: string
    orgId: string
    nodeTypeId: string
    parentId?: string | null
    name: string
    description?: string | null
    ownerUserId?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type NodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    nodeTypeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NodeAssignmentCreateInput = {
    id?: string
    role?: $Enums.NodeAssignmentRole
    createdAt?: Date | string
    updatedAt?: Date | string
    node: NodeCreateNestedOneWithoutAssignmentsInput
    user: UserCreateNestedOneWithoutNodeAssignmentsInput
  }

  export type NodeAssignmentUncheckedCreateInput = {
    id?: string
    nodeId: string
    userId: string
    role?: $Enums.NodeAssignmentRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NodeAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumNodeAssignmentRoleFieldUpdateOperationsInput | $Enums.NodeAssignmentRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: NodeUpdateOneRequiredWithoutAssignmentsNestedInput
    user?: UserUpdateOneRequiredWithoutNodeAssignmentsNestedInput
  }

  export type NodeAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumNodeAssignmentRoleFieldUpdateOperationsInput | $Enums.NodeAssignmentRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NodeAssignmentCreateManyInput = {
    id?: string
    nodeId: string
    userId: string
    role?: $Enums.NodeAssignmentRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NodeAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumNodeAssignmentRoleFieldUpdateOperationsInput | $Enums.NodeAssignmentRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NodeAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumNodeAssignmentRoleFieldUpdateOperationsInput | $Enums.NodeAssignmentRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NodeDependencyCreateInput = {
    id?: string
    createdAt?: Date | string
    blockedNode: NodeCreateNestedOneWithoutIncomingDepsInput
    dependsOnNode: NodeCreateNestedOneWithoutOutgoingDepsInput
  }

  export type NodeDependencyUncheckedCreateInput = {
    id?: string
    blockedNodeId: string
    dependsOnNodeId: string
    createdAt?: Date | string
  }

  export type NodeDependencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedNode?: NodeUpdateOneRequiredWithoutIncomingDepsNestedInput
    dependsOnNode?: NodeUpdateOneRequiredWithoutOutgoingDepsNestedInput
  }

  export type NodeDependencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockedNodeId?: StringFieldUpdateOperationsInput | string
    dependsOnNodeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NodeDependencyCreateManyInput = {
    id?: string
    blockedNodeId: string
    dependsOnNodeId: string
    createdAt?: Date | string
  }

  export type NodeDependencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NodeDependencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockedNodeId?: StringFieldUpdateOperationsInput | string
    dependsOnNodeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KpiDefinitionCreateInput = {
    id?: string
    name: string
    description?: string | null
    formula?: string | null
    unit?: string | null
    direction?: $Enums.KpiDirection
    aggregation?: $Enums.KpiAggregationMethod
    periodType: $Enums.KpiPeriodType
    baselineValue?: number | null
    targetValue?: number | null
    weight?: number | null
    status?: $Enums.KpiDefinitionStatus
    org: OrganizationCreateNestedOneWithoutKpisInput
    primaryNode: NodeCreateNestedOneWithoutKpisInput
    ownerUser?: UserCreateNestedOneWithoutOwnedKpisInput
    variables?: KpiVariableCreateNestedManyWithoutKpiInput
    values?: KpiValuePeriodCreateNestedManyWithoutKpiInput
  }

  export type KpiDefinitionUncheckedCreateInput = {
    id?: string
    orgId: string
    primaryNodeId: string
    ownerUserId?: string | null
    name: string
    description?: string | null
    formula?: string | null
    unit?: string | null
    direction?: $Enums.KpiDirection
    aggregation?: $Enums.KpiAggregationMethod
    periodType: $Enums.KpiPeriodType
    baselineValue?: number | null
    targetValue?: number | null
    weight?: number | null
    status?: $Enums.KpiDefinitionStatus
    variables?: KpiVariableUncheckedCreateNestedManyWithoutKpiInput
    values?: KpiValuePeriodUncheckedCreateNestedManyWithoutKpiInput
  }

  export type KpiDefinitionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumKpiDirectionFieldUpdateOperationsInput | $Enums.KpiDirection
    aggregation?: EnumKpiAggregationMethodFieldUpdateOperationsInput | $Enums.KpiAggregationMethod
    periodType?: EnumKpiPeriodTypeFieldUpdateOperationsInput | $Enums.KpiPeriodType
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiDefinitionStatusFieldUpdateOperationsInput | $Enums.KpiDefinitionStatus
    org?: OrganizationUpdateOneRequiredWithoutKpisNestedInput
    primaryNode?: NodeUpdateOneRequiredWithoutKpisNestedInput
    ownerUser?: UserUpdateOneWithoutOwnedKpisNestedInput
    variables?: KpiVariableUpdateManyWithoutKpiNestedInput
    values?: KpiValuePeriodUpdateManyWithoutKpiNestedInput
  }

  export type KpiDefinitionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    primaryNodeId?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumKpiDirectionFieldUpdateOperationsInput | $Enums.KpiDirection
    aggregation?: EnumKpiAggregationMethodFieldUpdateOperationsInput | $Enums.KpiAggregationMethod
    periodType?: EnumKpiPeriodTypeFieldUpdateOperationsInput | $Enums.KpiPeriodType
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiDefinitionStatusFieldUpdateOperationsInput | $Enums.KpiDefinitionStatus
    variables?: KpiVariableUncheckedUpdateManyWithoutKpiNestedInput
    values?: KpiValuePeriodUncheckedUpdateManyWithoutKpiNestedInput
  }

  export type KpiDefinitionCreateManyInput = {
    id?: string
    orgId: string
    primaryNodeId: string
    ownerUserId?: string | null
    name: string
    description?: string | null
    formula?: string | null
    unit?: string | null
    direction?: $Enums.KpiDirection
    aggregation?: $Enums.KpiAggregationMethod
    periodType: $Enums.KpiPeriodType
    baselineValue?: number | null
    targetValue?: number | null
    weight?: number | null
    status?: $Enums.KpiDefinitionStatus
  }

  export type KpiDefinitionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumKpiDirectionFieldUpdateOperationsInput | $Enums.KpiDirection
    aggregation?: EnumKpiAggregationMethodFieldUpdateOperationsInput | $Enums.KpiAggregationMethod
    periodType?: EnumKpiPeriodTypeFieldUpdateOperationsInput | $Enums.KpiPeriodType
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiDefinitionStatusFieldUpdateOperationsInput | $Enums.KpiDefinitionStatus
  }

  export type KpiDefinitionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    primaryNodeId?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumKpiDirectionFieldUpdateOperationsInput | $Enums.KpiDirection
    aggregation?: EnumKpiAggregationMethodFieldUpdateOperationsInput | $Enums.KpiAggregationMethod
    periodType?: EnumKpiPeriodTypeFieldUpdateOperationsInput | $Enums.KpiPeriodType
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiDefinitionStatusFieldUpdateOperationsInput | $Enums.KpiDefinitionStatus
  }

  export type KpiVariableCreateInput = {
    id?: string
    code: string
    displayName: string
    dataType: $Enums.KpiVariableDataType
    isRequired?: boolean
    kpi: KpiDefinitionCreateNestedOneWithoutVariablesInput
    values?: KpiVariableValueCreateNestedManyWithoutKpiVariableInput
  }

  export type KpiVariableUncheckedCreateInput = {
    id?: string
    kpiId: string
    code: string
    displayName: string
    dataType: $Enums.KpiVariableDataType
    isRequired?: boolean
    values?: KpiVariableValueUncheckedCreateNestedManyWithoutKpiVariableInput
  }

  export type KpiVariableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    dataType?: EnumKpiVariableDataTypeFieldUpdateOperationsInput | $Enums.KpiVariableDataType
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    kpi?: KpiDefinitionUpdateOneRequiredWithoutVariablesNestedInput
    values?: KpiVariableValueUpdateManyWithoutKpiVariableNestedInput
  }

  export type KpiVariableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kpiId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    dataType?: EnumKpiVariableDataTypeFieldUpdateOperationsInput | $Enums.KpiVariableDataType
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    values?: KpiVariableValueUncheckedUpdateManyWithoutKpiVariableNestedInput
  }

  export type KpiVariableCreateManyInput = {
    id?: string
    kpiId: string
    code: string
    displayName: string
    dataType: $Enums.KpiVariableDataType
    isRequired?: boolean
  }

  export type KpiVariableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    dataType?: EnumKpiVariableDataTypeFieldUpdateOperationsInput | $Enums.KpiVariableDataType
    isRequired?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KpiVariableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    kpiId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    dataType?: EnumKpiVariableDataTypeFieldUpdateOperationsInput | $Enums.KpiVariableDataType
    isRequired?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KpiValuePeriodCreateInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    calculatedValue?: number | null
    status?: $Enums.KpiValueStatus
    note?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    kpi: KpiDefinitionCreateNestedOneWithoutValuesInput
    enteredByUser?: UserCreateNestedOneWithoutKpiValuesEnteredInput
    approvedByUser?: UserCreateNestedOneWithoutKpiValuesApprovedInput
    variableValues?: KpiVariableValueCreateNestedManyWithoutKpiValueInput
  }

  export type KpiValuePeriodUncheckedCreateInput = {
    id?: string
    kpiId: string
    periodStart: Date | string
    periodEnd: Date | string
    calculatedValue?: number | null
    status?: $Enums.KpiValueStatus
    note?: string | null
    enteredBy?: string | null
    approvedBy?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variableValues?: KpiVariableValueUncheckedCreateNestedManyWithoutKpiValueInput
  }

  export type KpiValuePeriodUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiValueStatusFieldUpdateOperationsInput | $Enums.KpiValueStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpi?: KpiDefinitionUpdateOneRequiredWithoutValuesNestedInput
    enteredByUser?: UserUpdateOneWithoutKpiValuesEnteredNestedInput
    approvedByUser?: UserUpdateOneWithoutKpiValuesApprovedNestedInput
    variableValues?: KpiVariableValueUpdateManyWithoutKpiValueNestedInput
  }

  export type KpiValuePeriodUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kpiId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiValueStatusFieldUpdateOperationsInput | $Enums.KpiValueStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    enteredBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variableValues?: KpiVariableValueUncheckedUpdateManyWithoutKpiValueNestedInput
  }

  export type KpiValuePeriodCreateManyInput = {
    id?: string
    kpiId: string
    periodStart: Date | string
    periodEnd: Date | string
    calculatedValue?: number | null
    status?: $Enums.KpiValueStatus
    note?: string | null
    enteredBy?: string | null
    approvedBy?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KpiValuePeriodUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiValueStatusFieldUpdateOperationsInput | $Enums.KpiValueStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KpiValuePeriodUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    kpiId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiValueStatusFieldUpdateOperationsInput | $Enums.KpiValueStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    enteredBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KpiVariableValueCreateInput = {
    id?: string
    value: number
    kpiValue: KpiValuePeriodCreateNestedOneWithoutVariableValuesInput
    kpiVariable: KpiVariableCreateNestedOneWithoutValuesInput
  }

  export type KpiVariableValueUncheckedCreateInput = {
    id?: string
    kpiValueId: string
    kpiVariableId: string
    value: number
  }

  export type KpiVariableValueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    kpiValue?: KpiValuePeriodUpdateOneRequiredWithoutVariableValuesNestedInput
    kpiVariable?: KpiVariableUpdateOneRequiredWithoutValuesNestedInput
  }

  export type KpiVariableValueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kpiValueId?: StringFieldUpdateOperationsInput | string
    kpiVariableId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type KpiVariableValueCreateManyInput = {
    id?: string
    kpiValueId: string
    kpiVariableId: string
    value: number
  }

  export type KpiVariableValueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type KpiVariableValueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    kpiValueId?: StringFieldUpdateOperationsInput | string
    kpiVariableId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type NodeListRelationFilter = {
    every?: NodeWhereInput
    some?: NodeWhereInput
    none?: NodeWhereInput
  }

  export type KpiDefinitionListRelationFilter = {
    every?: KpiDefinitionWhereInput
    some?: KpiDefinitionWhereInput
    none?: KpiDefinitionWhereInput
  }

  export type ChangeRequestListRelationFilter = {
    every?: ChangeRequestWhereInput
    some?: ChangeRequestWhereInput
    none?: ChangeRequestWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KpiDefinitionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChangeRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type DepartmentDept_name_org_soft_uniqueCompoundUniqueInput = {
    orgId: string
    name: string
    deletedAt: Date | string
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    parentId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    parentId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    parentId?: SortOrder
    managerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type UserPreferenceNullableScalarRelationFilter = {
    is?: UserPreferenceWhereInput | null
    isNot?: UserPreferenceWhereInput | null
  }

  export type ChangeApprovalListRelationFilter = {
    every?: ChangeApprovalWhereInput
    some?: ChangeApprovalWhereInput
    none?: ChangeApprovalWhereInput
  }

  export type NodeAssignmentListRelationFilter = {
    every?: NodeAssignmentWhereInput
    some?: NodeAssignmentWhereInput
    none?: NodeAssignmentWhereInput
  }

  export type KpiValuePeriodListRelationFilter = {
    every?: KpiValuePeriodWhereInput
    some?: KpiValuePeriodWhereInput
    none?: KpiValuePeriodWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChangeApprovalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NodeAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KpiValuePeriodOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserUser_email_org_uniqueCompoundUniqueInput = {
    orgId: string
    email: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
    role?: SortOrder
    managerId?: SortOrder
    departmentId?: SortOrder
    title?: SortOrder
    image?: SortOrder
    hashedPassword?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
    role?: SortOrder
    managerId?: SortOrder
    departmentId?: SortOrder
    title?: SortOrder
    image?: SortOrder
    hashedPassword?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    name?: SortOrder
    role?: SortOrder
    managerId?: SortOrder
    departmentId?: SortOrder
    title?: SortOrder
    image?: SortOrder
    hashedPassword?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserPreferenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locale?: SortOrder
    theme?: SortOrder
    notifications?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locale?: SortOrder
    theme?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locale?: SortOrder
    theme?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type ChangeRequestCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    requestedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    decidedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChangeRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    requestedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    decidedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChangeRequestMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    status?: SortOrder
    requestedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    decidedAt?: SortOrder
    deletedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type ChangeRequestScalarRelationFilter = {
    is?: ChangeRequestWhereInput
    isNot?: ChangeRequestWhereInput
  }

  export type ChangeApprovalApproval_once_per_userCompoundUniqueInput = {
    changeRequestId: string
    approverId: string
  }

  export type ChangeApprovalCountOrderByAggregateInput = {
    id?: SortOrder
    changeRequestId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    decidedAt?: SortOrder
  }

  export type ChangeApprovalMaxOrderByAggregateInput = {
    id?: SortOrder
    changeRequestId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    decidedAt?: SortOrder
  }

  export type ChangeApprovalMinOrderByAggregateInput = {
    id?: SortOrder
    changeRequestId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    decidedAt?: SortOrder
  }

  export type EnumNodeTypeCodeFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeTypeCode | EnumNodeTypeCodeFieldRefInput<$PrismaModel>
    in?: $Enums.NodeTypeCode[] | ListEnumNodeTypeCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NodeTypeCode[] | ListEnumNodeTypeCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumNodeTypeCodeFilter<$PrismaModel> | $Enums.NodeTypeCode
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NodeTypeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    displayName?: SortOrder
    levelOrder?: SortOrder
    canHaveKpis?: SortOrder
  }

  export type NodeTypeAvgOrderByAggregateInput = {
    levelOrder?: SortOrder
  }

  export type NodeTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    displayName?: SortOrder
    levelOrder?: SortOrder
    canHaveKpis?: SortOrder
  }

  export type NodeTypeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    displayName?: SortOrder
    levelOrder?: SortOrder
    canHaveKpis?: SortOrder
  }

  export type NodeTypeSumOrderByAggregateInput = {
    levelOrder?: SortOrder
  }

  export type EnumNodeTypeCodeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeTypeCode | EnumNodeTypeCodeFieldRefInput<$PrismaModel>
    in?: $Enums.NodeTypeCode[] | ListEnumNodeTypeCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NodeTypeCode[] | ListEnumNodeTypeCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumNodeTypeCodeWithAggregatesFilter<$PrismaModel> | $Enums.NodeTypeCode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNodeTypeCodeFilter<$PrismaModel>
    _max?: NestedEnumNodeTypeCodeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NodeTypeScalarRelationFilter = {
    is?: NodeTypeWhereInput
    isNot?: NodeTypeWhereInput
  }

  export type NodeNullableScalarRelationFilter = {
    is?: NodeWhereInput | null
    isNot?: NodeWhereInput | null
  }

  export type NodeDependencyListRelationFilter = {
    every?: NodeDependencyWhereInput
    some?: NodeDependencyWhereInput
    none?: NodeDependencyWhereInput
  }

  export type NodeDependencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NodeCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    nodeTypeId?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerUserId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type NodeAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type NodeMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    nodeTypeId?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerUserId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type NodeMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    nodeTypeId?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerUserId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type NodeSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type EnumNodeAssignmentRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeAssignmentRole | EnumNodeAssignmentRoleFieldRefInput<$PrismaModel>
    in?: $Enums.NodeAssignmentRole[] | ListEnumNodeAssignmentRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.NodeAssignmentRole[] | ListEnumNodeAssignmentRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumNodeAssignmentRoleFilter<$PrismaModel> | $Enums.NodeAssignmentRole
  }

  export type NodeScalarRelationFilter = {
    is?: NodeWhereInput
    isNot?: NodeWhereInput
  }

  export type NodeAssignmentNode_user_role_uniqueCompoundUniqueInput = {
    nodeId: string
    userId: string
    role: $Enums.NodeAssignmentRole
  }

  export type NodeAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NodeAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NodeAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    nodeId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNodeAssignmentRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeAssignmentRole | EnumNodeAssignmentRoleFieldRefInput<$PrismaModel>
    in?: $Enums.NodeAssignmentRole[] | ListEnumNodeAssignmentRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.NodeAssignmentRole[] | ListEnumNodeAssignmentRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumNodeAssignmentRoleWithAggregatesFilter<$PrismaModel> | $Enums.NodeAssignmentRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNodeAssignmentRoleFilter<$PrismaModel>
    _max?: NestedEnumNodeAssignmentRoleFilter<$PrismaModel>
  }

  export type NodeDependencyNode_dep_uniqueCompoundUniqueInput = {
    blockedNodeId: string
    dependsOnNodeId: string
  }

  export type NodeDependencyCountOrderByAggregateInput = {
    id?: SortOrder
    blockedNodeId?: SortOrder
    dependsOnNodeId?: SortOrder
    createdAt?: SortOrder
  }

  export type NodeDependencyMaxOrderByAggregateInput = {
    id?: SortOrder
    blockedNodeId?: SortOrder
    dependsOnNodeId?: SortOrder
    createdAt?: SortOrder
  }

  export type NodeDependencyMinOrderByAggregateInput = {
    id?: SortOrder
    blockedNodeId?: SortOrder
    dependsOnNodeId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumKpiDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiDirection | EnumKpiDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.KpiDirection[] | ListEnumKpiDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiDirection[] | ListEnumKpiDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiDirectionFilter<$PrismaModel> | $Enums.KpiDirection
  }

  export type EnumKpiAggregationMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiAggregationMethod | EnumKpiAggregationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.KpiAggregationMethod[] | ListEnumKpiAggregationMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiAggregationMethod[] | ListEnumKpiAggregationMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiAggregationMethodFilter<$PrismaModel> | $Enums.KpiAggregationMethod
  }

  export type EnumKpiPeriodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiPeriodType | EnumKpiPeriodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KpiPeriodType[] | ListEnumKpiPeriodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiPeriodType[] | ListEnumKpiPeriodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiPeriodTypeFilter<$PrismaModel> | $Enums.KpiPeriodType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumKpiDefinitionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiDefinitionStatus | EnumKpiDefinitionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KpiDefinitionStatus[] | ListEnumKpiDefinitionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiDefinitionStatus[] | ListEnumKpiDefinitionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiDefinitionStatusFilter<$PrismaModel> | $Enums.KpiDefinitionStatus
  }

  export type KpiVariableListRelationFilter = {
    every?: KpiVariableWhereInput
    some?: KpiVariableWhereInput
    none?: KpiVariableWhereInput
  }

  export type KpiVariableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KpiDefinitionCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    primaryNodeId?: SortOrder
    ownerUserId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    formula?: SortOrder
    unit?: SortOrder
    direction?: SortOrder
    aggregation?: SortOrder
    periodType?: SortOrder
    baselineValue?: SortOrder
    targetValue?: SortOrder
    weight?: SortOrder
    status?: SortOrder
  }

  export type KpiDefinitionAvgOrderByAggregateInput = {
    baselineValue?: SortOrder
    targetValue?: SortOrder
    weight?: SortOrder
  }

  export type KpiDefinitionMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    primaryNodeId?: SortOrder
    ownerUserId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    formula?: SortOrder
    unit?: SortOrder
    direction?: SortOrder
    aggregation?: SortOrder
    periodType?: SortOrder
    baselineValue?: SortOrder
    targetValue?: SortOrder
    weight?: SortOrder
    status?: SortOrder
  }

  export type KpiDefinitionMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    primaryNodeId?: SortOrder
    ownerUserId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    formula?: SortOrder
    unit?: SortOrder
    direction?: SortOrder
    aggregation?: SortOrder
    periodType?: SortOrder
    baselineValue?: SortOrder
    targetValue?: SortOrder
    weight?: SortOrder
    status?: SortOrder
  }

  export type KpiDefinitionSumOrderByAggregateInput = {
    baselineValue?: SortOrder
    targetValue?: SortOrder
    weight?: SortOrder
  }

  export type EnumKpiDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiDirection | EnumKpiDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.KpiDirection[] | ListEnumKpiDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiDirection[] | ListEnumKpiDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiDirectionWithAggregatesFilter<$PrismaModel> | $Enums.KpiDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKpiDirectionFilter<$PrismaModel>
    _max?: NestedEnumKpiDirectionFilter<$PrismaModel>
  }

  export type EnumKpiAggregationMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiAggregationMethod | EnumKpiAggregationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.KpiAggregationMethod[] | ListEnumKpiAggregationMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiAggregationMethod[] | ListEnumKpiAggregationMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiAggregationMethodWithAggregatesFilter<$PrismaModel> | $Enums.KpiAggregationMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKpiAggregationMethodFilter<$PrismaModel>
    _max?: NestedEnumKpiAggregationMethodFilter<$PrismaModel>
  }

  export type EnumKpiPeriodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiPeriodType | EnumKpiPeriodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KpiPeriodType[] | ListEnumKpiPeriodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiPeriodType[] | ListEnumKpiPeriodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiPeriodTypeWithAggregatesFilter<$PrismaModel> | $Enums.KpiPeriodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKpiPeriodTypeFilter<$PrismaModel>
    _max?: NestedEnumKpiPeriodTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumKpiDefinitionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiDefinitionStatus | EnumKpiDefinitionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KpiDefinitionStatus[] | ListEnumKpiDefinitionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiDefinitionStatus[] | ListEnumKpiDefinitionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiDefinitionStatusWithAggregatesFilter<$PrismaModel> | $Enums.KpiDefinitionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKpiDefinitionStatusFilter<$PrismaModel>
    _max?: NestedEnumKpiDefinitionStatusFilter<$PrismaModel>
  }

  export type EnumKpiVariableDataTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiVariableDataType | EnumKpiVariableDataTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KpiVariableDataType[] | ListEnumKpiVariableDataTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiVariableDataType[] | ListEnumKpiVariableDataTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiVariableDataTypeFilter<$PrismaModel> | $Enums.KpiVariableDataType
  }

  export type KpiDefinitionScalarRelationFilter = {
    is?: KpiDefinitionWhereInput
    isNot?: KpiDefinitionWhereInput
  }

  export type KpiVariableValueListRelationFilter = {
    every?: KpiVariableValueWhereInput
    some?: KpiVariableValueWhereInput
    none?: KpiVariableValueWhereInput
  }

  export type KpiVariableValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KpiVariableKpiIdCodeCompoundUniqueInput = {
    kpiId: string
    code: string
  }

  export type KpiVariableCountOrderByAggregateInput = {
    id?: SortOrder
    kpiId?: SortOrder
    code?: SortOrder
    displayName?: SortOrder
    dataType?: SortOrder
    isRequired?: SortOrder
  }

  export type KpiVariableMaxOrderByAggregateInput = {
    id?: SortOrder
    kpiId?: SortOrder
    code?: SortOrder
    displayName?: SortOrder
    dataType?: SortOrder
    isRequired?: SortOrder
  }

  export type KpiVariableMinOrderByAggregateInput = {
    id?: SortOrder
    kpiId?: SortOrder
    code?: SortOrder
    displayName?: SortOrder
    dataType?: SortOrder
    isRequired?: SortOrder
  }

  export type EnumKpiVariableDataTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiVariableDataType | EnumKpiVariableDataTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KpiVariableDataType[] | ListEnumKpiVariableDataTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiVariableDataType[] | ListEnumKpiVariableDataTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiVariableDataTypeWithAggregatesFilter<$PrismaModel> | $Enums.KpiVariableDataType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKpiVariableDataTypeFilter<$PrismaModel>
    _max?: NestedEnumKpiVariableDataTypeFilter<$PrismaModel>
  }

  export type EnumKpiValueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiValueStatus | EnumKpiValueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KpiValueStatus[] | ListEnumKpiValueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiValueStatus[] | ListEnumKpiValueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiValueStatusFilter<$PrismaModel> | $Enums.KpiValueStatus
  }

  export type KpiValuePeriodKpiIdPeriodStartPeriodEndCompoundUniqueInput = {
    kpiId: string
    periodStart: Date | string
    periodEnd: Date | string
  }

  export type KpiValuePeriodCountOrderByAggregateInput = {
    id?: SortOrder
    kpiId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    calculatedValue?: SortOrder
    status?: SortOrder
    note?: SortOrder
    enteredBy?: SortOrder
    approvedBy?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrder
    lockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KpiValuePeriodAvgOrderByAggregateInput = {
    calculatedValue?: SortOrder
  }

  export type KpiValuePeriodMaxOrderByAggregateInput = {
    id?: SortOrder
    kpiId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    calculatedValue?: SortOrder
    status?: SortOrder
    note?: SortOrder
    enteredBy?: SortOrder
    approvedBy?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrder
    lockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KpiValuePeriodMinOrderByAggregateInput = {
    id?: SortOrder
    kpiId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    calculatedValue?: SortOrder
    status?: SortOrder
    note?: SortOrder
    enteredBy?: SortOrder
    approvedBy?: SortOrder
    submittedAt?: SortOrder
    approvedAt?: SortOrder
    lockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KpiValuePeriodSumOrderByAggregateInput = {
    calculatedValue?: SortOrder
  }

  export type EnumKpiValueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiValueStatus | EnumKpiValueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KpiValueStatus[] | ListEnumKpiValueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiValueStatus[] | ListEnumKpiValueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiValueStatusWithAggregatesFilter<$PrismaModel> | $Enums.KpiValueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKpiValueStatusFilter<$PrismaModel>
    _max?: NestedEnumKpiValueStatusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type KpiValuePeriodScalarRelationFilter = {
    is?: KpiValuePeriodWhereInput
    isNot?: KpiValuePeriodWhereInput
  }

  export type KpiVariableScalarRelationFilter = {
    is?: KpiVariableWhereInput
    isNot?: KpiVariableWhereInput
  }

  export type KpiVariableValueKpiValueIdKpiVariableIdCompoundUniqueInput = {
    kpiValueId: string
    kpiVariableId: string
  }

  export type KpiVariableValueCountOrderByAggregateInput = {
    id?: SortOrder
    kpiValueId?: SortOrder
    kpiVariableId?: SortOrder
    value?: SortOrder
  }

  export type KpiVariableValueAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type KpiVariableValueMaxOrderByAggregateInput = {
    id?: SortOrder
    kpiValueId?: SortOrder
    kpiVariableId?: SortOrder
    value?: SortOrder
  }

  export type KpiVariableValueMinOrderByAggregateInput = {
    id?: SortOrder
    kpiValueId?: SortOrder
    kpiVariableId?: SortOrder
    value?: SortOrder
  }

  export type KpiVariableValueSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UserCreateNestedManyWithoutOrgInput = {
    create?: XOR<UserCreateWithoutOrgInput, UserUncheckedCreateWithoutOrgInput> | UserCreateWithoutOrgInput[] | UserUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrgInput | UserCreateOrConnectWithoutOrgInput[]
    createMany?: UserCreateManyOrgInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DepartmentCreateNestedManyWithoutOrgInput = {
    create?: XOR<DepartmentCreateWithoutOrgInput, DepartmentUncheckedCreateWithoutOrgInput> | DepartmentCreateWithoutOrgInput[] | DepartmentUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutOrgInput | DepartmentCreateOrConnectWithoutOrgInput[]
    createMany?: DepartmentCreateManyOrgInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type NodeCreateNestedManyWithoutOrgInput = {
    create?: XOR<NodeCreateWithoutOrgInput, NodeUncheckedCreateWithoutOrgInput> | NodeCreateWithoutOrgInput[] | NodeUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutOrgInput | NodeCreateOrConnectWithoutOrgInput[]
    createMany?: NodeCreateManyOrgInputEnvelope
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
  }

  export type KpiDefinitionCreateNestedManyWithoutOrgInput = {
    create?: XOR<KpiDefinitionCreateWithoutOrgInput, KpiDefinitionUncheckedCreateWithoutOrgInput> | KpiDefinitionCreateWithoutOrgInput[] | KpiDefinitionUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: KpiDefinitionCreateOrConnectWithoutOrgInput | KpiDefinitionCreateOrConnectWithoutOrgInput[]
    createMany?: KpiDefinitionCreateManyOrgInputEnvelope
    connect?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
  }

  export type ChangeRequestCreateNestedManyWithoutOrgInput = {
    create?: XOR<ChangeRequestCreateWithoutOrgInput, ChangeRequestUncheckedCreateWithoutOrgInput> | ChangeRequestCreateWithoutOrgInput[] | ChangeRequestUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutOrgInput | ChangeRequestCreateOrConnectWithoutOrgInput[]
    createMany?: ChangeRequestCreateManyOrgInputEnvelope
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<UserCreateWithoutOrgInput, UserUncheckedCreateWithoutOrgInput> | UserCreateWithoutOrgInput[] | UserUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrgInput | UserCreateOrConnectWithoutOrgInput[]
    createMany?: UserCreateManyOrgInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<DepartmentCreateWithoutOrgInput, DepartmentUncheckedCreateWithoutOrgInput> | DepartmentCreateWithoutOrgInput[] | DepartmentUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutOrgInput | DepartmentCreateOrConnectWithoutOrgInput[]
    createMany?: DepartmentCreateManyOrgInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type NodeUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<NodeCreateWithoutOrgInput, NodeUncheckedCreateWithoutOrgInput> | NodeCreateWithoutOrgInput[] | NodeUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutOrgInput | NodeCreateOrConnectWithoutOrgInput[]
    createMany?: NodeCreateManyOrgInputEnvelope
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
  }

  export type KpiDefinitionUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<KpiDefinitionCreateWithoutOrgInput, KpiDefinitionUncheckedCreateWithoutOrgInput> | KpiDefinitionCreateWithoutOrgInput[] | KpiDefinitionUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: KpiDefinitionCreateOrConnectWithoutOrgInput | KpiDefinitionCreateOrConnectWithoutOrgInput[]
    createMany?: KpiDefinitionCreateManyOrgInputEnvelope
    connect?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
  }

  export type ChangeRequestUncheckedCreateNestedManyWithoutOrgInput = {
    create?: XOR<ChangeRequestCreateWithoutOrgInput, ChangeRequestUncheckedCreateWithoutOrgInput> | ChangeRequestCreateWithoutOrgInput[] | ChangeRequestUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutOrgInput | ChangeRequestCreateOrConnectWithoutOrgInput[]
    createMany?: ChangeRequestCreateManyOrgInputEnvelope
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateManyWithoutOrgNestedInput = {
    create?: XOR<UserCreateWithoutOrgInput, UserUncheckedCreateWithoutOrgInput> | UserCreateWithoutOrgInput[] | UserUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrgInput | UserCreateOrConnectWithoutOrgInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrgInput | UserUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: UserCreateManyOrgInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrgInput | UserUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrgInput | UserUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type DepartmentUpdateManyWithoutOrgNestedInput = {
    create?: XOR<DepartmentCreateWithoutOrgInput, DepartmentUncheckedCreateWithoutOrgInput> | DepartmentCreateWithoutOrgInput[] | DepartmentUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutOrgInput | DepartmentCreateOrConnectWithoutOrgInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutOrgInput | DepartmentUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: DepartmentCreateManyOrgInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutOrgInput | DepartmentUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutOrgInput | DepartmentUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type NodeUpdateManyWithoutOrgNestedInput = {
    create?: XOR<NodeCreateWithoutOrgInput, NodeUncheckedCreateWithoutOrgInput> | NodeCreateWithoutOrgInput[] | NodeUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutOrgInput | NodeCreateOrConnectWithoutOrgInput[]
    upsert?: NodeUpsertWithWhereUniqueWithoutOrgInput | NodeUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: NodeCreateManyOrgInputEnvelope
    set?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    disconnect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    delete?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    update?: NodeUpdateWithWhereUniqueWithoutOrgInput | NodeUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: NodeUpdateManyWithWhereWithoutOrgInput | NodeUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: NodeScalarWhereInput | NodeScalarWhereInput[]
  }

  export type KpiDefinitionUpdateManyWithoutOrgNestedInput = {
    create?: XOR<KpiDefinitionCreateWithoutOrgInput, KpiDefinitionUncheckedCreateWithoutOrgInput> | KpiDefinitionCreateWithoutOrgInput[] | KpiDefinitionUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: KpiDefinitionCreateOrConnectWithoutOrgInput | KpiDefinitionCreateOrConnectWithoutOrgInput[]
    upsert?: KpiDefinitionUpsertWithWhereUniqueWithoutOrgInput | KpiDefinitionUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: KpiDefinitionCreateManyOrgInputEnvelope
    set?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    disconnect?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    delete?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    connect?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    update?: KpiDefinitionUpdateWithWhereUniqueWithoutOrgInput | KpiDefinitionUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: KpiDefinitionUpdateManyWithWhereWithoutOrgInput | KpiDefinitionUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: KpiDefinitionScalarWhereInput | KpiDefinitionScalarWhereInput[]
  }

  export type ChangeRequestUpdateManyWithoutOrgNestedInput = {
    create?: XOR<ChangeRequestCreateWithoutOrgInput, ChangeRequestUncheckedCreateWithoutOrgInput> | ChangeRequestCreateWithoutOrgInput[] | ChangeRequestUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutOrgInput | ChangeRequestCreateOrConnectWithoutOrgInput[]
    upsert?: ChangeRequestUpsertWithWhereUniqueWithoutOrgInput | ChangeRequestUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: ChangeRequestCreateManyOrgInputEnvelope
    set?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    disconnect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    delete?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    update?: ChangeRequestUpdateWithWhereUniqueWithoutOrgInput | ChangeRequestUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: ChangeRequestUpdateManyWithWhereWithoutOrgInput | ChangeRequestUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: ChangeRequestScalarWhereInput | ChangeRequestScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<UserCreateWithoutOrgInput, UserUncheckedCreateWithoutOrgInput> | UserCreateWithoutOrgInput[] | UserUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrgInput | UserCreateOrConnectWithoutOrgInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrgInput | UserUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: UserCreateManyOrgInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrgInput | UserUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrgInput | UserUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<DepartmentCreateWithoutOrgInput, DepartmentUncheckedCreateWithoutOrgInput> | DepartmentCreateWithoutOrgInput[] | DepartmentUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutOrgInput | DepartmentCreateOrConnectWithoutOrgInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutOrgInput | DepartmentUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: DepartmentCreateManyOrgInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutOrgInput | DepartmentUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutOrgInput | DepartmentUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type NodeUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<NodeCreateWithoutOrgInput, NodeUncheckedCreateWithoutOrgInput> | NodeCreateWithoutOrgInput[] | NodeUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutOrgInput | NodeCreateOrConnectWithoutOrgInput[]
    upsert?: NodeUpsertWithWhereUniqueWithoutOrgInput | NodeUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: NodeCreateManyOrgInputEnvelope
    set?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    disconnect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    delete?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    update?: NodeUpdateWithWhereUniqueWithoutOrgInput | NodeUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: NodeUpdateManyWithWhereWithoutOrgInput | NodeUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: NodeScalarWhereInput | NodeScalarWhereInput[]
  }

  export type KpiDefinitionUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<KpiDefinitionCreateWithoutOrgInput, KpiDefinitionUncheckedCreateWithoutOrgInput> | KpiDefinitionCreateWithoutOrgInput[] | KpiDefinitionUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: KpiDefinitionCreateOrConnectWithoutOrgInput | KpiDefinitionCreateOrConnectWithoutOrgInput[]
    upsert?: KpiDefinitionUpsertWithWhereUniqueWithoutOrgInput | KpiDefinitionUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: KpiDefinitionCreateManyOrgInputEnvelope
    set?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    disconnect?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    delete?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    connect?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    update?: KpiDefinitionUpdateWithWhereUniqueWithoutOrgInput | KpiDefinitionUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: KpiDefinitionUpdateManyWithWhereWithoutOrgInput | KpiDefinitionUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: KpiDefinitionScalarWhereInput | KpiDefinitionScalarWhereInput[]
  }

  export type ChangeRequestUncheckedUpdateManyWithoutOrgNestedInput = {
    create?: XOR<ChangeRequestCreateWithoutOrgInput, ChangeRequestUncheckedCreateWithoutOrgInput> | ChangeRequestCreateWithoutOrgInput[] | ChangeRequestUncheckedCreateWithoutOrgInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutOrgInput | ChangeRequestCreateOrConnectWithoutOrgInput[]
    upsert?: ChangeRequestUpsertWithWhereUniqueWithoutOrgInput | ChangeRequestUpsertWithWhereUniqueWithoutOrgInput[]
    createMany?: ChangeRequestCreateManyOrgInputEnvelope
    set?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    disconnect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    delete?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    update?: ChangeRequestUpdateWithWhereUniqueWithoutOrgInput | ChangeRequestUpdateWithWhereUniqueWithoutOrgInput[]
    updateMany?: ChangeRequestUpdateManyWithWhereWithoutOrgInput | ChangeRequestUpdateManyWithWhereWithoutOrgInput[]
    deleteMany?: ChangeRequestScalarWhereInput | ChangeRequestScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<OrganizationCreateWithoutDepartmentsInput, OrganizationUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutDepartmentsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutChildrenInput = {
    create?: XOR<DepartmentCreateWithoutChildrenInput, DepartmentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutChildrenInput
    connect?: DepartmentWhereUniqueInput
  }

  export type DepartmentCreateNestedManyWithoutParentInput = {
    create?: XOR<DepartmentCreateWithoutParentInput, DepartmentUncheckedCreateWithoutParentInput> | DepartmentCreateWithoutParentInput[] | DepartmentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutParentInput | DepartmentCreateOrConnectWithoutParentInput[]
    createMany?: DepartmentCreateManyParentInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutManagedDepartmentsInput = {
    create?: XOR<UserCreateWithoutManagedDepartmentsInput, UserUncheckedCreateWithoutManagedDepartmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedDepartmentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<DepartmentCreateWithoutParentInput, DepartmentUncheckedCreateWithoutParentInput> | DepartmentCreateWithoutParentInput[] | DepartmentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutParentInput | DepartmentCreateOrConnectWithoutParentInput[]
    createMany?: DepartmentCreateManyParentInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput = {
    create?: XOR<OrganizationCreateWithoutDepartmentsInput, OrganizationUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutDepartmentsInput
    upsert?: OrganizationUpsertWithoutDepartmentsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutDepartmentsInput, OrganizationUpdateWithoutDepartmentsInput>, OrganizationUncheckedUpdateWithoutDepartmentsInput>
  }

  export type DepartmentUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<DepartmentCreateWithoutChildrenInput, DepartmentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutChildrenInput
    upsert?: DepartmentUpsertWithoutChildrenInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutChildrenInput, DepartmentUpdateWithoutChildrenInput>, DepartmentUncheckedUpdateWithoutChildrenInput>
  }

  export type DepartmentUpdateManyWithoutParentNestedInput = {
    create?: XOR<DepartmentCreateWithoutParentInput, DepartmentUncheckedCreateWithoutParentInput> | DepartmentCreateWithoutParentInput[] | DepartmentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutParentInput | DepartmentCreateOrConnectWithoutParentInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutParentInput | DepartmentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: DepartmentCreateManyParentInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutParentInput | DepartmentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutParentInput | DepartmentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type UserUpdateOneWithoutManagedDepartmentsNestedInput = {
    create?: XOR<UserCreateWithoutManagedDepartmentsInput, UserUncheckedCreateWithoutManagedDepartmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutManagedDepartmentsInput
    upsert?: UserUpsertWithoutManagedDepartmentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutManagedDepartmentsInput, UserUpdateWithoutManagedDepartmentsInput>, UserUncheckedUpdateWithoutManagedDepartmentsInput>
  }

  export type UserUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDepartmentInput | UserUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDepartmentInput | UserUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDepartmentInput | UserUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<DepartmentCreateWithoutParentInput, DepartmentUncheckedCreateWithoutParentInput> | DepartmentCreateWithoutParentInput[] | DepartmentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutParentInput | DepartmentCreateOrConnectWithoutParentInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutParentInput | DepartmentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: DepartmentCreateManyParentInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutParentInput | DepartmentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutParentInput | DepartmentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput> | UserCreateWithoutDepartmentInput[] | UserUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentInput | UserCreateOrConnectWithoutDepartmentInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutDepartmentInput | UserUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: UserCreateManyDepartmentInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutDepartmentInput | UserUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: UserUpdateManyWithWhereWithoutDepartmentInput | UserUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutUsersInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDirectReportsInput = {
    create?: XOR<UserCreateWithoutDirectReportsInput, UserUncheckedCreateWithoutDirectReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDirectReportsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutManagerInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DepartmentCreateNestedOneWithoutUsersInput = {
    create?: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutUsersInput
    connect?: DepartmentWhereUniqueInput
  }

  export type DepartmentCreateNestedManyWithoutManagerInput = {
    create?: XOR<DepartmentCreateWithoutManagerInput, DepartmentUncheckedCreateWithoutManagerInput> | DepartmentCreateWithoutManagerInput[] | DepartmentUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutManagerInput | DepartmentCreateOrConnectWithoutManagerInput[]
    createMany?: DepartmentCreateManyManagerInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type UserPreferenceCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutUserInput
    connect?: UserPreferenceWhereUniqueInput
  }

  export type ChangeApprovalCreateNestedManyWithoutApproverInput = {
    create?: XOR<ChangeApprovalCreateWithoutApproverInput, ChangeApprovalUncheckedCreateWithoutApproverInput> | ChangeApprovalCreateWithoutApproverInput[] | ChangeApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ChangeApprovalCreateOrConnectWithoutApproverInput | ChangeApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: ChangeApprovalCreateManyApproverInputEnvelope
    connect?: ChangeApprovalWhereUniqueInput | ChangeApprovalWhereUniqueInput[]
  }

  export type ChangeRequestCreateNestedManyWithoutRequesterInput = {
    create?: XOR<ChangeRequestCreateWithoutRequesterInput, ChangeRequestUncheckedCreateWithoutRequesterInput> | ChangeRequestCreateWithoutRequesterInput[] | ChangeRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutRequesterInput | ChangeRequestCreateOrConnectWithoutRequesterInput[]
    createMany?: ChangeRequestCreateManyRequesterInputEnvelope
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
  }

  export type NodeCreateNestedManyWithoutOwnerUserInput = {
    create?: XOR<NodeCreateWithoutOwnerUserInput, NodeUncheckedCreateWithoutOwnerUserInput> | NodeCreateWithoutOwnerUserInput[] | NodeUncheckedCreateWithoutOwnerUserInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutOwnerUserInput | NodeCreateOrConnectWithoutOwnerUserInput[]
    createMany?: NodeCreateManyOwnerUserInputEnvelope
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
  }

  export type NodeAssignmentCreateNestedManyWithoutUserInput = {
    create?: XOR<NodeAssignmentCreateWithoutUserInput, NodeAssignmentUncheckedCreateWithoutUserInput> | NodeAssignmentCreateWithoutUserInput[] | NodeAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NodeAssignmentCreateOrConnectWithoutUserInput | NodeAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: NodeAssignmentCreateManyUserInputEnvelope
    connect?: NodeAssignmentWhereUniqueInput | NodeAssignmentWhereUniqueInput[]
  }

  export type KpiValuePeriodCreateNestedManyWithoutEnteredByUserInput = {
    create?: XOR<KpiValuePeriodCreateWithoutEnteredByUserInput, KpiValuePeriodUncheckedCreateWithoutEnteredByUserInput> | KpiValuePeriodCreateWithoutEnteredByUserInput[] | KpiValuePeriodUncheckedCreateWithoutEnteredByUserInput[]
    connectOrCreate?: KpiValuePeriodCreateOrConnectWithoutEnteredByUserInput | KpiValuePeriodCreateOrConnectWithoutEnteredByUserInput[]
    createMany?: KpiValuePeriodCreateManyEnteredByUserInputEnvelope
    connect?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
  }

  export type KpiValuePeriodCreateNestedManyWithoutApprovedByUserInput = {
    create?: XOR<KpiValuePeriodCreateWithoutApprovedByUserInput, KpiValuePeriodUncheckedCreateWithoutApprovedByUserInput> | KpiValuePeriodCreateWithoutApprovedByUserInput[] | KpiValuePeriodUncheckedCreateWithoutApprovedByUserInput[]
    connectOrCreate?: KpiValuePeriodCreateOrConnectWithoutApprovedByUserInput | KpiValuePeriodCreateOrConnectWithoutApprovedByUserInput[]
    createMany?: KpiValuePeriodCreateManyApprovedByUserInputEnvelope
    connect?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
  }

  export type KpiDefinitionCreateNestedManyWithoutOwnerUserInput = {
    create?: XOR<KpiDefinitionCreateWithoutOwnerUserInput, KpiDefinitionUncheckedCreateWithoutOwnerUserInput> | KpiDefinitionCreateWithoutOwnerUserInput[] | KpiDefinitionUncheckedCreateWithoutOwnerUserInput[]
    connectOrCreate?: KpiDefinitionCreateOrConnectWithoutOwnerUserInput | KpiDefinitionCreateOrConnectWithoutOwnerUserInput[]
    createMany?: KpiDefinitionCreateManyOwnerUserInputEnvelope
    connect?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<DepartmentCreateWithoutManagerInput, DepartmentUncheckedCreateWithoutManagerInput> | DepartmentCreateWithoutManagerInput[] | DepartmentUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutManagerInput | DepartmentCreateOrConnectWithoutManagerInput[]
    createMany?: DepartmentCreateManyManagerInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type UserPreferenceUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutUserInput
    connect?: UserPreferenceWhereUniqueInput
  }

  export type ChangeApprovalUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<ChangeApprovalCreateWithoutApproverInput, ChangeApprovalUncheckedCreateWithoutApproverInput> | ChangeApprovalCreateWithoutApproverInput[] | ChangeApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ChangeApprovalCreateOrConnectWithoutApproverInput | ChangeApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: ChangeApprovalCreateManyApproverInputEnvelope
    connect?: ChangeApprovalWhereUniqueInput | ChangeApprovalWhereUniqueInput[]
  }

  export type ChangeRequestUncheckedCreateNestedManyWithoutRequesterInput = {
    create?: XOR<ChangeRequestCreateWithoutRequesterInput, ChangeRequestUncheckedCreateWithoutRequesterInput> | ChangeRequestCreateWithoutRequesterInput[] | ChangeRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutRequesterInput | ChangeRequestCreateOrConnectWithoutRequesterInput[]
    createMany?: ChangeRequestCreateManyRequesterInputEnvelope
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
  }

  export type NodeUncheckedCreateNestedManyWithoutOwnerUserInput = {
    create?: XOR<NodeCreateWithoutOwnerUserInput, NodeUncheckedCreateWithoutOwnerUserInput> | NodeCreateWithoutOwnerUserInput[] | NodeUncheckedCreateWithoutOwnerUserInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutOwnerUserInput | NodeCreateOrConnectWithoutOwnerUserInput[]
    createMany?: NodeCreateManyOwnerUserInputEnvelope
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
  }

  export type NodeAssignmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NodeAssignmentCreateWithoutUserInput, NodeAssignmentUncheckedCreateWithoutUserInput> | NodeAssignmentCreateWithoutUserInput[] | NodeAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NodeAssignmentCreateOrConnectWithoutUserInput | NodeAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: NodeAssignmentCreateManyUserInputEnvelope
    connect?: NodeAssignmentWhereUniqueInput | NodeAssignmentWhereUniqueInput[]
  }

  export type KpiValuePeriodUncheckedCreateNestedManyWithoutEnteredByUserInput = {
    create?: XOR<KpiValuePeriodCreateWithoutEnteredByUserInput, KpiValuePeriodUncheckedCreateWithoutEnteredByUserInput> | KpiValuePeriodCreateWithoutEnteredByUserInput[] | KpiValuePeriodUncheckedCreateWithoutEnteredByUserInput[]
    connectOrCreate?: KpiValuePeriodCreateOrConnectWithoutEnteredByUserInput | KpiValuePeriodCreateOrConnectWithoutEnteredByUserInput[]
    createMany?: KpiValuePeriodCreateManyEnteredByUserInputEnvelope
    connect?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
  }

  export type KpiValuePeriodUncheckedCreateNestedManyWithoutApprovedByUserInput = {
    create?: XOR<KpiValuePeriodCreateWithoutApprovedByUserInput, KpiValuePeriodUncheckedCreateWithoutApprovedByUserInput> | KpiValuePeriodCreateWithoutApprovedByUserInput[] | KpiValuePeriodUncheckedCreateWithoutApprovedByUserInput[]
    connectOrCreate?: KpiValuePeriodCreateOrConnectWithoutApprovedByUserInput | KpiValuePeriodCreateOrConnectWithoutApprovedByUserInput[]
    createMany?: KpiValuePeriodCreateManyApprovedByUserInputEnvelope
    connect?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
  }

  export type KpiDefinitionUncheckedCreateNestedManyWithoutOwnerUserInput = {
    create?: XOR<KpiDefinitionCreateWithoutOwnerUserInput, KpiDefinitionUncheckedCreateWithoutOwnerUserInput> | KpiDefinitionCreateWithoutOwnerUserInput[] | KpiDefinitionUncheckedCreateWithoutOwnerUserInput[]
    connectOrCreate?: KpiDefinitionCreateOrConnectWithoutOwnerUserInput | KpiDefinitionCreateOrConnectWithoutOwnerUserInput[]
    createMany?: KpiDefinitionCreateManyOwnerUserInputEnvelope
    connect?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type OrganizationUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    upsert?: OrganizationUpsertWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUsersInput, OrganizationUpdateWithoutUsersInput>, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneWithoutDirectReportsNestedInput = {
    create?: XOR<UserCreateWithoutDirectReportsInput, UserUncheckedCreateWithoutDirectReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDirectReportsInput
    upsert?: UserUpsertWithoutDirectReportsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDirectReportsInput, UserUpdateWithoutDirectReportsInput>, UserUncheckedUpdateWithoutDirectReportsInput>
  }

  export type UserUpdateManyWithoutManagerNestedInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutManagerInput | UserUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutManagerInput | UserUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutManagerInput | UserUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type DepartmentUpdateOneWithoutUsersNestedInput = {
    create?: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutUsersInput
    upsert?: DepartmentUpsertWithoutUsersInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutUsersInput, DepartmentUpdateWithoutUsersInput>, DepartmentUncheckedUpdateWithoutUsersInput>
  }

  export type DepartmentUpdateManyWithoutManagerNestedInput = {
    create?: XOR<DepartmentCreateWithoutManagerInput, DepartmentUncheckedCreateWithoutManagerInput> | DepartmentCreateWithoutManagerInput[] | DepartmentUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutManagerInput | DepartmentCreateOrConnectWithoutManagerInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutManagerInput | DepartmentUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: DepartmentCreateManyManagerInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutManagerInput | DepartmentUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutManagerInput | DepartmentUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type UserPreferenceUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutUserInput
    upsert?: UserPreferenceUpsertWithoutUserInput
    disconnect?: UserPreferenceWhereInput | boolean
    delete?: UserPreferenceWhereInput | boolean
    connect?: UserPreferenceWhereUniqueInput
    update?: XOR<XOR<UserPreferenceUpdateToOneWithWhereWithoutUserInput, UserPreferenceUpdateWithoutUserInput>, UserPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type ChangeApprovalUpdateManyWithoutApproverNestedInput = {
    create?: XOR<ChangeApprovalCreateWithoutApproverInput, ChangeApprovalUncheckedCreateWithoutApproverInput> | ChangeApprovalCreateWithoutApproverInput[] | ChangeApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ChangeApprovalCreateOrConnectWithoutApproverInput | ChangeApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: ChangeApprovalUpsertWithWhereUniqueWithoutApproverInput | ChangeApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: ChangeApprovalCreateManyApproverInputEnvelope
    set?: ChangeApprovalWhereUniqueInput | ChangeApprovalWhereUniqueInput[]
    disconnect?: ChangeApprovalWhereUniqueInput | ChangeApprovalWhereUniqueInput[]
    delete?: ChangeApprovalWhereUniqueInput | ChangeApprovalWhereUniqueInput[]
    connect?: ChangeApprovalWhereUniqueInput | ChangeApprovalWhereUniqueInput[]
    update?: ChangeApprovalUpdateWithWhereUniqueWithoutApproverInput | ChangeApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: ChangeApprovalUpdateManyWithWhereWithoutApproverInput | ChangeApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: ChangeApprovalScalarWhereInput | ChangeApprovalScalarWhereInput[]
  }

  export type ChangeRequestUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<ChangeRequestCreateWithoutRequesterInput, ChangeRequestUncheckedCreateWithoutRequesterInput> | ChangeRequestCreateWithoutRequesterInput[] | ChangeRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutRequesterInput | ChangeRequestCreateOrConnectWithoutRequesterInput[]
    upsert?: ChangeRequestUpsertWithWhereUniqueWithoutRequesterInput | ChangeRequestUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: ChangeRequestCreateManyRequesterInputEnvelope
    set?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    disconnect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    delete?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    update?: ChangeRequestUpdateWithWhereUniqueWithoutRequesterInput | ChangeRequestUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: ChangeRequestUpdateManyWithWhereWithoutRequesterInput | ChangeRequestUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: ChangeRequestScalarWhereInput | ChangeRequestScalarWhereInput[]
  }

  export type NodeUpdateManyWithoutOwnerUserNestedInput = {
    create?: XOR<NodeCreateWithoutOwnerUserInput, NodeUncheckedCreateWithoutOwnerUserInput> | NodeCreateWithoutOwnerUserInput[] | NodeUncheckedCreateWithoutOwnerUserInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutOwnerUserInput | NodeCreateOrConnectWithoutOwnerUserInput[]
    upsert?: NodeUpsertWithWhereUniqueWithoutOwnerUserInput | NodeUpsertWithWhereUniqueWithoutOwnerUserInput[]
    createMany?: NodeCreateManyOwnerUserInputEnvelope
    set?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    disconnect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    delete?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    update?: NodeUpdateWithWhereUniqueWithoutOwnerUserInput | NodeUpdateWithWhereUniqueWithoutOwnerUserInput[]
    updateMany?: NodeUpdateManyWithWhereWithoutOwnerUserInput | NodeUpdateManyWithWhereWithoutOwnerUserInput[]
    deleteMany?: NodeScalarWhereInput | NodeScalarWhereInput[]
  }

  export type NodeAssignmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<NodeAssignmentCreateWithoutUserInput, NodeAssignmentUncheckedCreateWithoutUserInput> | NodeAssignmentCreateWithoutUserInput[] | NodeAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NodeAssignmentCreateOrConnectWithoutUserInput | NodeAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: NodeAssignmentUpsertWithWhereUniqueWithoutUserInput | NodeAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NodeAssignmentCreateManyUserInputEnvelope
    set?: NodeAssignmentWhereUniqueInput | NodeAssignmentWhereUniqueInput[]
    disconnect?: NodeAssignmentWhereUniqueInput | NodeAssignmentWhereUniqueInput[]
    delete?: NodeAssignmentWhereUniqueInput | NodeAssignmentWhereUniqueInput[]
    connect?: NodeAssignmentWhereUniqueInput | NodeAssignmentWhereUniqueInput[]
    update?: NodeAssignmentUpdateWithWhereUniqueWithoutUserInput | NodeAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NodeAssignmentUpdateManyWithWhereWithoutUserInput | NodeAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NodeAssignmentScalarWhereInput | NodeAssignmentScalarWhereInput[]
  }

  export type KpiValuePeriodUpdateManyWithoutEnteredByUserNestedInput = {
    create?: XOR<KpiValuePeriodCreateWithoutEnteredByUserInput, KpiValuePeriodUncheckedCreateWithoutEnteredByUserInput> | KpiValuePeriodCreateWithoutEnteredByUserInput[] | KpiValuePeriodUncheckedCreateWithoutEnteredByUserInput[]
    connectOrCreate?: KpiValuePeriodCreateOrConnectWithoutEnteredByUserInput | KpiValuePeriodCreateOrConnectWithoutEnteredByUserInput[]
    upsert?: KpiValuePeriodUpsertWithWhereUniqueWithoutEnteredByUserInput | KpiValuePeriodUpsertWithWhereUniqueWithoutEnteredByUserInput[]
    createMany?: KpiValuePeriodCreateManyEnteredByUserInputEnvelope
    set?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    disconnect?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    delete?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    connect?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    update?: KpiValuePeriodUpdateWithWhereUniqueWithoutEnteredByUserInput | KpiValuePeriodUpdateWithWhereUniqueWithoutEnteredByUserInput[]
    updateMany?: KpiValuePeriodUpdateManyWithWhereWithoutEnteredByUserInput | KpiValuePeriodUpdateManyWithWhereWithoutEnteredByUserInput[]
    deleteMany?: KpiValuePeriodScalarWhereInput | KpiValuePeriodScalarWhereInput[]
  }

  export type KpiValuePeriodUpdateManyWithoutApprovedByUserNestedInput = {
    create?: XOR<KpiValuePeriodCreateWithoutApprovedByUserInput, KpiValuePeriodUncheckedCreateWithoutApprovedByUserInput> | KpiValuePeriodCreateWithoutApprovedByUserInput[] | KpiValuePeriodUncheckedCreateWithoutApprovedByUserInput[]
    connectOrCreate?: KpiValuePeriodCreateOrConnectWithoutApprovedByUserInput | KpiValuePeriodCreateOrConnectWithoutApprovedByUserInput[]
    upsert?: KpiValuePeriodUpsertWithWhereUniqueWithoutApprovedByUserInput | KpiValuePeriodUpsertWithWhereUniqueWithoutApprovedByUserInput[]
    createMany?: KpiValuePeriodCreateManyApprovedByUserInputEnvelope
    set?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    disconnect?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    delete?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    connect?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    update?: KpiValuePeriodUpdateWithWhereUniqueWithoutApprovedByUserInput | KpiValuePeriodUpdateWithWhereUniqueWithoutApprovedByUserInput[]
    updateMany?: KpiValuePeriodUpdateManyWithWhereWithoutApprovedByUserInput | KpiValuePeriodUpdateManyWithWhereWithoutApprovedByUserInput[]
    deleteMany?: KpiValuePeriodScalarWhereInput | KpiValuePeriodScalarWhereInput[]
  }

  export type KpiDefinitionUpdateManyWithoutOwnerUserNestedInput = {
    create?: XOR<KpiDefinitionCreateWithoutOwnerUserInput, KpiDefinitionUncheckedCreateWithoutOwnerUserInput> | KpiDefinitionCreateWithoutOwnerUserInput[] | KpiDefinitionUncheckedCreateWithoutOwnerUserInput[]
    connectOrCreate?: KpiDefinitionCreateOrConnectWithoutOwnerUserInput | KpiDefinitionCreateOrConnectWithoutOwnerUserInput[]
    upsert?: KpiDefinitionUpsertWithWhereUniqueWithoutOwnerUserInput | KpiDefinitionUpsertWithWhereUniqueWithoutOwnerUserInput[]
    createMany?: KpiDefinitionCreateManyOwnerUserInputEnvelope
    set?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    disconnect?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    delete?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    connect?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    update?: KpiDefinitionUpdateWithWhereUniqueWithoutOwnerUserInput | KpiDefinitionUpdateWithWhereUniqueWithoutOwnerUserInput[]
    updateMany?: KpiDefinitionUpdateManyWithWhereWithoutOwnerUserInput | KpiDefinitionUpdateManyWithWhereWithoutOwnerUserInput[]
    deleteMany?: KpiDefinitionScalarWhereInput | KpiDefinitionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput> | UserCreateWithoutManagerInput[] | UserUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: UserCreateOrConnectWithoutManagerInput | UserCreateOrConnectWithoutManagerInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutManagerInput | UserUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: UserCreateManyManagerInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutManagerInput | UserUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: UserUpdateManyWithWhereWithoutManagerInput | UserUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<DepartmentCreateWithoutManagerInput, DepartmentUncheckedCreateWithoutManagerInput> | DepartmentCreateWithoutManagerInput[] | DepartmentUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutManagerInput | DepartmentCreateOrConnectWithoutManagerInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutManagerInput | DepartmentUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: DepartmentCreateManyManagerInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutManagerInput | DepartmentUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutManagerInput | DepartmentUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type UserPreferenceUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferenceCreateOrConnectWithoutUserInput
    upsert?: UserPreferenceUpsertWithoutUserInput
    disconnect?: UserPreferenceWhereInput | boolean
    delete?: UserPreferenceWhereInput | boolean
    connect?: UserPreferenceWhereUniqueInput
    update?: XOR<XOR<UserPreferenceUpdateToOneWithWhereWithoutUserInput, UserPreferenceUpdateWithoutUserInput>, UserPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type ChangeApprovalUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<ChangeApprovalCreateWithoutApproverInput, ChangeApprovalUncheckedCreateWithoutApproverInput> | ChangeApprovalCreateWithoutApproverInput[] | ChangeApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ChangeApprovalCreateOrConnectWithoutApproverInput | ChangeApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: ChangeApprovalUpsertWithWhereUniqueWithoutApproverInput | ChangeApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: ChangeApprovalCreateManyApproverInputEnvelope
    set?: ChangeApprovalWhereUniqueInput | ChangeApprovalWhereUniqueInput[]
    disconnect?: ChangeApprovalWhereUniqueInput | ChangeApprovalWhereUniqueInput[]
    delete?: ChangeApprovalWhereUniqueInput | ChangeApprovalWhereUniqueInput[]
    connect?: ChangeApprovalWhereUniqueInput | ChangeApprovalWhereUniqueInput[]
    update?: ChangeApprovalUpdateWithWhereUniqueWithoutApproverInput | ChangeApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: ChangeApprovalUpdateManyWithWhereWithoutApproverInput | ChangeApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: ChangeApprovalScalarWhereInput | ChangeApprovalScalarWhereInput[]
  }

  export type ChangeRequestUncheckedUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<ChangeRequestCreateWithoutRequesterInput, ChangeRequestUncheckedCreateWithoutRequesterInput> | ChangeRequestCreateWithoutRequesterInput[] | ChangeRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutRequesterInput | ChangeRequestCreateOrConnectWithoutRequesterInput[]
    upsert?: ChangeRequestUpsertWithWhereUniqueWithoutRequesterInput | ChangeRequestUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: ChangeRequestCreateManyRequesterInputEnvelope
    set?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    disconnect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    delete?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    connect?: ChangeRequestWhereUniqueInput | ChangeRequestWhereUniqueInput[]
    update?: ChangeRequestUpdateWithWhereUniqueWithoutRequesterInput | ChangeRequestUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: ChangeRequestUpdateManyWithWhereWithoutRequesterInput | ChangeRequestUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: ChangeRequestScalarWhereInput | ChangeRequestScalarWhereInput[]
  }

  export type NodeUncheckedUpdateManyWithoutOwnerUserNestedInput = {
    create?: XOR<NodeCreateWithoutOwnerUserInput, NodeUncheckedCreateWithoutOwnerUserInput> | NodeCreateWithoutOwnerUserInput[] | NodeUncheckedCreateWithoutOwnerUserInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutOwnerUserInput | NodeCreateOrConnectWithoutOwnerUserInput[]
    upsert?: NodeUpsertWithWhereUniqueWithoutOwnerUserInput | NodeUpsertWithWhereUniqueWithoutOwnerUserInput[]
    createMany?: NodeCreateManyOwnerUserInputEnvelope
    set?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    disconnect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    delete?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    update?: NodeUpdateWithWhereUniqueWithoutOwnerUserInput | NodeUpdateWithWhereUniqueWithoutOwnerUserInput[]
    updateMany?: NodeUpdateManyWithWhereWithoutOwnerUserInput | NodeUpdateManyWithWhereWithoutOwnerUserInput[]
    deleteMany?: NodeScalarWhereInput | NodeScalarWhereInput[]
  }

  export type NodeAssignmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NodeAssignmentCreateWithoutUserInput, NodeAssignmentUncheckedCreateWithoutUserInput> | NodeAssignmentCreateWithoutUserInput[] | NodeAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NodeAssignmentCreateOrConnectWithoutUserInput | NodeAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: NodeAssignmentUpsertWithWhereUniqueWithoutUserInput | NodeAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NodeAssignmentCreateManyUserInputEnvelope
    set?: NodeAssignmentWhereUniqueInput | NodeAssignmentWhereUniqueInput[]
    disconnect?: NodeAssignmentWhereUniqueInput | NodeAssignmentWhereUniqueInput[]
    delete?: NodeAssignmentWhereUniqueInput | NodeAssignmentWhereUniqueInput[]
    connect?: NodeAssignmentWhereUniqueInput | NodeAssignmentWhereUniqueInput[]
    update?: NodeAssignmentUpdateWithWhereUniqueWithoutUserInput | NodeAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NodeAssignmentUpdateManyWithWhereWithoutUserInput | NodeAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NodeAssignmentScalarWhereInput | NodeAssignmentScalarWhereInput[]
  }

  export type KpiValuePeriodUncheckedUpdateManyWithoutEnteredByUserNestedInput = {
    create?: XOR<KpiValuePeriodCreateWithoutEnteredByUserInput, KpiValuePeriodUncheckedCreateWithoutEnteredByUserInput> | KpiValuePeriodCreateWithoutEnteredByUserInput[] | KpiValuePeriodUncheckedCreateWithoutEnteredByUserInput[]
    connectOrCreate?: KpiValuePeriodCreateOrConnectWithoutEnteredByUserInput | KpiValuePeriodCreateOrConnectWithoutEnteredByUserInput[]
    upsert?: KpiValuePeriodUpsertWithWhereUniqueWithoutEnteredByUserInput | KpiValuePeriodUpsertWithWhereUniqueWithoutEnteredByUserInput[]
    createMany?: KpiValuePeriodCreateManyEnteredByUserInputEnvelope
    set?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    disconnect?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    delete?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    connect?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    update?: KpiValuePeriodUpdateWithWhereUniqueWithoutEnteredByUserInput | KpiValuePeriodUpdateWithWhereUniqueWithoutEnteredByUserInput[]
    updateMany?: KpiValuePeriodUpdateManyWithWhereWithoutEnteredByUserInput | KpiValuePeriodUpdateManyWithWhereWithoutEnteredByUserInput[]
    deleteMany?: KpiValuePeriodScalarWhereInput | KpiValuePeriodScalarWhereInput[]
  }

  export type KpiValuePeriodUncheckedUpdateManyWithoutApprovedByUserNestedInput = {
    create?: XOR<KpiValuePeriodCreateWithoutApprovedByUserInput, KpiValuePeriodUncheckedCreateWithoutApprovedByUserInput> | KpiValuePeriodCreateWithoutApprovedByUserInput[] | KpiValuePeriodUncheckedCreateWithoutApprovedByUserInput[]
    connectOrCreate?: KpiValuePeriodCreateOrConnectWithoutApprovedByUserInput | KpiValuePeriodCreateOrConnectWithoutApprovedByUserInput[]
    upsert?: KpiValuePeriodUpsertWithWhereUniqueWithoutApprovedByUserInput | KpiValuePeriodUpsertWithWhereUniqueWithoutApprovedByUserInput[]
    createMany?: KpiValuePeriodCreateManyApprovedByUserInputEnvelope
    set?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    disconnect?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    delete?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    connect?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    update?: KpiValuePeriodUpdateWithWhereUniqueWithoutApprovedByUserInput | KpiValuePeriodUpdateWithWhereUniqueWithoutApprovedByUserInput[]
    updateMany?: KpiValuePeriodUpdateManyWithWhereWithoutApprovedByUserInput | KpiValuePeriodUpdateManyWithWhereWithoutApprovedByUserInput[]
    deleteMany?: KpiValuePeriodScalarWhereInput | KpiValuePeriodScalarWhereInput[]
  }

  export type KpiDefinitionUncheckedUpdateManyWithoutOwnerUserNestedInput = {
    create?: XOR<KpiDefinitionCreateWithoutOwnerUserInput, KpiDefinitionUncheckedCreateWithoutOwnerUserInput> | KpiDefinitionCreateWithoutOwnerUserInput[] | KpiDefinitionUncheckedCreateWithoutOwnerUserInput[]
    connectOrCreate?: KpiDefinitionCreateOrConnectWithoutOwnerUserInput | KpiDefinitionCreateOrConnectWithoutOwnerUserInput[]
    upsert?: KpiDefinitionUpsertWithWhereUniqueWithoutOwnerUserInput | KpiDefinitionUpsertWithWhereUniqueWithoutOwnerUserInput[]
    createMany?: KpiDefinitionCreateManyOwnerUserInputEnvelope
    set?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    disconnect?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    delete?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    connect?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    update?: KpiDefinitionUpdateWithWhereUniqueWithoutOwnerUserInput | KpiDefinitionUpdateWithWhereUniqueWithoutOwnerUserInput[]
    updateMany?: KpiDefinitionUpdateManyWithWhereWithoutOwnerUserInput | KpiDefinitionUpdateManyWithWhereWithoutOwnerUserInput[]
    deleteMany?: KpiDefinitionScalarWhereInput | KpiDefinitionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutPreferencesInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPreferencesInput
    upsert?: UserUpsertWithoutPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPreferencesInput, UserUpdateWithoutPreferencesInput>, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type OrganizationCreateNestedOneWithoutChangeRequestsInput = {
    create?: XOR<OrganizationCreateWithoutChangeRequestsInput, OrganizationUncheckedCreateWithoutChangeRequestsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutChangeRequestsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChangeRequestsInput = {
    create?: XOR<UserCreateWithoutChangeRequestsInput, UserUncheckedCreateWithoutChangeRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChangeRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type ChangeApprovalCreateNestedManyWithoutChangeRequestInput = {
    create?: XOR<ChangeApprovalCreateWithoutChangeRequestInput, ChangeApprovalUncheckedCreateWithoutChangeRequestInput> | ChangeApprovalCreateWithoutChangeRequestInput[] | ChangeApprovalUncheckedCreateWithoutChangeRequestInput[]
    connectOrCreate?: ChangeApprovalCreateOrConnectWithoutChangeRequestInput | ChangeApprovalCreateOrConnectWithoutChangeRequestInput[]
    createMany?: ChangeApprovalCreateManyChangeRequestInputEnvelope
    connect?: ChangeApprovalWhereUniqueInput | ChangeApprovalWhereUniqueInput[]
  }

  export type ChangeApprovalUncheckedCreateNestedManyWithoutChangeRequestInput = {
    create?: XOR<ChangeApprovalCreateWithoutChangeRequestInput, ChangeApprovalUncheckedCreateWithoutChangeRequestInput> | ChangeApprovalCreateWithoutChangeRequestInput[] | ChangeApprovalUncheckedCreateWithoutChangeRequestInput[]
    connectOrCreate?: ChangeApprovalCreateOrConnectWithoutChangeRequestInput | ChangeApprovalCreateOrConnectWithoutChangeRequestInput[]
    createMany?: ChangeApprovalCreateManyChangeRequestInputEnvelope
    connect?: ChangeApprovalWhereUniqueInput | ChangeApprovalWhereUniqueInput[]
  }

  export type EnumApprovalStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalStatus
  }

  export type OrganizationUpdateOneRequiredWithoutChangeRequestsNestedInput = {
    create?: XOR<OrganizationCreateWithoutChangeRequestsInput, OrganizationUncheckedCreateWithoutChangeRequestsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutChangeRequestsInput
    upsert?: OrganizationUpsertWithoutChangeRequestsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutChangeRequestsInput, OrganizationUpdateWithoutChangeRequestsInput>, OrganizationUncheckedUpdateWithoutChangeRequestsInput>
  }

  export type UserUpdateOneRequiredWithoutChangeRequestsNestedInput = {
    create?: XOR<UserCreateWithoutChangeRequestsInput, UserUncheckedCreateWithoutChangeRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChangeRequestsInput
    upsert?: UserUpsertWithoutChangeRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChangeRequestsInput, UserUpdateWithoutChangeRequestsInput>, UserUncheckedUpdateWithoutChangeRequestsInput>
  }

  export type ChangeApprovalUpdateManyWithoutChangeRequestNestedInput = {
    create?: XOR<ChangeApprovalCreateWithoutChangeRequestInput, ChangeApprovalUncheckedCreateWithoutChangeRequestInput> | ChangeApprovalCreateWithoutChangeRequestInput[] | ChangeApprovalUncheckedCreateWithoutChangeRequestInput[]
    connectOrCreate?: ChangeApprovalCreateOrConnectWithoutChangeRequestInput | ChangeApprovalCreateOrConnectWithoutChangeRequestInput[]
    upsert?: ChangeApprovalUpsertWithWhereUniqueWithoutChangeRequestInput | ChangeApprovalUpsertWithWhereUniqueWithoutChangeRequestInput[]
    createMany?: ChangeApprovalCreateManyChangeRequestInputEnvelope
    set?: ChangeApprovalWhereUniqueInput | ChangeApprovalWhereUniqueInput[]
    disconnect?: ChangeApprovalWhereUniqueInput | ChangeApprovalWhereUniqueInput[]
    delete?: ChangeApprovalWhereUniqueInput | ChangeApprovalWhereUniqueInput[]
    connect?: ChangeApprovalWhereUniqueInput | ChangeApprovalWhereUniqueInput[]
    update?: ChangeApprovalUpdateWithWhereUniqueWithoutChangeRequestInput | ChangeApprovalUpdateWithWhereUniqueWithoutChangeRequestInput[]
    updateMany?: ChangeApprovalUpdateManyWithWhereWithoutChangeRequestInput | ChangeApprovalUpdateManyWithWhereWithoutChangeRequestInput[]
    deleteMany?: ChangeApprovalScalarWhereInput | ChangeApprovalScalarWhereInput[]
  }

  export type ChangeApprovalUncheckedUpdateManyWithoutChangeRequestNestedInput = {
    create?: XOR<ChangeApprovalCreateWithoutChangeRequestInput, ChangeApprovalUncheckedCreateWithoutChangeRequestInput> | ChangeApprovalCreateWithoutChangeRequestInput[] | ChangeApprovalUncheckedCreateWithoutChangeRequestInput[]
    connectOrCreate?: ChangeApprovalCreateOrConnectWithoutChangeRequestInput | ChangeApprovalCreateOrConnectWithoutChangeRequestInput[]
    upsert?: ChangeApprovalUpsertWithWhereUniqueWithoutChangeRequestInput | ChangeApprovalUpsertWithWhereUniqueWithoutChangeRequestInput[]
    createMany?: ChangeApprovalCreateManyChangeRequestInputEnvelope
    set?: ChangeApprovalWhereUniqueInput | ChangeApprovalWhereUniqueInput[]
    disconnect?: ChangeApprovalWhereUniqueInput | ChangeApprovalWhereUniqueInput[]
    delete?: ChangeApprovalWhereUniqueInput | ChangeApprovalWhereUniqueInput[]
    connect?: ChangeApprovalWhereUniqueInput | ChangeApprovalWhereUniqueInput[]
    update?: ChangeApprovalUpdateWithWhereUniqueWithoutChangeRequestInput | ChangeApprovalUpdateWithWhereUniqueWithoutChangeRequestInput[]
    updateMany?: ChangeApprovalUpdateManyWithWhereWithoutChangeRequestInput | ChangeApprovalUpdateManyWithWhereWithoutChangeRequestInput[]
    deleteMany?: ChangeApprovalScalarWhereInput | ChangeApprovalScalarWhereInput[]
  }

  export type ChangeRequestCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<ChangeRequestCreateWithoutApprovalsInput, ChangeRequestUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutApprovalsInput
    connect?: ChangeRequestWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<UserCreateWithoutApprovalsInput, UserUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type ChangeRequestUpdateOneRequiredWithoutApprovalsNestedInput = {
    create?: XOR<ChangeRequestCreateWithoutApprovalsInput, ChangeRequestUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: ChangeRequestCreateOrConnectWithoutApprovalsInput
    upsert?: ChangeRequestUpsertWithoutApprovalsInput
    connect?: ChangeRequestWhereUniqueInput
    update?: XOR<XOR<ChangeRequestUpdateToOneWithWhereWithoutApprovalsInput, ChangeRequestUpdateWithoutApprovalsInput>, ChangeRequestUncheckedUpdateWithoutApprovalsInput>
  }

  export type UserUpdateOneRequiredWithoutApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutApprovalsInput, UserUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalsInput
    upsert?: UserUpsertWithoutApprovalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovalsInput, UserUpdateWithoutApprovalsInput>, UserUncheckedUpdateWithoutApprovalsInput>
  }

  export type NodeCreateNestedManyWithoutNodeTypeInput = {
    create?: XOR<NodeCreateWithoutNodeTypeInput, NodeUncheckedCreateWithoutNodeTypeInput> | NodeCreateWithoutNodeTypeInput[] | NodeUncheckedCreateWithoutNodeTypeInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutNodeTypeInput | NodeCreateOrConnectWithoutNodeTypeInput[]
    createMany?: NodeCreateManyNodeTypeInputEnvelope
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
  }

  export type NodeUncheckedCreateNestedManyWithoutNodeTypeInput = {
    create?: XOR<NodeCreateWithoutNodeTypeInput, NodeUncheckedCreateWithoutNodeTypeInput> | NodeCreateWithoutNodeTypeInput[] | NodeUncheckedCreateWithoutNodeTypeInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutNodeTypeInput | NodeCreateOrConnectWithoutNodeTypeInput[]
    createMany?: NodeCreateManyNodeTypeInputEnvelope
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
  }

  export type EnumNodeTypeCodeFieldUpdateOperationsInput = {
    set?: $Enums.NodeTypeCode
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NodeUpdateManyWithoutNodeTypeNestedInput = {
    create?: XOR<NodeCreateWithoutNodeTypeInput, NodeUncheckedCreateWithoutNodeTypeInput> | NodeCreateWithoutNodeTypeInput[] | NodeUncheckedCreateWithoutNodeTypeInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutNodeTypeInput | NodeCreateOrConnectWithoutNodeTypeInput[]
    upsert?: NodeUpsertWithWhereUniqueWithoutNodeTypeInput | NodeUpsertWithWhereUniqueWithoutNodeTypeInput[]
    createMany?: NodeCreateManyNodeTypeInputEnvelope
    set?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    disconnect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    delete?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    update?: NodeUpdateWithWhereUniqueWithoutNodeTypeInput | NodeUpdateWithWhereUniqueWithoutNodeTypeInput[]
    updateMany?: NodeUpdateManyWithWhereWithoutNodeTypeInput | NodeUpdateManyWithWhereWithoutNodeTypeInput[]
    deleteMany?: NodeScalarWhereInput | NodeScalarWhereInput[]
  }

  export type NodeUncheckedUpdateManyWithoutNodeTypeNestedInput = {
    create?: XOR<NodeCreateWithoutNodeTypeInput, NodeUncheckedCreateWithoutNodeTypeInput> | NodeCreateWithoutNodeTypeInput[] | NodeUncheckedCreateWithoutNodeTypeInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutNodeTypeInput | NodeCreateOrConnectWithoutNodeTypeInput[]
    upsert?: NodeUpsertWithWhereUniqueWithoutNodeTypeInput | NodeUpsertWithWhereUniqueWithoutNodeTypeInput[]
    createMany?: NodeCreateManyNodeTypeInputEnvelope
    set?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    disconnect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    delete?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    update?: NodeUpdateWithWhereUniqueWithoutNodeTypeInput | NodeUpdateWithWhereUniqueWithoutNodeTypeInput[]
    updateMany?: NodeUpdateManyWithWhereWithoutNodeTypeInput | NodeUpdateManyWithWhereWithoutNodeTypeInput[]
    deleteMany?: NodeScalarWhereInput | NodeScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutNodesInput = {
    create?: XOR<OrganizationCreateWithoutNodesInput, OrganizationUncheckedCreateWithoutNodesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutNodesInput
    connect?: OrganizationWhereUniqueInput
  }

  export type NodeTypeCreateNestedOneWithoutNodesInput = {
    create?: XOR<NodeTypeCreateWithoutNodesInput, NodeTypeUncheckedCreateWithoutNodesInput>
    connectOrCreate?: NodeTypeCreateOrConnectWithoutNodesInput
    connect?: NodeTypeWhereUniqueInput
  }

  export type NodeCreateNestedOneWithoutChildrenInput = {
    create?: XOR<NodeCreateWithoutChildrenInput, NodeUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: NodeCreateOrConnectWithoutChildrenInput
    connect?: NodeWhereUniqueInput
  }

  export type NodeCreateNestedManyWithoutParentInput = {
    create?: XOR<NodeCreateWithoutParentInput, NodeUncheckedCreateWithoutParentInput> | NodeCreateWithoutParentInput[] | NodeUncheckedCreateWithoutParentInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutParentInput | NodeCreateOrConnectWithoutParentInput[]
    createMany?: NodeCreateManyParentInputEnvelope
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutOwnedNodesInput = {
    create?: XOR<UserCreateWithoutOwnedNodesInput, UserUncheckedCreateWithoutOwnedNodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedNodesInput
    connect?: UserWhereUniqueInput
  }

  export type NodeAssignmentCreateNestedManyWithoutNodeInput = {
    create?: XOR<NodeAssignmentCreateWithoutNodeInput, NodeAssignmentUncheckedCreateWithoutNodeInput> | NodeAssignmentCreateWithoutNodeInput[] | NodeAssignmentUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: NodeAssignmentCreateOrConnectWithoutNodeInput | NodeAssignmentCreateOrConnectWithoutNodeInput[]
    createMany?: NodeAssignmentCreateManyNodeInputEnvelope
    connect?: NodeAssignmentWhereUniqueInput | NodeAssignmentWhereUniqueInput[]
  }

  export type NodeDependencyCreateNestedManyWithoutDependsOnNodeInput = {
    create?: XOR<NodeDependencyCreateWithoutDependsOnNodeInput, NodeDependencyUncheckedCreateWithoutDependsOnNodeInput> | NodeDependencyCreateWithoutDependsOnNodeInput[] | NodeDependencyUncheckedCreateWithoutDependsOnNodeInput[]
    connectOrCreate?: NodeDependencyCreateOrConnectWithoutDependsOnNodeInput | NodeDependencyCreateOrConnectWithoutDependsOnNodeInput[]
    createMany?: NodeDependencyCreateManyDependsOnNodeInputEnvelope
    connect?: NodeDependencyWhereUniqueInput | NodeDependencyWhereUniqueInput[]
  }

  export type NodeDependencyCreateNestedManyWithoutBlockedNodeInput = {
    create?: XOR<NodeDependencyCreateWithoutBlockedNodeInput, NodeDependencyUncheckedCreateWithoutBlockedNodeInput> | NodeDependencyCreateWithoutBlockedNodeInput[] | NodeDependencyUncheckedCreateWithoutBlockedNodeInput[]
    connectOrCreate?: NodeDependencyCreateOrConnectWithoutBlockedNodeInput | NodeDependencyCreateOrConnectWithoutBlockedNodeInput[]
    createMany?: NodeDependencyCreateManyBlockedNodeInputEnvelope
    connect?: NodeDependencyWhereUniqueInput | NodeDependencyWhereUniqueInput[]
  }

  export type KpiDefinitionCreateNestedManyWithoutPrimaryNodeInput = {
    create?: XOR<KpiDefinitionCreateWithoutPrimaryNodeInput, KpiDefinitionUncheckedCreateWithoutPrimaryNodeInput> | KpiDefinitionCreateWithoutPrimaryNodeInput[] | KpiDefinitionUncheckedCreateWithoutPrimaryNodeInput[]
    connectOrCreate?: KpiDefinitionCreateOrConnectWithoutPrimaryNodeInput | KpiDefinitionCreateOrConnectWithoutPrimaryNodeInput[]
    createMany?: KpiDefinitionCreateManyPrimaryNodeInputEnvelope
    connect?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
  }

  export type NodeUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<NodeCreateWithoutParentInput, NodeUncheckedCreateWithoutParentInput> | NodeCreateWithoutParentInput[] | NodeUncheckedCreateWithoutParentInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutParentInput | NodeCreateOrConnectWithoutParentInput[]
    createMany?: NodeCreateManyParentInputEnvelope
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
  }

  export type NodeAssignmentUncheckedCreateNestedManyWithoutNodeInput = {
    create?: XOR<NodeAssignmentCreateWithoutNodeInput, NodeAssignmentUncheckedCreateWithoutNodeInput> | NodeAssignmentCreateWithoutNodeInput[] | NodeAssignmentUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: NodeAssignmentCreateOrConnectWithoutNodeInput | NodeAssignmentCreateOrConnectWithoutNodeInput[]
    createMany?: NodeAssignmentCreateManyNodeInputEnvelope
    connect?: NodeAssignmentWhereUniqueInput | NodeAssignmentWhereUniqueInput[]
  }

  export type NodeDependencyUncheckedCreateNestedManyWithoutDependsOnNodeInput = {
    create?: XOR<NodeDependencyCreateWithoutDependsOnNodeInput, NodeDependencyUncheckedCreateWithoutDependsOnNodeInput> | NodeDependencyCreateWithoutDependsOnNodeInput[] | NodeDependencyUncheckedCreateWithoutDependsOnNodeInput[]
    connectOrCreate?: NodeDependencyCreateOrConnectWithoutDependsOnNodeInput | NodeDependencyCreateOrConnectWithoutDependsOnNodeInput[]
    createMany?: NodeDependencyCreateManyDependsOnNodeInputEnvelope
    connect?: NodeDependencyWhereUniqueInput | NodeDependencyWhereUniqueInput[]
  }

  export type NodeDependencyUncheckedCreateNestedManyWithoutBlockedNodeInput = {
    create?: XOR<NodeDependencyCreateWithoutBlockedNodeInput, NodeDependencyUncheckedCreateWithoutBlockedNodeInput> | NodeDependencyCreateWithoutBlockedNodeInput[] | NodeDependencyUncheckedCreateWithoutBlockedNodeInput[]
    connectOrCreate?: NodeDependencyCreateOrConnectWithoutBlockedNodeInput | NodeDependencyCreateOrConnectWithoutBlockedNodeInput[]
    createMany?: NodeDependencyCreateManyBlockedNodeInputEnvelope
    connect?: NodeDependencyWhereUniqueInput | NodeDependencyWhereUniqueInput[]
  }

  export type KpiDefinitionUncheckedCreateNestedManyWithoutPrimaryNodeInput = {
    create?: XOR<KpiDefinitionCreateWithoutPrimaryNodeInput, KpiDefinitionUncheckedCreateWithoutPrimaryNodeInput> | KpiDefinitionCreateWithoutPrimaryNodeInput[] | KpiDefinitionUncheckedCreateWithoutPrimaryNodeInput[]
    connectOrCreate?: KpiDefinitionCreateOrConnectWithoutPrimaryNodeInput | KpiDefinitionCreateOrConnectWithoutPrimaryNodeInput[]
    createMany?: KpiDefinitionCreateManyPrimaryNodeInputEnvelope
    connect?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type OrganizationUpdateOneRequiredWithoutNodesNestedInput = {
    create?: XOR<OrganizationCreateWithoutNodesInput, OrganizationUncheckedCreateWithoutNodesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutNodesInput
    upsert?: OrganizationUpsertWithoutNodesInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutNodesInput, OrganizationUpdateWithoutNodesInput>, OrganizationUncheckedUpdateWithoutNodesInput>
  }

  export type NodeTypeUpdateOneRequiredWithoutNodesNestedInput = {
    create?: XOR<NodeTypeCreateWithoutNodesInput, NodeTypeUncheckedCreateWithoutNodesInput>
    connectOrCreate?: NodeTypeCreateOrConnectWithoutNodesInput
    upsert?: NodeTypeUpsertWithoutNodesInput
    connect?: NodeTypeWhereUniqueInput
    update?: XOR<XOR<NodeTypeUpdateToOneWithWhereWithoutNodesInput, NodeTypeUpdateWithoutNodesInput>, NodeTypeUncheckedUpdateWithoutNodesInput>
  }

  export type NodeUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<NodeCreateWithoutChildrenInput, NodeUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: NodeCreateOrConnectWithoutChildrenInput
    upsert?: NodeUpsertWithoutChildrenInput
    disconnect?: NodeWhereInput | boolean
    delete?: NodeWhereInput | boolean
    connect?: NodeWhereUniqueInput
    update?: XOR<XOR<NodeUpdateToOneWithWhereWithoutChildrenInput, NodeUpdateWithoutChildrenInput>, NodeUncheckedUpdateWithoutChildrenInput>
  }

  export type NodeUpdateManyWithoutParentNestedInput = {
    create?: XOR<NodeCreateWithoutParentInput, NodeUncheckedCreateWithoutParentInput> | NodeCreateWithoutParentInput[] | NodeUncheckedCreateWithoutParentInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutParentInput | NodeCreateOrConnectWithoutParentInput[]
    upsert?: NodeUpsertWithWhereUniqueWithoutParentInput | NodeUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: NodeCreateManyParentInputEnvelope
    set?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    disconnect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    delete?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    update?: NodeUpdateWithWhereUniqueWithoutParentInput | NodeUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: NodeUpdateManyWithWhereWithoutParentInput | NodeUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: NodeScalarWhereInput | NodeScalarWhereInput[]
  }

  export type UserUpdateOneWithoutOwnedNodesNestedInput = {
    create?: XOR<UserCreateWithoutOwnedNodesInput, UserUncheckedCreateWithoutOwnedNodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedNodesInput
    upsert?: UserUpsertWithoutOwnedNodesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedNodesInput, UserUpdateWithoutOwnedNodesInput>, UserUncheckedUpdateWithoutOwnedNodesInput>
  }

  export type NodeAssignmentUpdateManyWithoutNodeNestedInput = {
    create?: XOR<NodeAssignmentCreateWithoutNodeInput, NodeAssignmentUncheckedCreateWithoutNodeInput> | NodeAssignmentCreateWithoutNodeInput[] | NodeAssignmentUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: NodeAssignmentCreateOrConnectWithoutNodeInput | NodeAssignmentCreateOrConnectWithoutNodeInput[]
    upsert?: NodeAssignmentUpsertWithWhereUniqueWithoutNodeInput | NodeAssignmentUpsertWithWhereUniqueWithoutNodeInput[]
    createMany?: NodeAssignmentCreateManyNodeInputEnvelope
    set?: NodeAssignmentWhereUniqueInput | NodeAssignmentWhereUniqueInput[]
    disconnect?: NodeAssignmentWhereUniqueInput | NodeAssignmentWhereUniqueInput[]
    delete?: NodeAssignmentWhereUniqueInput | NodeAssignmentWhereUniqueInput[]
    connect?: NodeAssignmentWhereUniqueInput | NodeAssignmentWhereUniqueInput[]
    update?: NodeAssignmentUpdateWithWhereUniqueWithoutNodeInput | NodeAssignmentUpdateWithWhereUniqueWithoutNodeInput[]
    updateMany?: NodeAssignmentUpdateManyWithWhereWithoutNodeInput | NodeAssignmentUpdateManyWithWhereWithoutNodeInput[]
    deleteMany?: NodeAssignmentScalarWhereInput | NodeAssignmentScalarWhereInput[]
  }

  export type NodeDependencyUpdateManyWithoutDependsOnNodeNestedInput = {
    create?: XOR<NodeDependencyCreateWithoutDependsOnNodeInput, NodeDependencyUncheckedCreateWithoutDependsOnNodeInput> | NodeDependencyCreateWithoutDependsOnNodeInput[] | NodeDependencyUncheckedCreateWithoutDependsOnNodeInput[]
    connectOrCreate?: NodeDependencyCreateOrConnectWithoutDependsOnNodeInput | NodeDependencyCreateOrConnectWithoutDependsOnNodeInput[]
    upsert?: NodeDependencyUpsertWithWhereUniqueWithoutDependsOnNodeInput | NodeDependencyUpsertWithWhereUniqueWithoutDependsOnNodeInput[]
    createMany?: NodeDependencyCreateManyDependsOnNodeInputEnvelope
    set?: NodeDependencyWhereUniqueInput | NodeDependencyWhereUniqueInput[]
    disconnect?: NodeDependencyWhereUniqueInput | NodeDependencyWhereUniqueInput[]
    delete?: NodeDependencyWhereUniqueInput | NodeDependencyWhereUniqueInput[]
    connect?: NodeDependencyWhereUniqueInput | NodeDependencyWhereUniqueInput[]
    update?: NodeDependencyUpdateWithWhereUniqueWithoutDependsOnNodeInput | NodeDependencyUpdateWithWhereUniqueWithoutDependsOnNodeInput[]
    updateMany?: NodeDependencyUpdateManyWithWhereWithoutDependsOnNodeInput | NodeDependencyUpdateManyWithWhereWithoutDependsOnNodeInput[]
    deleteMany?: NodeDependencyScalarWhereInput | NodeDependencyScalarWhereInput[]
  }

  export type NodeDependencyUpdateManyWithoutBlockedNodeNestedInput = {
    create?: XOR<NodeDependencyCreateWithoutBlockedNodeInput, NodeDependencyUncheckedCreateWithoutBlockedNodeInput> | NodeDependencyCreateWithoutBlockedNodeInput[] | NodeDependencyUncheckedCreateWithoutBlockedNodeInput[]
    connectOrCreate?: NodeDependencyCreateOrConnectWithoutBlockedNodeInput | NodeDependencyCreateOrConnectWithoutBlockedNodeInput[]
    upsert?: NodeDependencyUpsertWithWhereUniqueWithoutBlockedNodeInput | NodeDependencyUpsertWithWhereUniqueWithoutBlockedNodeInput[]
    createMany?: NodeDependencyCreateManyBlockedNodeInputEnvelope
    set?: NodeDependencyWhereUniqueInput | NodeDependencyWhereUniqueInput[]
    disconnect?: NodeDependencyWhereUniqueInput | NodeDependencyWhereUniqueInput[]
    delete?: NodeDependencyWhereUniqueInput | NodeDependencyWhereUniqueInput[]
    connect?: NodeDependencyWhereUniqueInput | NodeDependencyWhereUniqueInput[]
    update?: NodeDependencyUpdateWithWhereUniqueWithoutBlockedNodeInput | NodeDependencyUpdateWithWhereUniqueWithoutBlockedNodeInput[]
    updateMany?: NodeDependencyUpdateManyWithWhereWithoutBlockedNodeInput | NodeDependencyUpdateManyWithWhereWithoutBlockedNodeInput[]
    deleteMany?: NodeDependencyScalarWhereInput | NodeDependencyScalarWhereInput[]
  }

  export type KpiDefinitionUpdateManyWithoutPrimaryNodeNestedInput = {
    create?: XOR<KpiDefinitionCreateWithoutPrimaryNodeInput, KpiDefinitionUncheckedCreateWithoutPrimaryNodeInput> | KpiDefinitionCreateWithoutPrimaryNodeInput[] | KpiDefinitionUncheckedCreateWithoutPrimaryNodeInput[]
    connectOrCreate?: KpiDefinitionCreateOrConnectWithoutPrimaryNodeInput | KpiDefinitionCreateOrConnectWithoutPrimaryNodeInput[]
    upsert?: KpiDefinitionUpsertWithWhereUniqueWithoutPrimaryNodeInput | KpiDefinitionUpsertWithWhereUniqueWithoutPrimaryNodeInput[]
    createMany?: KpiDefinitionCreateManyPrimaryNodeInputEnvelope
    set?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    disconnect?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    delete?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    connect?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    update?: KpiDefinitionUpdateWithWhereUniqueWithoutPrimaryNodeInput | KpiDefinitionUpdateWithWhereUniqueWithoutPrimaryNodeInput[]
    updateMany?: KpiDefinitionUpdateManyWithWhereWithoutPrimaryNodeInput | KpiDefinitionUpdateManyWithWhereWithoutPrimaryNodeInput[]
    deleteMany?: KpiDefinitionScalarWhereInput | KpiDefinitionScalarWhereInput[]
  }

  export type NodeUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<NodeCreateWithoutParentInput, NodeUncheckedCreateWithoutParentInput> | NodeCreateWithoutParentInput[] | NodeUncheckedCreateWithoutParentInput[]
    connectOrCreate?: NodeCreateOrConnectWithoutParentInput | NodeCreateOrConnectWithoutParentInput[]
    upsert?: NodeUpsertWithWhereUniqueWithoutParentInput | NodeUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: NodeCreateManyParentInputEnvelope
    set?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    disconnect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    delete?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]
    update?: NodeUpdateWithWhereUniqueWithoutParentInput | NodeUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: NodeUpdateManyWithWhereWithoutParentInput | NodeUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: NodeScalarWhereInput | NodeScalarWhereInput[]
  }

  export type NodeAssignmentUncheckedUpdateManyWithoutNodeNestedInput = {
    create?: XOR<NodeAssignmentCreateWithoutNodeInput, NodeAssignmentUncheckedCreateWithoutNodeInput> | NodeAssignmentCreateWithoutNodeInput[] | NodeAssignmentUncheckedCreateWithoutNodeInput[]
    connectOrCreate?: NodeAssignmentCreateOrConnectWithoutNodeInput | NodeAssignmentCreateOrConnectWithoutNodeInput[]
    upsert?: NodeAssignmentUpsertWithWhereUniqueWithoutNodeInput | NodeAssignmentUpsertWithWhereUniqueWithoutNodeInput[]
    createMany?: NodeAssignmentCreateManyNodeInputEnvelope
    set?: NodeAssignmentWhereUniqueInput | NodeAssignmentWhereUniqueInput[]
    disconnect?: NodeAssignmentWhereUniqueInput | NodeAssignmentWhereUniqueInput[]
    delete?: NodeAssignmentWhereUniqueInput | NodeAssignmentWhereUniqueInput[]
    connect?: NodeAssignmentWhereUniqueInput | NodeAssignmentWhereUniqueInput[]
    update?: NodeAssignmentUpdateWithWhereUniqueWithoutNodeInput | NodeAssignmentUpdateWithWhereUniqueWithoutNodeInput[]
    updateMany?: NodeAssignmentUpdateManyWithWhereWithoutNodeInput | NodeAssignmentUpdateManyWithWhereWithoutNodeInput[]
    deleteMany?: NodeAssignmentScalarWhereInput | NodeAssignmentScalarWhereInput[]
  }

  export type NodeDependencyUncheckedUpdateManyWithoutDependsOnNodeNestedInput = {
    create?: XOR<NodeDependencyCreateWithoutDependsOnNodeInput, NodeDependencyUncheckedCreateWithoutDependsOnNodeInput> | NodeDependencyCreateWithoutDependsOnNodeInput[] | NodeDependencyUncheckedCreateWithoutDependsOnNodeInput[]
    connectOrCreate?: NodeDependencyCreateOrConnectWithoutDependsOnNodeInput | NodeDependencyCreateOrConnectWithoutDependsOnNodeInput[]
    upsert?: NodeDependencyUpsertWithWhereUniqueWithoutDependsOnNodeInput | NodeDependencyUpsertWithWhereUniqueWithoutDependsOnNodeInput[]
    createMany?: NodeDependencyCreateManyDependsOnNodeInputEnvelope
    set?: NodeDependencyWhereUniqueInput | NodeDependencyWhereUniqueInput[]
    disconnect?: NodeDependencyWhereUniqueInput | NodeDependencyWhereUniqueInput[]
    delete?: NodeDependencyWhereUniqueInput | NodeDependencyWhereUniqueInput[]
    connect?: NodeDependencyWhereUniqueInput | NodeDependencyWhereUniqueInput[]
    update?: NodeDependencyUpdateWithWhereUniqueWithoutDependsOnNodeInput | NodeDependencyUpdateWithWhereUniqueWithoutDependsOnNodeInput[]
    updateMany?: NodeDependencyUpdateManyWithWhereWithoutDependsOnNodeInput | NodeDependencyUpdateManyWithWhereWithoutDependsOnNodeInput[]
    deleteMany?: NodeDependencyScalarWhereInput | NodeDependencyScalarWhereInput[]
  }

  export type NodeDependencyUncheckedUpdateManyWithoutBlockedNodeNestedInput = {
    create?: XOR<NodeDependencyCreateWithoutBlockedNodeInput, NodeDependencyUncheckedCreateWithoutBlockedNodeInput> | NodeDependencyCreateWithoutBlockedNodeInput[] | NodeDependencyUncheckedCreateWithoutBlockedNodeInput[]
    connectOrCreate?: NodeDependencyCreateOrConnectWithoutBlockedNodeInput | NodeDependencyCreateOrConnectWithoutBlockedNodeInput[]
    upsert?: NodeDependencyUpsertWithWhereUniqueWithoutBlockedNodeInput | NodeDependencyUpsertWithWhereUniqueWithoutBlockedNodeInput[]
    createMany?: NodeDependencyCreateManyBlockedNodeInputEnvelope
    set?: NodeDependencyWhereUniqueInput | NodeDependencyWhereUniqueInput[]
    disconnect?: NodeDependencyWhereUniqueInput | NodeDependencyWhereUniqueInput[]
    delete?: NodeDependencyWhereUniqueInput | NodeDependencyWhereUniqueInput[]
    connect?: NodeDependencyWhereUniqueInput | NodeDependencyWhereUniqueInput[]
    update?: NodeDependencyUpdateWithWhereUniqueWithoutBlockedNodeInput | NodeDependencyUpdateWithWhereUniqueWithoutBlockedNodeInput[]
    updateMany?: NodeDependencyUpdateManyWithWhereWithoutBlockedNodeInput | NodeDependencyUpdateManyWithWhereWithoutBlockedNodeInput[]
    deleteMany?: NodeDependencyScalarWhereInput | NodeDependencyScalarWhereInput[]
  }

  export type KpiDefinitionUncheckedUpdateManyWithoutPrimaryNodeNestedInput = {
    create?: XOR<KpiDefinitionCreateWithoutPrimaryNodeInput, KpiDefinitionUncheckedCreateWithoutPrimaryNodeInput> | KpiDefinitionCreateWithoutPrimaryNodeInput[] | KpiDefinitionUncheckedCreateWithoutPrimaryNodeInput[]
    connectOrCreate?: KpiDefinitionCreateOrConnectWithoutPrimaryNodeInput | KpiDefinitionCreateOrConnectWithoutPrimaryNodeInput[]
    upsert?: KpiDefinitionUpsertWithWhereUniqueWithoutPrimaryNodeInput | KpiDefinitionUpsertWithWhereUniqueWithoutPrimaryNodeInput[]
    createMany?: KpiDefinitionCreateManyPrimaryNodeInputEnvelope
    set?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    disconnect?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    delete?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    connect?: KpiDefinitionWhereUniqueInput | KpiDefinitionWhereUniqueInput[]
    update?: KpiDefinitionUpdateWithWhereUniqueWithoutPrimaryNodeInput | KpiDefinitionUpdateWithWhereUniqueWithoutPrimaryNodeInput[]
    updateMany?: KpiDefinitionUpdateManyWithWhereWithoutPrimaryNodeInput | KpiDefinitionUpdateManyWithWhereWithoutPrimaryNodeInput[]
    deleteMany?: KpiDefinitionScalarWhereInput | KpiDefinitionScalarWhereInput[]
  }

  export type NodeCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<NodeCreateWithoutAssignmentsInput, NodeUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: NodeCreateOrConnectWithoutAssignmentsInput
    connect?: NodeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNodeAssignmentsInput = {
    create?: XOR<UserCreateWithoutNodeAssignmentsInput, UserUncheckedCreateWithoutNodeAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNodeAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNodeAssignmentRoleFieldUpdateOperationsInput = {
    set?: $Enums.NodeAssignmentRole
  }

  export type NodeUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<NodeCreateWithoutAssignmentsInput, NodeUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: NodeCreateOrConnectWithoutAssignmentsInput
    upsert?: NodeUpsertWithoutAssignmentsInput
    connect?: NodeWhereUniqueInput
    update?: XOR<XOR<NodeUpdateToOneWithWhereWithoutAssignmentsInput, NodeUpdateWithoutAssignmentsInput>, NodeUncheckedUpdateWithoutAssignmentsInput>
  }

  export type UserUpdateOneRequiredWithoutNodeAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutNodeAssignmentsInput, UserUncheckedCreateWithoutNodeAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNodeAssignmentsInput
    upsert?: UserUpsertWithoutNodeAssignmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNodeAssignmentsInput, UserUpdateWithoutNodeAssignmentsInput>, UserUncheckedUpdateWithoutNodeAssignmentsInput>
  }

  export type NodeCreateNestedOneWithoutIncomingDepsInput = {
    create?: XOR<NodeCreateWithoutIncomingDepsInput, NodeUncheckedCreateWithoutIncomingDepsInput>
    connectOrCreate?: NodeCreateOrConnectWithoutIncomingDepsInput
    connect?: NodeWhereUniqueInput
  }

  export type NodeCreateNestedOneWithoutOutgoingDepsInput = {
    create?: XOR<NodeCreateWithoutOutgoingDepsInput, NodeUncheckedCreateWithoutOutgoingDepsInput>
    connectOrCreate?: NodeCreateOrConnectWithoutOutgoingDepsInput
    connect?: NodeWhereUniqueInput
  }

  export type NodeUpdateOneRequiredWithoutIncomingDepsNestedInput = {
    create?: XOR<NodeCreateWithoutIncomingDepsInput, NodeUncheckedCreateWithoutIncomingDepsInput>
    connectOrCreate?: NodeCreateOrConnectWithoutIncomingDepsInput
    upsert?: NodeUpsertWithoutIncomingDepsInput
    connect?: NodeWhereUniqueInput
    update?: XOR<XOR<NodeUpdateToOneWithWhereWithoutIncomingDepsInput, NodeUpdateWithoutIncomingDepsInput>, NodeUncheckedUpdateWithoutIncomingDepsInput>
  }

  export type NodeUpdateOneRequiredWithoutOutgoingDepsNestedInput = {
    create?: XOR<NodeCreateWithoutOutgoingDepsInput, NodeUncheckedCreateWithoutOutgoingDepsInput>
    connectOrCreate?: NodeCreateOrConnectWithoutOutgoingDepsInput
    upsert?: NodeUpsertWithoutOutgoingDepsInput
    connect?: NodeWhereUniqueInput
    update?: XOR<XOR<NodeUpdateToOneWithWhereWithoutOutgoingDepsInput, NodeUpdateWithoutOutgoingDepsInput>, NodeUncheckedUpdateWithoutOutgoingDepsInput>
  }

  export type OrganizationCreateNestedOneWithoutKpisInput = {
    create?: XOR<OrganizationCreateWithoutKpisInput, OrganizationUncheckedCreateWithoutKpisInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutKpisInput
    connect?: OrganizationWhereUniqueInput
  }

  export type NodeCreateNestedOneWithoutKpisInput = {
    create?: XOR<NodeCreateWithoutKpisInput, NodeUncheckedCreateWithoutKpisInput>
    connectOrCreate?: NodeCreateOrConnectWithoutKpisInput
    connect?: NodeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedKpisInput = {
    create?: XOR<UserCreateWithoutOwnedKpisInput, UserUncheckedCreateWithoutOwnedKpisInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedKpisInput
    connect?: UserWhereUniqueInput
  }

  export type KpiVariableCreateNestedManyWithoutKpiInput = {
    create?: XOR<KpiVariableCreateWithoutKpiInput, KpiVariableUncheckedCreateWithoutKpiInput> | KpiVariableCreateWithoutKpiInput[] | KpiVariableUncheckedCreateWithoutKpiInput[]
    connectOrCreate?: KpiVariableCreateOrConnectWithoutKpiInput | KpiVariableCreateOrConnectWithoutKpiInput[]
    createMany?: KpiVariableCreateManyKpiInputEnvelope
    connect?: KpiVariableWhereUniqueInput | KpiVariableWhereUniqueInput[]
  }

  export type KpiValuePeriodCreateNestedManyWithoutKpiInput = {
    create?: XOR<KpiValuePeriodCreateWithoutKpiInput, KpiValuePeriodUncheckedCreateWithoutKpiInput> | KpiValuePeriodCreateWithoutKpiInput[] | KpiValuePeriodUncheckedCreateWithoutKpiInput[]
    connectOrCreate?: KpiValuePeriodCreateOrConnectWithoutKpiInput | KpiValuePeriodCreateOrConnectWithoutKpiInput[]
    createMany?: KpiValuePeriodCreateManyKpiInputEnvelope
    connect?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
  }

  export type KpiVariableUncheckedCreateNestedManyWithoutKpiInput = {
    create?: XOR<KpiVariableCreateWithoutKpiInput, KpiVariableUncheckedCreateWithoutKpiInput> | KpiVariableCreateWithoutKpiInput[] | KpiVariableUncheckedCreateWithoutKpiInput[]
    connectOrCreate?: KpiVariableCreateOrConnectWithoutKpiInput | KpiVariableCreateOrConnectWithoutKpiInput[]
    createMany?: KpiVariableCreateManyKpiInputEnvelope
    connect?: KpiVariableWhereUniqueInput | KpiVariableWhereUniqueInput[]
  }

  export type KpiValuePeriodUncheckedCreateNestedManyWithoutKpiInput = {
    create?: XOR<KpiValuePeriodCreateWithoutKpiInput, KpiValuePeriodUncheckedCreateWithoutKpiInput> | KpiValuePeriodCreateWithoutKpiInput[] | KpiValuePeriodUncheckedCreateWithoutKpiInput[]
    connectOrCreate?: KpiValuePeriodCreateOrConnectWithoutKpiInput | KpiValuePeriodCreateOrConnectWithoutKpiInput[]
    createMany?: KpiValuePeriodCreateManyKpiInputEnvelope
    connect?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
  }

  export type EnumKpiDirectionFieldUpdateOperationsInput = {
    set?: $Enums.KpiDirection
  }

  export type EnumKpiAggregationMethodFieldUpdateOperationsInput = {
    set?: $Enums.KpiAggregationMethod
  }

  export type EnumKpiPeriodTypeFieldUpdateOperationsInput = {
    set?: $Enums.KpiPeriodType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumKpiDefinitionStatusFieldUpdateOperationsInput = {
    set?: $Enums.KpiDefinitionStatus
  }

  export type OrganizationUpdateOneRequiredWithoutKpisNestedInput = {
    create?: XOR<OrganizationCreateWithoutKpisInput, OrganizationUncheckedCreateWithoutKpisInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutKpisInput
    upsert?: OrganizationUpsertWithoutKpisInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutKpisInput, OrganizationUpdateWithoutKpisInput>, OrganizationUncheckedUpdateWithoutKpisInput>
  }

  export type NodeUpdateOneRequiredWithoutKpisNestedInput = {
    create?: XOR<NodeCreateWithoutKpisInput, NodeUncheckedCreateWithoutKpisInput>
    connectOrCreate?: NodeCreateOrConnectWithoutKpisInput
    upsert?: NodeUpsertWithoutKpisInput
    connect?: NodeWhereUniqueInput
    update?: XOR<XOR<NodeUpdateToOneWithWhereWithoutKpisInput, NodeUpdateWithoutKpisInput>, NodeUncheckedUpdateWithoutKpisInput>
  }

  export type UserUpdateOneWithoutOwnedKpisNestedInput = {
    create?: XOR<UserCreateWithoutOwnedKpisInput, UserUncheckedCreateWithoutOwnedKpisInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedKpisInput
    upsert?: UserUpsertWithoutOwnedKpisInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedKpisInput, UserUpdateWithoutOwnedKpisInput>, UserUncheckedUpdateWithoutOwnedKpisInput>
  }

  export type KpiVariableUpdateManyWithoutKpiNestedInput = {
    create?: XOR<KpiVariableCreateWithoutKpiInput, KpiVariableUncheckedCreateWithoutKpiInput> | KpiVariableCreateWithoutKpiInput[] | KpiVariableUncheckedCreateWithoutKpiInput[]
    connectOrCreate?: KpiVariableCreateOrConnectWithoutKpiInput | KpiVariableCreateOrConnectWithoutKpiInput[]
    upsert?: KpiVariableUpsertWithWhereUniqueWithoutKpiInput | KpiVariableUpsertWithWhereUniqueWithoutKpiInput[]
    createMany?: KpiVariableCreateManyKpiInputEnvelope
    set?: KpiVariableWhereUniqueInput | KpiVariableWhereUniqueInput[]
    disconnect?: KpiVariableWhereUniqueInput | KpiVariableWhereUniqueInput[]
    delete?: KpiVariableWhereUniqueInput | KpiVariableWhereUniqueInput[]
    connect?: KpiVariableWhereUniqueInput | KpiVariableWhereUniqueInput[]
    update?: KpiVariableUpdateWithWhereUniqueWithoutKpiInput | KpiVariableUpdateWithWhereUniqueWithoutKpiInput[]
    updateMany?: KpiVariableUpdateManyWithWhereWithoutKpiInput | KpiVariableUpdateManyWithWhereWithoutKpiInput[]
    deleteMany?: KpiVariableScalarWhereInput | KpiVariableScalarWhereInput[]
  }

  export type KpiValuePeriodUpdateManyWithoutKpiNestedInput = {
    create?: XOR<KpiValuePeriodCreateWithoutKpiInput, KpiValuePeriodUncheckedCreateWithoutKpiInput> | KpiValuePeriodCreateWithoutKpiInput[] | KpiValuePeriodUncheckedCreateWithoutKpiInput[]
    connectOrCreate?: KpiValuePeriodCreateOrConnectWithoutKpiInput | KpiValuePeriodCreateOrConnectWithoutKpiInput[]
    upsert?: KpiValuePeriodUpsertWithWhereUniqueWithoutKpiInput | KpiValuePeriodUpsertWithWhereUniqueWithoutKpiInput[]
    createMany?: KpiValuePeriodCreateManyKpiInputEnvelope
    set?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    disconnect?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    delete?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    connect?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    update?: KpiValuePeriodUpdateWithWhereUniqueWithoutKpiInput | KpiValuePeriodUpdateWithWhereUniqueWithoutKpiInput[]
    updateMany?: KpiValuePeriodUpdateManyWithWhereWithoutKpiInput | KpiValuePeriodUpdateManyWithWhereWithoutKpiInput[]
    deleteMany?: KpiValuePeriodScalarWhereInput | KpiValuePeriodScalarWhereInput[]
  }

  export type KpiVariableUncheckedUpdateManyWithoutKpiNestedInput = {
    create?: XOR<KpiVariableCreateWithoutKpiInput, KpiVariableUncheckedCreateWithoutKpiInput> | KpiVariableCreateWithoutKpiInput[] | KpiVariableUncheckedCreateWithoutKpiInput[]
    connectOrCreate?: KpiVariableCreateOrConnectWithoutKpiInput | KpiVariableCreateOrConnectWithoutKpiInput[]
    upsert?: KpiVariableUpsertWithWhereUniqueWithoutKpiInput | KpiVariableUpsertWithWhereUniqueWithoutKpiInput[]
    createMany?: KpiVariableCreateManyKpiInputEnvelope
    set?: KpiVariableWhereUniqueInput | KpiVariableWhereUniqueInput[]
    disconnect?: KpiVariableWhereUniqueInput | KpiVariableWhereUniqueInput[]
    delete?: KpiVariableWhereUniqueInput | KpiVariableWhereUniqueInput[]
    connect?: KpiVariableWhereUniqueInput | KpiVariableWhereUniqueInput[]
    update?: KpiVariableUpdateWithWhereUniqueWithoutKpiInput | KpiVariableUpdateWithWhereUniqueWithoutKpiInput[]
    updateMany?: KpiVariableUpdateManyWithWhereWithoutKpiInput | KpiVariableUpdateManyWithWhereWithoutKpiInput[]
    deleteMany?: KpiVariableScalarWhereInput | KpiVariableScalarWhereInput[]
  }

  export type KpiValuePeriodUncheckedUpdateManyWithoutKpiNestedInput = {
    create?: XOR<KpiValuePeriodCreateWithoutKpiInput, KpiValuePeriodUncheckedCreateWithoutKpiInput> | KpiValuePeriodCreateWithoutKpiInput[] | KpiValuePeriodUncheckedCreateWithoutKpiInput[]
    connectOrCreate?: KpiValuePeriodCreateOrConnectWithoutKpiInput | KpiValuePeriodCreateOrConnectWithoutKpiInput[]
    upsert?: KpiValuePeriodUpsertWithWhereUniqueWithoutKpiInput | KpiValuePeriodUpsertWithWhereUniqueWithoutKpiInput[]
    createMany?: KpiValuePeriodCreateManyKpiInputEnvelope
    set?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    disconnect?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    delete?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    connect?: KpiValuePeriodWhereUniqueInput | KpiValuePeriodWhereUniqueInput[]
    update?: KpiValuePeriodUpdateWithWhereUniqueWithoutKpiInput | KpiValuePeriodUpdateWithWhereUniqueWithoutKpiInput[]
    updateMany?: KpiValuePeriodUpdateManyWithWhereWithoutKpiInput | KpiValuePeriodUpdateManyWithWhereWithoutKpiInput[]
    deleteMany?: KpiValuePeriodScalarWhereInput | KpiValuePeriodScalarWhereInput[]
  }

  export type KpiDefinitionCreateNestedOneWithoutVariablesInput = {
    create?: XOR<KpiDefinitionCreateWithoutVariablesInput, KpiDefinitionUncheckedCreateWithoutVariablesInput>
    connectOrCreate?: KpiDefinitionCreateOrConnectWithoutVariablesInput
    connect?: KpiDefinitionWhereUniqueInput
  }

  export type KpiVariableValueCreateNestedManyWithoutKpiVariableInput = {
    create?: XOR<KpiVariableValueCreateWithoutKpiVariableInput, KpiVariableValueUncheckedCreateWithoutKpiVariableInput> | KpiVariableValueCreateWithoutKpiVariableInput[] | KpiVariableValueUncheckedCreateWithoutKpiVariableInput[]
    connectOrCreate?: KpiVariableValueCreateOrConnectWithoutKpiVariableInput | KpiVariableValueCreateOrConnectWithoutKpiVariableInput[]
    createMany?: KpiVariableValueCreateManyKpiVariableInputEnvelope
    connect?: KpiVariableValueWhereUniqueInput | KpiVariableValueWhereUniqueInput[]
  }

  export type KpiVariableValueUncheckedCreateNestedManyWithoutKpiVariableInput = {
    create?: XOR<KpiVariableValueCreateWithoutKpiVariableInput, KpiVariableValueUncheckedCreateWithoutKpiVariableInput> | KpiVariableValueCreateWithoutKpiVariableInput[] | KpiVariableValueUncheckedCreateWithoutKpiVariableInput[]
    connectOrCreate?: KpiVariableValueCreateOrConnectWithoutKpiVariableInput | KpiVariableValueCreateOrConnectWithoutKpiVariableInput[]
    createMany?: KpiVariableValueCreateManyKpiVariableInputEnvelope
    connect?: KpiVariableValueWhereUniqueInput | KpiVariableValueWhereUniqueInput[]
  }

  export type EnumKpiVariableDataTypeFieldUpdateOperationsInput = {
    set?: $Enums.KpiVariableDataType
  }

  export type KpiDefinitionUpdateOneRequiredWithoutVariablesNestedInput = {
    create?: XOR<KpiDefinitionCreateWithoutVariablesInput, KpiDefinitionUncheckedCreateWithoutVariablesInput>
    connectOrCreate?: KpiDefinitionCreateOrConnectWithoutVariablesInput
    upsert?: KpiDefinitionUpsertWithoutVariablesInput
    connect?: KpiDefinitionWhereUniqueInput
    update?: XOR<XOR<KpiDefinitionUpdateToOneWithWhereWithoutVariablesInput, KpiDefinitionUpdateWithoutVariablesInput>, KpiDefinitionUncheckedUpdateWithoutVariablesInput>
  }

  export type KpiVariableValueUpdateManyWithoutKpiVariableNestedInput = {
    create?: XOR<KpiVariableValueCreateWithoutKpiVariableInput, KpiVariableValueUncheckedCreateWithoutKpiVariableInput> | KpiVariableValueCreateWithoutKpiVariableInput[] | KpiVariableValueUncheckedCreateWithoutKpiVariableInput[]
    connectOrCreate?: KpiVariableValueCreateOrConnectWithoutKpiVariableInput | KpiVariableValueCreateOrConnectWithoutKpiVariableInput[]
    upsert?: KpiVariableValueUpsertWithWhereUniqueWithoutKpiVariableInput | KpiVariableValueUpsertWithWhereUniqueWithoutKpiVariableInput[]
    createMany?: KpiVariableValueCreateManyKpiVariableInputEnvelope
    set?: KpiVariableValueWhereUniqueInput | KpiVariableValueWhereUniqueInput[]
    disconnect?: KpiVariableValueWhereUniqueInput | KpiVariableValueWhereUniqueInput[]
    delete?: KpiVariableValueWhereUniqueInput | KpiVariableValueWhereUniqueInput[]
    connect?: KpiVariableValueWhereUniqueInput | KpiVariableValueWhereUniqueInput[]
    update?: KpiVariableValueUpdateWithWhereUniqueWithoutKpiVariableInput | KpiVariableValueUpdateWithWhereUniqueWithoutKpiVariableInput[]
    updateMany?: KpiVariableValueUpdateManyWithWhereWithoutKpiVariableInput | KpiVariableValueUpdateManyWithWhereWithoutKpiVariableInput[]
    deleteMany?: KpiVariableValueScalarWhereInput | KpiVariableValueScalarWhereInput[]
  }

  export type KpiVariableValueUncheckedUpdateManyWithoutKpiVariableNestedInput = {
    create?: XOR<KpiVariableValueCreateWithoutKpiVariableInput, KpiVariableValueUncheckedCreateWithoutKpiVariableInput> | KpiVariableValueCreateWithoutKpiVariableInput[] | KpiVariableValueUncheckedCreateWithoutKpiVariableInput[]
    connectOrCreate?: KpiVariableValueCreateOrConnectWithoutKpiVariableInput | KpiVariableValueCreateOrConnectWithoutKpiVariableInput[]
    upsert?: KpiVariableValueUpsertWithWhereUniqueWithoutKpiVariableInput | KpiVariableValueUpsertWithWhereUniqueWithoutKpiVariableInput[]
    createMany?: KpiVariableValueCreateManyKpiVariableInputEnvelope
    set?: KpiVariableValueWhereUniqueInput | KpiVariableValueWhereUniqueInput[]
    disconnect?: KpiVariableValueWhereUniqueInput | KpiVariableValueWhereUniqueInput[]
    delete?: KpiVariableValueWhereUniqueInput | KpiVariableValueWhereUniqueInput[]
    connect?: KpiVariableValueWhereUniqueInput | KpiVariableValueWhereUniqueInput[]
    update?: KpiVariableValueUpdateWithWhereUniqueWithoutKpiVariableInput | KpiVariableValueUpdateWithWhereUniqueWithoutKpiVariableInput[]
    updateMany?: KpiVariableValueUpdateManyWithWhereWithoutKpiVariableInput | KpiVariableValueUpdateManyWithWhereWithoutKpiVariableInput[]
    deleteMany?: KpiVariableValueScalarWhereInput | KpiVariableValueScalarWhereInput[]
  }

  export type KpiDefinitionCreateNestedOneWithoutValuesInput = {
    create?: XOR<KpiDefinitionCreateWithoutValuesInput, KpiDefinitionUncheckedCreateWithoutValuesInput>
    connectOrCreate?: KpiDefinitionCreateOrConnectWithoutValuesInput
    connect?: KpiDefinitionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutKpiValuesEnteredInput = {
    create?: XOR<UserCreateWithoutKpiValuesEnteredInput, UserUncheckedCreateWithoutKpiValuesEnteredInput>
    connectOrCreate?: UserCreateOrConnectWithoutKpiValuesEnteredInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutKpiValuesApprovedInput = {
    create?: XOR<UserCreateWithoutKpiValuesApprovedInput, UserUncheckedCreateWithoutKpiValuesApprovedInput>
    connectOrCreate?: UserCreateOrConnectWithoutKpiValuesApprovedInput
    connect?: UserWhereUniqueInput
  }

  export type KpiVariableValueCreateNestedManyWithoutKpiValueInput = {
    create?: XOR<KpiVariableValueCreateWithoutKpiValueInput, KpiVariableValueUncheckedCreateWithoutKpiValueInput> | KpiVariableValueCreateWithoutKpiValueInput[] | KpiVariableValueUncheckedCreateWithoutKpiValueInput[]
    connectOrCreate?: KpiVariableValueCreateOrConnectWithoutKpiValueInput | KpiVariableValueCreateOrConnectWithoutKpiValueInput[]
    createMany?: KpiVariableValueCreateManyKpiValueInputEnvelope
    connect?: KpiVariableValueWhereUniqueInput | KpiVariableValueWhereUniqueInput[]
  }

  export type KpiVariableValueUncheckedCreateNestedManyWithoutKpiValueInput = {
    create?: XOR<KpiVariableValueCreateWithoutKpiValueInput, KpiVariableValueUncheckedCreateWithoutKpiValueInput> | KpiVariableValueCreateWithoutKpiValueInput[] | KpiVariableValueUncheckedCreateWithoutKpiValueInput[]
    connectOrCreate?: KpiVariableValueCreateOrConnectWithoutKpiValueInput | KpiVariableValueCreateOrConnectWithoutKpiValueInput[]
    createMany?: KpiVariableValueCreateManyKpiValueInputEnvelope
    connect?: KpiVariableValueWhereUniqueInput | KpiVariableValueWhereUniqueInput[]
  }

  export type EnumKpiValueStatusFieldUpdateOperationsInput = {
    set?: $Enums.KpiValueStatus
  }

  export type KpiDefinitionUpdateOneRequiredWithoutValuesNestedInput = {
    create?: XOR<KpiDefinitionCreateWithoutValuesInput, KpiDefinitionUncheckedCreateWithoutValuesInput>
    connectOrCreate?: KpiDefinitionCreateOrConnectWithoutValuesInput
    upsert?: KpiDefinitionUpsertWithoutValuesInput
    connect?: KpiDefinitionWhereUniqueInput
    update?: XOR<XOR<KpiDefinitionUpdateToOneWithWhereWithoutValuesInput, KpiDefinitionUpdateWithoutValuesInput>, KpiDefinitionUncheckedUpdateWithoutValuesInput>
  }

  export type UserUpdateOneWithoutKpiValuesEnteredNestedInput = {
    create?: XOR<UserCreateWithoutKpiValuesEnteredInput, UserUncheckedCreateWithoutKpiValuesEnteredInput>
    connectOrCreate?: UserCreateOrConnectWithoutKpiValuesEnteredInput
    upsert?: UserUpsertWithoutKpiValuesEnteredInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutKpiValuesEnteredInput, UserUpdateWithoutKpiValuesEnteredInput>, UserUncheckedUpdateWithoutKpiValuesEnteredInput>
  }

  export type UserUpdateOneWithoutKpiValuesApprovedNestedInput = {
    create?: XOR<UserCreateWithoutKpiValuesApprovedInput, UserUncheckedCreateWithoutKpiValuesApprovedInput>
    connectOrCreate?: UserCreateOrConnectWithoutKpiValuesApprovedInput
    upsert?: UserUpsertWithoutKpiValuesApprovedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutKpiValuesApprovedInput, UserUpdateWithoutKpiValuesApprovedInput>, UserUncheckedUpdateWithoutKpiValuesApprovedInput>
  }

  export type KpiVariableValueUpdateManyWithoutKpiValueNestedInput = {
    create?: XOR<KpiVariableValueCreateWithoutKpiValueInput, KpiVariableValueUncheckedCreateWithoutKpiValueInput> | KpiVariableValueCreateWithoutKpiValueInput[] | KpiVariableValueUncheckedCreateWithoutKpiValueInput[]
    connectOrCreate?: KpiVariableValueCreateOrConnectWithoutKpiValueInput | KpiVariableValueCreateOrConnectWithoutKpiValueInput[]
    upsert?: KpiVariableValueUpsertWithWhereUniqueWithoutKpiValueInput | KpiVariableValueUpsertWithWhereUniqueWithoutKpiValueInput[]
    createMany?: KpiVariableValueCreateManyKpiValueInputEnvelope
    set?: KpiVariableValueWhereUniqueInput | KpiVariableValueWhereUniqueInput[]
    disconnect?: KpiVariableValueWhereUniqueInput | KpiVariableValueWhereUniqueInput[]
    delete?: KpiVariableValueWhereUniqueInput | KpiVariableValueWhereUniqueInput[]
    connect?: KpiVariableValueWhereUniqueInput | KpiVariableValueWhereUniqueInput[]
    update?: KpiVariableValueUpdateWithWhereUniqueWithoutKpiValueInput | KpiVariableValueUpdateWithWhereUniqueWithoutKpiValueInput[]
    updateMany?: KpiVariableValueUpdateManyWithWhereWithoutKpiValueInput | KpiVariableValueUpdateManyWithWhereWithoutKpiValueInput[]
    deleteMany?: KpiVariableValueScalarWhereInput | KpiVariableValueScalarWhereInput[]
  }

  export type KpiVariableValueUncheckedUpdateManyWithoutKpiValueNestedInput = {
    create?: XOR<KpiVariableValueCreateWithoutKpiValueInput, KpiVariableValueUncheckedCreateWithoutKpiValueInput> | KpiVariableValueCreateWithoutKpiValueInput[] | KpiVariableValueUncheckedCreateWithoutKpiValueInput[]
    connectOrCreate?: KpiVariableValueCreateOrConnectWithoutKpiValueInput | KpiVariableValueCreateOrConnectWithoutKpiValueInput[]
    upsert?: KpiVariableValueUpsertWithWhereUniqueWithoutKpiValueInput | KpiVariableValueUpsertWithWhereUniqueWithoutKpiValueInput[]
    createMany?: KpiVariableValueCreateManyKpiValueInputEnvelope
    set?: KpiVariableValueWhereUniqueInput | KpiVariableValueWhereUniqueInput[]
    disconnect?: KpiVariableValueWhereUniqueInput | KpiVariableValueWhereUniqueInput[]
    delete?: KpiVariableValueWhereUniqueInput | KpiVariableValueWhereUniqueInput[]
    connect?: KpiVariableValueWhereUniqueInput | KpiVariableValueWhereUniqueInput[]
    update?: KpiVariableValueUpdateWithWhereUniqueWithoutKpiValueInput | KpiVariableValueUpdateWithWhereUniqueWithoutKpiValueInput[]
    updateMany?: KpiVariableValueUpdateManyWithWhereWithoutKpiValueInput | KpiVariableValueUpdateManyWithWhereWithoutKpiValueInput[]
    deleteMany?: KpiVariableValueScalarWhereInput | KpiVariableValueScalarWhereInput[]
  }

  export type KpiValuePeriodCreateNestedOneWithoutVariableValuesInput = {
    create?: XOR<KpiValuePeriodCreateWithoutVariableValuesInput, KpiValuePeriodUncheckedCreateWithoutVariableValuesInput>
    connectOrCreate?: KpiValuePeriodCreateOrConnectWithoutVariableValuesInput
    connect?: KpiValuePeriodWhereUniqueInput
  }

  export type KpiVariableCreateNestedOneWithoutValuesInput = {
    create?: XOR<KpiVariableCreateWithoutValuesInput, KpiVariableUncheckedCreateWithoutValuesInput>
    connectOrCreate?: KpiVariableCreateOrConnectWithoutValuesInput
    connect?: KpiVariableWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type KpiValuePeriodUpdateOneRequiredWithoutVariableValuesNestedInput = {
    create?: XOR<KpiValuePeriodCreateWithoutVariableValuesInput, KpiValuePeriodUncheckedCreateWithoutVariableValuesInput>
    connectOrCreate?: KpiValuePeriodCreateOrConnectWithoutVariableValuesInput
    upsert?: KpiValuePeriodUpsertWithoutVariableValuesInput
    connect?: KpiValuePeriodWhereUniqueInput
    update?: XOR<XOR<KpiValuePeriodUpdateToOneWithWhereWithoutVariableValuesInput, KpiValuePeriodUpdateWithoutVariableValuesInput>, KpiValuePeriodUncheckedUpdateWithoutVariableValuesInput>
  }

  export type KpiVariableUpdateOneRequiredWithoutValuesNestedInput = {
    create?: XOR<KpiVariableCreateWithoutValuesInput, KpiVariableUncheckedCreateWithoutValuesInput>
    connectOrCreate?: KpiVariableCreateOrConnectWithoutValuesInput
    upsert?: KpiVariableUpsertWithoutValuesInput
    connect?: KpiVariableWhereUniqueInput
    update?: XOR<XOR<KpiVariableUpdateToOneWithWhereWithoutValuesInput, KpiVariableUpdateWithoutValuesInput>, KpiVariableUncheckedUpdateWithoutValuesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type NestedEnumNodeTypeCodeFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeTypeCode | EnumNodeTypeCodeFieldRefInput<$PrismaModel>
    in?: $Enums.NodeTypeCode[] | ListEnumNodeTypeCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NodeTypeCode[] | ListEnumNodeTypeCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumNodeTypeCodeFilter<$PrismaModel> | $Enums.NodeTypeCode
  }

  export type NestedEnumNodeTypeCodeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeTypeCode | EnumNodeTypeCodeFieldRefInput<$PrismaModel>
    in?: $Enums.NodeTypeCode[] | ListEnumNodeTypeCodeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NodeTypeCode[] | ListEnumNodeTypeCodeFieldRefInput<$PrismaModel>
    not?: NestedEnumNodeTypeCodeWithAggregatesFilter<$PrismaModel> | $Enums.NodeTypeCode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNodeTypeCodeFilter<$PrismaModel>
    _max?: NestedEnumNodeTypeCodeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedEnumNodeAssignmentRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeAssignmentRole | EnumNodeAssignmentRoleFieldRefInput<$PrismaModel>
    in?: $Enums.NodeAssignmentRole[] | ListEnumNodeAssignmentRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.NodeAssignmentRole[] | ListEnumNodeAssignmentRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumNodeAssignmentRoleFilter<$PrismaModel> | $Enums.NodeAssignmentRole
  }

  export type NestedEnumNodeAssignmentRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeAssignmentRole | EnumNodeAssignmentRoleFieldRefInput<$PrismaModel>
    in?: $Enums.NodeAssignmentRole[] | ListEnumNodeAssignmentRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.NodeAssignmentRole[] | ListEnumNodeAssignmentRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumNodeAssignmentRoleWithAggregatesFilter<$PrismaModel> | $Enums.NodeAssignmentRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNodeAssignmentRoleFilter<$PrismaModel>
    _max?: NestedEnumNodeAssignmentRoleFilter<$PrismaModel>
  }

  export type NestedEnumKpiDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiDirection | EnumKpiDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.KpiDirection[] | ListEnumKpiDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiDirection[] | ListEnumKpiDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiDirectionFilter<$PrismaModel> | $Enums.KpiDirection
  }

  export type NestedEnumKpiAggregationMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiAggregationMethod | EnumKpiAggregationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.KpiAggregationMethod[] | ListEnumKpiAggregationMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiAggregationMethod[] | ListEnumKpiAggregationMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiAggregationMethodFilter<$PrismaModel> | $Enums.KpiAggregationMethod
  }

  export type NestedEnumKpiPeriodTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiPeriodType | EnumKpiPeriodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KpiPeriodType[] | ListEnumKpiPeriodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiPeriodType[] | ListEnumKpiPeriodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiPeriodTypeFilter<$PrismaModel> | $Enums.KpiPeriodType
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumKpiDefinitionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiDefinitionStatus | EnumKpiDefinitionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KpiDefinitionStatus[] | ListEnumKpiDefinitionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiDefinitionStatus[] | ListEnumKpiDefinitionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiDefinitionStatusFilter<$PrismaModel> | $Enums.KpiDefinitionStatus
  }

  export type NestedEnumKpiDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiDirection | EnumKpiDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.KpiDirection[] | ListEnumKpiDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiDirection[] | ListEnumKpiDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiDirectionWithAggregatesFilter<$PrismaModel> | $Enums.KpiDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKpiDirectionFilter<$PrismaModel>
    _max?: NestedEnumKpiDirectionFilter<$PrismaModel>
  }

  export type NestedEnumKpiAggregationMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiAggregationMethod | EnumKpiAggregationMethodFieldRefInput<$PrismaModel>
    in?: $Enums.KpiAggregationMethod[] | ListEnumKpiAggregationMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiAggregationMethod[] | ListEnumKpiAggregationMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiAggregationMethodWithAggregatesFilter<$PrismaModel> | $Enums.KpiAggregationMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKpiAggregationMethodFilter<$PrismaModel>
    _max?: NestedEnumKpiAggregationMethodFilter<$PrismaModel>
  }

  export type NestedEnumKpiPeriodTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiPeriodType | EnumKpiPeriodTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KpiPeriodType[] | ListEnumKpiPeriodTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiPeriodType[] | ListEnumKpiPeriodTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiPeriodTypeWithAggregatesFilter<$PrismaModel> | $Enums.KpiPeriodType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKpiPeriodTypeFilter<$PrismaModel>
    _max?: NestedEnumKpiPeriodTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumKpiDefinitionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiDefinitionStatus | EnumKpiDefinitionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KpiDefinitionStatus[] | ListEnumKpiDefinitionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiDefinitionStatus[] | ListEnumKpiDefinitionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiDefinitionStatusWithAggregatesFilter<$PrismaModel> | $Enums.KpiDefinitionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKpiDefinitionStatusFilter<$PrismaModel>
    _max?: NestedEnumKpiDefinitionStatusFilter<$PrismaModel>
  }

  export type NestedEnumKpiVariableDataTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiVariableDataType | EnumKpiVariableDataTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KpiVariableDataType[] | ListEnumKpiVariableDataTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiVariableDataType[] | ListEnumKpiVariableDataTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiVariableDataTypeFilter<$PrismaModel> | $Enums.KpiVariableDataType
  }

  export type NestedEnumKpiVariableDataTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiVariableDataType | EnumKpiVariableDataTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KpiVariableDataType[] | ListEnumKpiVariableDataTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiVariableDataType[] | ListEnumKpiVariableDataTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiVariableDataTypeWithAggregatesFilter<$PrismaModel> | $Enums.KpiVariableDataType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKpiVariableDataTypeFilter<$PrismaModel>
    _max?: NestedEnumKpiVariableDataTypeFilter<$PrismaModel>
  }

  export type NestedEnumKpiValueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiValueStatus | EnumKpiValueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KpiValueStatus[] | ListEnumKpiValueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiValueStatus[] | ListEnumKpiValueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiValueStatusFilter<$PrismaModel> | $Enums.KpiValueStatus
  }

  export type NestedEnumKpiValueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KpiValueStatus | EnumKpiValueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KpiValueStatus[] | ListEnumKpiValueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KpiValueStatus[] | ListEnumKpiValueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKpiValueStatusWithAggregatesFilter<$PrismaModel> | $Enums.KpiValueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKpiValueStatusFilter<$PrismaModel>
    _max?: NestedEnumKpiValueStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UserCreateWithoutOrgInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    manager?: UserCreateNestedOneWithoutDirectReportsInput
    directReports?: UserCreateNestedManyWithoutManagerInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionCreateNestedManyWithoutOwnerUserInput
  }

  export type UserUncheckedCreateWithoutOrgInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    managerId?: string | null
    departmentId?: string | null
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    directReports?: UserUncheckedCreateNestedManyWithoutManagerInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalUncheckedCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeUncheckedCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentUncheckedCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodUncheckedCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodUncheckedCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionUncheckedCreateNestedManyWithoutOwnerUserInput
  }

  export type UserCreateOrConnectWithoutOrgInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrgInput, UserUncheckedCreateWithoutOrgInput>
  }

  export type UserCreateManyOrgInputEnvelope = {
    data: UserCreateManyOrgInput | UserCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutOrgInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    parent?: DepartmentCreateNestedOneWithoutChildrenInput
    children?: DepartmentCreateNestedManyWithoutParentInput
    manager?: UserCreateNestedOneWithoutManagedDepartmentsInput
    users?: UserCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutOrgInput = {
    id?: string
    name: string
    code?: string | null
    parentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: DepartmentUncheckedCreateNestedManyWithoutParentInput
    users?: UserUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutOrgInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutOrgInput, DepartmentUncheckedCreateWithoutOrgInput>
  }

  export type DepartmentCreateManyOrgInputEnvelope = {
    data: DepartmentCreateManyOrgInput | DepartmentCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type NodeCreateWithoutOrgInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    nodeType: NodeTypeCreateNestedOneWithoutNodesInput
    parent?: NodeCreateNestedOneWithoutChildrenInput
    children?: NodeCreateNestedManyWithoutParentInput
    ownerUser?: UserCreateNestedOneWithoutOwnedNodesInput
    assignments?: NodeAssignmentCreateNestedManyWithoutNodeInput
    outgoingDeps?: NodeDependencyCreateNestedManyWithoutDependsOnNodeInput
    incomingDeps?: NodeDependencyCreateNestedManyWithoutBlockedNodeInput
    kpis?: KpiDefinitionCreateNestedManyWithoutPrimaryNodeInput
  }

  export type NodeUncheckedCreateWithoutOrgInput = {
    id?: string
    nodeTypeId: string
    parentId?: string | null
    name: string
    description?: string | null
    ownerUserId?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: NodeUncheckedCreateNestedManyWithoutParentInput
    assignments?: NodeAssignmentUncheckedCreateNestedManyWithoutNodeInput
    outgoingDeps?: NodeDependencyUncheckedCreateNestedManyWithoutDependsOnNodeInput
    incomingDeps?: NodeDependencyUncheckedCreateNestedManyWithoutBlockedNodeInput
    kpis?: KpiDefinitionUncheckedCreateNestedManyWithoutPrimaryNodeInput
  }

  export type NodeCreateOrConnectWithoutOrgInput = {
    where: NodeWhereUniqueInput
    create: XOR<NodeCreateWithoutOrgInput, NodeUncheckedCreateWithoutOrgInput>
  }

  export type NodeCreateManyOrgInputEnvelope = {
    data: NodeCreateManyOrgInput | NodeCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type KpiDefinitionCreateWithoutOrgInput = {
    id?: string
    name: string
    description?: string | null
    formula?: string | null
    unit?: string | null
    direction?: $Enums.KpiDirection
    aggregation?: $Enums.KpiAggregationMethod
    periodType: $Enums.KpiPeriodType
    baselineValue?: number | null
    targetValue?: number | null
    weight?: number | null
    status?: $Enums.KpiDefinitionStatus
    primaryNode: NodeCreateNestedOneWithoutKpisInput
    ownerUser?: UserCreateNestedOneWithoutOwnedKpisInput
    variables?: KpiVariableCreateNestedManyWithoutKpiInput
    values?: KpiValuePeriodCreateNestedManyWithoutKpiInput
  }

  export type KpiDefinitionUncheckedCreateWithoutOrgInput = {
    id?: string
    primaryNodeId: string
    ownerUserId?: string | null
    name: string
    description?: string | null
    formula?: string | null
    unit?: string | null
    direction?: $Enums.KpiDirection
    aggregation?: $Enums.KpiAggregationMethod
    periodType: $Enums.KpiPeriodType
    baselineValue?: number | null
    targetValue?: number | null
    weight?: number | null
    status?: $Enums.KpiDefinitionStatus
    variables?: KpiVariableUncheckedCreateNestedManyWithoutKpiInput
    values?: KpiValuePeriodUncheckedCreateNestedManyWithoutKpiInput
  }

  export type KpiDefinitionCreateOrConnectWithoutOrgInput = {
    where: KpiDefinitionWhereUniqueInput
    create: XOR<KpiDefinitionCreateWithoutOrgInput, KpiDefinitionUncheckedCreateWithoutOrgInput>
  }

  export type KpiDefinitionCreateManyOrgInputEnvelope = {
    data: KpiDefinitionCreateManyOrgInput | KpiDefinitionCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type ChangeRequestCreateWithoutOrgInput = {
    id?: string
    entityType: string
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    decidedAt?: Date | string | null
    deletedAt?: Date | string | null
    requester: UserCreateNestedOneWithoutChangeRequestsInput
    approvals?: ChangeApprovalCreateNestedManyWithoutChangeRequestInput
  }

  export type ChangeRequestUncheckedCreateWithoutOrgInput = {
    id?: string
    entityType: string
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.ApprovalStatus
    requestedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    decidedAt?: Date | string | null
    deletedAt?: Date | string | null
    approvals?: ChangeApprovalUncheckedCreateNestedManyWithoutChangeRequestInput
  }

  export type ChangeRequestCreateOrConnectWithoutOrgInput = {
    where: ChangeRequestWhereUniqueInput
    create: XOR<ChangeRequestCreateWithoutOrgInput, ChangeRequestUncheckedCreateWithoutOrgInput>
  }

  export type ChangeRequestCreateManyOrgInputEnvelope = {
    data: ChangeRequestCreateManyOrgInput | ChangeRequestCreateManyOrgInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutOrgInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutOrgInput, UserUncheckedUpdateWithoutOrgInput>
    create: XOR<UserCreateWithoutOrgInput, UserUncheckedCreateWithoutOrgInput>
  }

  export type UserUpdateWithWhereUniqueWithoutOrgInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutOrgInput, UserUncheckedUpdateWithoutOrgInput>
  }

  export type UserUpdateManyWithWhereWithoutOrgInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutOrgInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    orgId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    managerId?: StringNullableFilter<"User"> | string | null
    departmentId?: StringNullableFilter<"User"> | string | null
    title?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    hashedPassword?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type DepartmentUpsertWithWhereUniqueWithoutOrgInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutOrgInput, DepartmentUncheckedUpdateWithoutOrgInput>
    create: XOR<DepartmentCreateWithoutOrgInput, DepartmentUncheckedCreateWithoutOrgInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutOrgInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutOrgInput, DepartmentUncheckedUpdateWithoutOrgInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutOrgInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutOrgInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: StringFilter<"Department"> | string
    orgId?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    code?: StringNullableFilter<"Department"> | string | null
    parentId?: StringNullableFilter<"Department"> | string | null
    managerId?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Department"> | Date | string | null
  }

  export type NodeUpsertWithWhereUniqueWithoutOrgInput = {
    where: NodeWhereUniqueInput
    update: XOR<NodeUpdateWithoutOrgInput, NodeUncheckedUpdateWithoutOrgInput>
    create: XOR<NodeCreateWithoutOrgInput, NodeUncheckedCreateWithoutOrgInput>
  }

  export type NodeUpdateWithWhereUniqueWithoutOrgInput = {
    where: NodeWhereUniqueInput
    data: XOR<NodeUpdateWithoutOrgInput, NodeUncheckedUpdateWithoutOrgInput>
  }

  export type NodeUpdateManyWithWhereWithoutOrgInput = {
    where: NodeScalarWhereInput
    data: XOR<NodeUpdateManyMutationInput, NodeUncheckedUpdateManyWithoutOrgInput>
  }

  export type NodeScalarWhereInput = {
    AND?: NodeScalarWhereInput | NodeScalarWhereInput[]
    OR?: NodeScalarWhereInput[]
    NOT?: NodeScalarWhereInput | NodeScalarWhereInput[]
    id?: StringFilter<"Node"> | string
    orgId?: StringFilter<"Node"> | string
    nodeTypeId?: StringFilter<"Node"> | string
    parentId?: StringNullableFilter<"Node"> | string | null
    name?: StringFilter<"Node"> | string
    description?: StringNullableFilter<"Node"> | string | null
    ownerUserId?: StringNullableFilter<"Node"> | string | null
    status?: EnumStatusFilter<"Node"> | $Enums.Status
    progress?: IntFilter<"Node"> | number
    startDate?: DateTimeNullableFilter<"Node"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Node"> | Date | string | null
    createdAt?: DateTimeFilter<"Node"> | Date | string
    updatedAt?: DateTimeFilter<"Node"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Node"> | Date | string | null
  }

  export type KpiDefinitionUpsertWithWhereUniqueWithoutOrgInput = {
    where: KpiDefinitionWhereUniqueInput
    update: XOR<KpiDefinitionUpdateWithoutOrgInput, KpiDefinitionUncheckedUpdateWithoutOrgInput>
    create: XOR<KpiDefinitionCreateWithoutOrgInput, KpiDefinitionUncheckedCreateWithoutOrgInput>
  }

  export type KpiDefinitionUpdateWithWhereUniqueWithoutOrgInput = {
    where: KpiDefinitionWhereUniqueInput
    data: XOR<KpiDefinitionUpdateWithoutOrgInput, KpiDefinitionUncheckedUpdateWithoutOrgInput>
  }

  export type KpiDefinitionUpdateManyWithWhereWithoutOrgInput = {
    where: KpiDefinitionScalarWhereInput
    data: XOR<KpiDefinitionUpdateManyMutationInput, KpiDefinitionUncheckedUpdateManyWithoutOrgInput>
  }

  export type KpiDefinitionScalarWhereInput = {
    AND?: KpiDefinitionScalarWhereInput | KpiDefinitionScalarWhereInput[]
    OR?: KpiDefinitionScalarWhereInput[]
    NOT?: KpiDefinitionScalarWhereInput | KpiDefinitionScalarWhereInput[]
    id?: StringFilter<"KpiDefinition"> | string
    orgId?: StringFilter<"KpiDefinition"> | string
    primaryNodeId?: StringFilter<"KpiDefinition"> | string
    ownerUserId?: StringNullableFilter<"KpiDefinition"> | string | null
    name?: StringFilter<"KpiDefinition"> | string
    description?: StringNullableFilter<"KpiDefinition"> | string | null
    formula?: StringNullableFilter<"KpiDefinition"> | string | null
    unit?: StringNullableFilter<"KpiDefinition"> | string | null
    direction?: EnumKpiDirectionFilter<"KpiDefinition"> | $Enums.KpiDirection
    aggregation?: EnumKpiAggregationMethodFilter<"KpiDefinition"> | $Enums.KpiAggregationMethod
    periodType?: EnumKpiPeriodTypeFilter<"KpiDefinition"> | $Enums.KpiPeriodType
    baselineValue?: FloatNullableFilter<"KpiDefinition"> | number | null
    targetValue?: FloatNullableFilter<"KpiDefinition"> | number | null
    weight?: FloatNullableFilter<"KpiDefinition"> | number | null
    status?: EnumKpiDefinitionStatusFilter<"KpiDefinition"> | $Enums.KpiDefinitionStatus
  }

  export type ChangeRequestUpsertWithWhereUniqueWithoutOrgInput = {
    where: ChangeRequestWhereUniqueInput
    update: XOR<ChangeRequestUpdateWithoutOrgInput, ChangeRequestUncheckedUpdateWithoutOrgInput>
    create: XOR<ChangeRequestCreateWithoutOrgInput, ChangeRequestUncheckedCreateWithoutOrgInput>
  }

  export type ChangeRequestUpdateWithWhereUniqueWithoutOrgInput = {
    where: ChangeRequestWhereUniqueInput
    data: XOR<ChangeRequestUpdateWithoutOrgInput, ChangeRequestUncheckedUpdateWithoutOrgInput>
  }

  export type ChangeRequestUpdateManyWithWhereWithoutOrgInput = {
    where: ChangeRequestScalarWhereInput
    data: XOR<ChangeRequestUpdateManyMutationInput, ChangeRequestUncheckedUpdateManyWithoutOrgInput>
  }

  export type ChangeRequestScalarWhereInput = {
    AND?: ChangeRequestScalarWhereInput | ChangeRequestScalarWhereInput[]
    OR?: ChangeRequestScalarWhereInput[]
    NOT?: ChangeRequestScalarWhereInput | ChangeRequestScalarWhereInput[]
    id?: StringFilter<"ChangeRequest"> | string
    orgId?: StringFilter<"ChangeRequest"> | string
    entityType?: StringFilter<"ChangeRequest"> | string
    entityId?: StringFilter<"ChangeRequest"> | string
    payload?: JsonFilter<"ChangeRequest">
    status?: EnumApprovalStatusFilter<"ChangeRequest"> | $Enums.ApprovalStatus
    requestedBy?: StringFilter<"ChangeRequest"> | string
    createdAt?: DateTimeFilter<"ChangeRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ChangeRequest"> | Date | string
    decidedAt?: DateTimeNullableFilter<"ChangeRequest"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"ChangeRequest"> | Date | string | null
  }

  export type OrganizationCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserCreateNestedManyWithoutOrgInput
    nodes?: NodeCreateNestedManyWithoutOrgInput
    kpis?: KpiDefinitionCreateNestedManyWithoutOrgInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutOrgInput
  }

  export type OrganizationUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    nodes?: NodeUncheckedCreateNestedManyWithoutOrgInput
    kpis?: KpiDefinitionUncheckedCreateNestedManyWithoutOrgInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrganizationCreateOrConnectWithoutDepartmentsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutDepartmentsInput, OrganizationUncheckedCreateWithoutDepartmentsInput>
  }

  export type DepartmentCreateWithoutChildrenInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutDepartmentsInput
    parent?: DepartmentCreateNestedOneWithoutChildrenInput
    manager?: UserCreateNestedOneWithoutManagedDepartmentsInput
    users?: UserCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutChildrenInput = {
    id?: string
    orgId: string
    name: string
    code?: string | null
    parentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutChildrenInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutChildrenInput, DepartmentUncheckedCreateWithoutChildrenInput>
  }

  export type DepartmentCreateWithoutParentInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutDepartmentsInput
    children?: DepartmentCreateNestedManyWithoutParentInput
    manager?: UserCreateNestedOneWithoutManagedDepartmentsInput
    users?: UserCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutParentInput = {
    id?: string
    orgId: string
    name: string
    code?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: DepartmentUncheckedCreateNestedManyWithoutParentInput
    users?: UserUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutParentInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutParentInput, DepartmentUncheckedCreateWithoutParentInput>
  }

  export type DepartmentCreateManyParentInputEnvelope = {
    data: DepartmentCreateManyParentInput | DepartmentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutManagedDepartmentsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutDirectReportsInput
    directReports?: UserCreateNestedManyWithoutManagerInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionCreateNestedManyWithoutOwnerUserInput
  }

  export type UserUncheckedCreateWithoutManagedDepartmentsInput = {
    id?: string
    orgId: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    managerId?: string | null
    departmentId?: string | null
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    directReports?: UserUncheckedCreateNestedManyWithoutManagerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalUncheckedCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeUncheckedCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentUncheckedCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodUncheckedCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodUncheckedCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionUncheckedCreateNestedManyWithoutOwnerUserInput
  }

  export type UserCreateOrConnectWithoutManagedDepartmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagedDepartmentsInput, UserUncheckedCreateWithoutManagedDepartmentsInput>
  }

  export type UserCreateWithoutDepartmentInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutDirectReportsInput
    directReports?: UserCreateNestedManyWithoutManagerInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionCreateNestedManyWithoutOwnerUserInput
  }

  export type UserUncheckedCreateWithoutDepartmentInput = {
    id?: string
    orgId: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    managerId?: string | null
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    directReports?: UserUncheckedCreateNestedManyWithoutManagerInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalUncheckedCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeUncheckedCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentUncheckedCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodUncheckedCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodUncheckedCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionUncheckedCreateNestedManyWithoutOwnerUserInput
  }

  export type UserCreateOrConnectWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput>
  }

  export type UserCreateManyDepartmentInputEnvelope = {
    data: UserCreateManyDepartmentInput | UserCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutDepartmentsInput = {
    update: XOR<OrganizationUpdateWithoutDepartmentsInput, OrganizationUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<OrganizationCreateWithoutDepartmentsInput, OrganizationUncheckedCreateWithoutDepartmentsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutDepartmentsInput, OrganizationUncheckedUpdateWithoutDepartmentsInput>
  }

  export type OrganizationUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutOrgNestedInput
    nodes?: NodeUpdateManyWithoutOrgNestedInput
    kpis?: KpiDefinitionUpdateManyWithoutOrgNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutOrgNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    nodes?: NodeUncheckedUpdateManyWithoutOrgNestedInput
    kpis?: KpiDefinitionUncheckedUpdateManyWithoutOrgNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type DepartmentUpsertWithoutChildrenInput = {
    update: XOR<DepartmentUpdateWithoutChildrenInput, DepartmentUncheckedUpdateWithoutChildrenInput>
    create: XOR<DepartmentCreateWithoutChildrenInput, DepartmentUncheckedCreateWithoutChildrenInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutChildrenInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutChildrenInput, DepartmentUncheckedUpdateWithoutChildrenInput>
  }

  export type DepartmentUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput
    parent?: DepartmentUpdateOneWithoutChildrenNestedInput
    manager?: UserUpdateOneWithoutManagedDepartmentsNestedInput
    users?: UserUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUpsertWithWhereUniqueWithoutParentInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutParentInput, DepartmentUncheckedUpdateWithoutParentInput>
    create: XOR<DepartmentCreateWithoutParentInput, DepartmentUncheckedCreateWithoutParentInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutParentInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutParentInput, DepartmentUncheckedUpdateWithoutParentInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutParentInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutParentInput>
  }

  export type UserUpsertWithoutManagedDepartmentsInput = {
    update: XOR<UserUpdateWithoutManagedDepartmentsInput, UserUncheckedUpdateWithoutManagedDepartmentsInput>
    create: XOR<UserCreateWithoutManagedDepartmentsInput, UserUncheckedCreateWithoutManagedDepartmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutManagedDepartmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutManagedDepartmentsInput, UserUncheckedUpdateWithoutManagedDepartmentsInput>
  }

  export type UserUpdateWithoutManagedDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutDirectReportsNestedInput
    directReports?: UserUpdateManyWithoutManagerNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserUncheckedUpdateWithoutManagedDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directReports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUncheckedUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUncheckedUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUncheckedUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUncheckedUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUncheckedUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUncheckedUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutDepartmentInput, UserUncheckedUpdateWithoutDepartmentInput>
    create: XOR<UserCreateWithoutDepartmentInput, UserUncheckedCreateWithoutDepartmentInput>
  }

  export type UserUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutDepartmentInput, UserUncheckedUpdateWithoutDepartmentInput>
  }

  export type UserUpdateManyWithWhereWithoutDepartmentInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type OrganizationCreateWithoutUsersInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    departments?: DepartmentCreateNestedManyWithoutOrgInput
    nodes?: NodeCreateNestedManyWithoutOrgInput
    kpis?: KpiDefinitionCreateNestedManyWithoutOrgInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutOrgInput
  }

  export type OrganizationUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    departments?: DepartmentUncheckedCreateNestedManyWithoutOrgInput
    nodes?: NodeUncheckedCreateNestedManyWithoutOrgInput
    kpis?: KpiDefinitionUncheckedCreateNestedManyWithoutOrgInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrganizationCreateOrConnectWithoutUsersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutDirectReportsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutDirectReportsInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionCreateNestedManyWithoutOwnerUserInput
  }

  export type UserUncheckedCreateWithoutDirectReportsInput = {
    id?: string
    orgId: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    managerId?: string | null
    departmentId?: string | null
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalUncheckedCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeUncheckedCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentUncheckedCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodUncheckedCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodUncheckedCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionUncheckedCreateNestedManyWithoutOwnerUserInput
  }

  export type UserCreateOrConnectWithoutDirectReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDirectReportsInput, UserUncheckedCreateWithoutDirectReportsInput>
  }

  export type UserCreateWithoutManagerInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutUsersInput
    directReports?: UserCreateNestedManyWithoutManagerInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionCreateNestedManyWithoutOwnerUserInput
  }

  export type UserUncheckedCreateWithoutManagerInput = {
    id?: string
    orgId: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    departmentId?: string | null
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    directReports?: UserUncheckedCreateNestedManyWithoutManagerInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalUncheckedCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeUncheckedCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentUncheckedCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodUncheckedCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodUncheckedCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionUncheckedCreateNestedManyWithoutOwnerUserInput
  }

  export type UserCreateOrConnectWithoutManagerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
  }

  export type UserCreateManyManagerInputEnvelope = {
    data: UserCreateManyManagerInput | UserCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutUsersInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutDepartmentsInput
    parent?: DepartmentCreateNestedOneWithoutChildrenInput
    children?: DepartmentCreateNestedManyWithoutParentInput
    manager?: UserCreateNestedOneWithoutManagedDepartmentsInput
  }

  export type DepartmentUncheckedCreateWithoutUsersInput = {
    id?: string
    orgId: string
    name: string
    code?: string | null
    parentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: DepartmentUncheckedCreateNestedManyWithoutParentInput
  }

  export type DepartmentCreateOrConnectWithoutUsersInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
  }

  export type DepartmentCreateWithoutManagerInput = {
    id?: string
    name: string
    code?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutDepartmentsInput
    parent?: DepartmentCreateNestedOneWithoutChildrenInput
    children?: DepartmentCreateNestedManyWithoutParentInput
    users?: UserCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutManagerInput = {
    id?: string
    orgId: string
    name: string
    code?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: DepartmentUncheckedCreateNestedManyWithoutParentInput
    users?: UserUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutManagerInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutManagerInput, DepartmentUncheckedCreateWithoutManagerInput>
  }

  export type DepartmentCreateManyManagerInputEnvelope = {
    data: DepartmentCreateManyManagerInput | DepartmentCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPreferenceCreateWithoutUserInput = {
    id?: string
    locale?: string
    theme?: string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferenceUncheckedCreateWithoutUserInput = {
    id?: string
    locale?: string
    theme?: string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferenceCreateOrConnectWithoutUserInput = {
    where: UserPreferenceWhereUniqueInput
    create: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
  }

  export type ChangeApprovalCreateWithoutApproverInput = {
    id?: string
    status?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    decidedAt?: Date | string | null
    changeRequest: ChangeRequestCreateNestedOneWithoutApprovalsInput
  }

  export type ChangeApprovalUncheckedCreateWithoutApproverInput = {
    id?: string
    changeRequestId: string
    status?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    decidedAt?: Date | string | null
  }

  export type ChangeApprovalCreateOrConnectWithoutApproverInput = {
    where: ChangeApprovalWhereUniqueInput
    create: XOR<ChangeApprovalCreateWithoutApproverInput, ChangeApprovalUncheckedCreateWithoutApproverInput>
  }

  export type ChangeApprovalCreateManyApproverInputEnvelope = {
    data: ChangeApprovalCreateManyApproverInput | ChangeApprovalCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type ChangeRequestCreateWithoutRequesterInput = {
    id?: string
    entityType: string
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    decidedAt?: Date | string | null
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutChangeRequestsInput
    approvals?: ChangeApprovalCreateNestedManyWithoutChangeRequestInput
  }

  export type ChangeRequestUncheckedCreateWithoutRequesterInput = {
    id?: string
    orgId: string
    entityType: string
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    decidedAt?: Date | string | null
    deletedAt?: Date | string | null
    approvals?: ChangeApprovalUncheckedCreateNestedManyWithoutChangeRequestInput
  }

  export type ChangeRequestCreateOrConnectWithoutRequesterInput = {
    where: ChangeRequestWhereUniqueInput
    create: XOR<ChangeRequestCreateWithoutRequesterInput, ChangeRequestUncheckedCreateWithoutRequesterInput>
  }

  export type ChangeRequestCreateManyRequesterInputEnvelope = {
    data: ChangeRequestCreateManyRequesterInput | ChangeRequestCreateManyRequesterInput[]
    skipDuplicates?: boolean
  }

  export type NodeCreateWithoutOwnerUserInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutNodesInput
    nodeType: NodeTypeCreateNestedOneWithoutNodesInput
    parent?: NodeCreateNestedOneWithoutChildrenInput
    children?: NodeCreateNestedManyWithoutParentInput
    assignments?: NodeAssignmentCreateNestedManyWithoutNodeInput
    outgoingDeps?: NodeDependencyCreateNestedManyWithoutDependsOnNodeInput
    incomingDeps?: NodeDependencyCreateNestedManyWithoutBlockedNodeInput
    kpis?: KpiDefinitionCreateNestedManyWithoutPrimaryNodeInput
  }

  export type NodeUncheckedCreateWithoutOwnerUserInput = {
    id?: string
    orgId: string
    nodeTypeId: string
    parentId?: string | null
    name: string
    description?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: NodeUncheckedCreateNestedManyWithoutParentInput
    assignments?: NodeAssignmentUncheckedCreateNestedManyWithoutNodeInput
    outgoingDeps?: NodeDependencyUncheckedCreateNestedManyWithoutDependsOnNodeInput
    incomingDeps?: NodeDependencyUncheckedCreateNestedManyWithoutBlockedNodeInput
    kpis?: KpiDefinitionUncheckedCreateNestedManyWithoutPrimaryNodeInput
  }

  export type NodeCreateOrConnectWithoutOwnerUserInput = {
    where: NodeWhereUniqueInput
    create: XOR<NodeCreateWithoutOwnerUserInput, NodeUncheckedCreateWithoutOwnerUserInput>
  }

  export type NodeCreateManyOwnerUserInputEnvelope = {
    data: NodeCreateManyOwnerUserInput | NodeCreateManyOwnerUserInput[]
    skipDuplicates?: boolean
  }

  export type NodeAssignmentCreateWithoutUserInput = {
    id?: string
    role?: $Enums.NodeAssignmentRole
    createdAt?: Date | string
    updatedAt?: Date | string
    node: NodeCreateNestedOneWithoutAssignmentsInput
  }

  export type NodeAssignmentUncheckedCreateWithoutUserInput = {
    id?: string
    nodeId: string
    role?: $Enums.NodeAssignmentRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NodeAssignmentCreateOrConnectWithoutUserInput = {
    where: NodeAssignmentWhereUniqueInput
    create: XOR<NodeAssignmentCreateWithoutUserInput, NodeAssignmentUncheckedCreateWithoutUserInput>
  }

  export type NodeAssignmentCreateManyUserInputEnvelope = {
    data: NodeAssignmentCreateManyUserInput | NodeAssignmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type KpiValuePeriodCreateWithoutEnteredByUserInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    calculatedValue?: number | null
    status?: $Enums.KpiValueStatus
    note?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    kpi: KpiDefinitionCreateNestedOneWithoutValuesInput
    approvedByUser?: UserCreateNestedOneWithoutKpiValuesApprovedInput
    variableValues?: KpiVariableValueCreateNestedManyWithoutKpiValueInput
  }

  export type KpiValuePeriodUncheckedCreateWithoutEnteredByUserInput = {
    id?: string
    kpiId: string
    periodStart: Date | string
    periodEnd: Date | string
    calculatedValue?: number | null
    status?: $Enums.KpiValueStatus
    note?: string | null
    approvedBy?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variableValues?: KpiVariableValueUncheckedCreateNestedManyWithoutKpiValueInput
  }

  export type KpiValuePeriodCreateOrConnectWithoutEnteredByUserInput = {
    where: KpiValuePeriodWhereUniqueInput
    create: XOR<KpiValuePeriodCreateWithoutEnteredByUserInput, KpiValuePeriodUncheckedCreateWithoutEnteredByUserInput>
  }

  export type KpiValuePeriodCreateManyEnteredByUserInputEnvelope = {
    data: KpiValuePeriodCreateManyEnteredByUserInput | KpiValuePeriodCreateManyEnteredByUserInput[]
    skipDuplicates?: boolean
  }

  export type KpiValuePeriodCreateWithoutApprovedByUserInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    calculatedValue?: number | null
    status?: $Enums.KpiValueStatus
    note?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    kpi: KpiDefinitionCreateNestedOneWithoutValuesInput
    enteredByUser?: UserCreateNestedOneWithoutKpiValuesEnteredInput
    variableValues?: KpiVariableValueCreateNestedManyWithoutKpiValueInput
  }

  export type KpiValuePeriodUncheckedCreateWithoutApprovedByUserInput = {
    id?: string
    kpiId: string
    periodStart: Date | string
    periodEnd: Date | string
    calculatedValue?: number | null
    status?: $Enums.KpiValueStatus
    note?: string | null
    enteredBy?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variableValues?: KpiVariableValueUncheckedCreateNestedManyWithoutKpiValueInput
  }

  export type KpiValuePeriodCreateOrConnectWithoutApprovedByUserInput = {
    where: KpiValuePeriodWhereUniqueInput
    create: XOR<KpiValuePeriodCreateWithoutApprovedByUserInput, KpiValuePeriodUncheckedCreateWithoutApprovedByUserInput>
  }

  export type KpiValuePeriodCreateManyApprovedByUserInputEnvelope = {
    data: KpiValuePeriodCreateManyApprovedByUserInput | KpiValuePeriodCreateManyApprovedByUserInput[]
    skipDuplicates?: boolean
  }

  export type KpiDefinitionCreateWithoutOwnerUserInput = {
    id?: string
    name: string
    description?: string | null
    formula?: string | null
    unit?: string | null
    direction?: $Enums.KpiDirection
    aggregation?: $Enums.KpiAggregationMethod
    periodType: $Enums.KpiPeriodType
    baselineValue?: number | null
    targetValue?: number | null
    weight?: number | null
    status?: $Enums.KpiDefinitionStatus
    org: OrganizationCreateNestedOneWithoutKpisInput
    primaryNode: NodeCreateNestedOneWithoutKpisInput
    variables?: KpiVariableCreateNestedManyWithoutKpiInput
    values?: KpiValuePeriodCreateNestedManyWithoutKpiInput
  }

  export type KpiDefinitionUncheckedCreateWithoutOwnerUserInput = {
    id?: string
    orgId: string
    primaryNodeId: string
    name: string
    description?: string | null
    formula?: string | null
    unit?: string | null
    direction?: $Enums.KpiDirection
    aggregation?: $Enums.KpiAggregationMethod
    periodType: $Enums.KpiPeriodType
    baselineValue?: number | null
    targetValue?: number | null
    weight?: number | null
    status?: $Enums.KpiDefinitionStatus
    variables?: KpiVariableUncheckedCreateNestedManyWithoutKpiInput
    values?: KpiValuePeriodUncheckedCreateNestedManyWithoutKpiInput
  }

  export type KpiDefinitionCreateOrConnectWithoutOwnerUserInput = {
    where: KpiDefinitionWhereUniqueInput
    create: XOR<KpiDefinitionCreateWithoutOwnerUserInput, KpiDefinitionUncheckedCreateWithoutOwnerUserInput>
  }

  export type KpiDefinitionCreateManyOwnerUserInputEnvelope = {
    data: KpiDefinitionCreateManyOwnerUserInput | KpiDefinitionCreateManyOwnerUserInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutUsersInput = {
    update: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUsersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type OrganizationUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departments?: DepartmentUpdateManyWithoutOrgNestedInput
    nodes?: NodeUpdateManyWithoutOrgNestedInput
    kpis?: KpiDefinitionUpdateManyWithoutOrgNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutOrgNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departments?: DepartmentUncheckedUpdateManyWithoutOrgNestedInput
    nodes?: NodeUncheckedUpdateManyWithoutOrgNestedInput
    kpis?: KpiDefinitionUncheckedUpdateManyWithoutOrgNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type UserUpsertWithoutDirectReportsInput = {
    update: XOR<UserUpdateWithoutDirectReportsInput, UserUncheckedUpdateWithoutDirectReportsInput>
    create: XOR<UserCreateWithoutDirectReportsInput, UserUncheckedCreateWithoutDirectReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDirectReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDirectReportsInput, UserUncheckedUpdateWithoutDirectReportsInput>
  }

  export type UserUpdateWithoutDirectReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutDirectReportsNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDirectReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUncheckedUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUncheckedUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUncheckedUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUncheckedUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUncheckedUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUncheckedUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutManagerInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutManagerInput, UserUncheckedUpdateWithoutManagerInput>
    create: XOR<UserCreateWithoutManagerInput, UserUncheckedCreateWithoutManagerInput>
  }

  export type UserUpdateWithWhereUniqueWithoutManagerInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutManagerInput, UserUncheckedUpdateWithoutManagerInput>
  }

  export type UserUpdateManyWithWhereWithoutManagerInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutManagerInput>
  }

  export type DepartmentUpsertWithoutUsersInput = {
    update: XOR<DepartmentUpdateWithoutUsersInput, DepartmentUncheckedUpdateWithoutUsersInput>
    create: XOR<DepartmentCreateWithoutUsersInput, DepartmentUncheckedCreateWithoutUsersInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutUsersInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutUsersInput, DepartmentUncheckedUpdateWithoutUsersInput>
  }

  export type DepartmentUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput
    parent?: DepartmentUpdateOneWithoutChildrenNestedInput
    children?: DepartmentUpdateManyWithoutParentNestedInput
    manager?: UserUpdateOneWithoutManagedDepartmentsNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: DepartmentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type DepartmentUpsertWithWhereUniqueWithoutManagerInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutManagerInput, DepartmentUncheckedUpdateWithoutManagerInput>
    create: XOR<DepartmentCreateWithoutManagerInput, DepartmentUncheckedCreateWithoutManagerInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutManagerInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutManagerInput, DepartmentUncheckedUpdateWithoutManagerInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutManagerInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutManagerInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type UserPreferenceUpsertWithoutUserInput = {
    update: XOR<UserPreferenceUpdateWithoutUserInput, UserPreferenceUncheckedUpdateWithoutUserInput>
    create: XOR<UserPreferenceCreateWithoutUserInput, UserPreferenceUncheckedCreateWithoutUserInput>
    where?: UserPreferenceWhereInput
  }

  export type UserPreferenceUpdateToOneWithWhereWithoutUserInput = {
    where?: UserPreferenceWhereInput
    data: XOR<UserPreferenceUpdateWithoutUserInput, UserPreferenceUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferenceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferenceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    locale?: StringFieldUpdateOperationsInput | string
    theme?: StringFieldUpdateOperationsInput | string
    notifications?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeApprovalUpsertWithWhereUniqueWithoutApproverInput = {
    where: ChangeApprovalWhereUniqueInput
    update: XOR<ChangeApprovalUpdateWithoutApproverInput, ChangeApprovalUncheckedUpdateWithoutApproverInput>
    create: XOR<ChangeApprovalCreateWithoutApproverInput, ChangeApprovalUncheckedCreateWithoutApproverInput>
  }

  export type ChangeApprovalUpdateWithWhereUniqueWithoutApproverInput = {
    where: ChangeApprovalWhereUniqueInput
    data: XOR<ChangeApprovalUpdateWithoutApproverInput, ChangeApprovalUncheckedUpdateWithoutApproverInput>
  }

  export type ChangeApprovalUpdateManyWithWhereWithoutApproverInput = {
    where: ChangeApprovalScalarWhereInput
    data: XOR<ChangeApprovalUpdateManyMutationInput, ChangeApprovalUncheckedUpdateManyWithoutApproverInput>
  }

  export type ChangeApprovalScalarWhereInput = {
    AND?: ChangeApprovalScalarWhereInput | ChangeApprovalScalarWhereInput[]
    OR?: ChangeApprovalScalarWhereInput[]
    NOT?: ChangeApprovalScalarWhereInput | ChangeApprovalScalarWhereInput[]
    id?: StringFilter<"ChangeApproval"> | string
    changeRequestId?: StringFilter<"ChangeApproval"> | string
    approverId?: StringFilter<"ChangeApproval"> | string
    status?: EnumApprovalStatusFilter<"ChangeApproval"> | $Enums.ApprovalStatus
    comment?: StringNullableFilter<"ChangeApproval"> | string | null
    createdAt?: DateTimeFilter<"ChangeApproval"> | Date | string
    decidedAt?: DateTimeNullableFilter<"ChangeApproval"> | Date | string | null
  }

  export type ChangeRequestUpsertWithWhereUniqueWithoutRequesterInput = {
    where: ChangeRequestWhereUniqueInput
    update: XOR<ChangeRequestUpdateWithoutRequesterInput, ChangeRequestUncheckedUpdateWithoutRequesterInput>
    create: XOR<ChangeRequestCreateWithoutRequesterInput, ChangeRequestUncheckedCreateWithoutRequesterInput>
  }

  export type ChangeRequestUpdateWithWhereUniqueWithoutRequesterInput = {
    where: ChangeRequestWhereUniqueInput
    data: XOR<ChangeRequestUpdateWithoutRequesterInput, ChangeRequestUncheckedUpdateWithoutRequesterInput>
  }

  export type ChangeRequestUpdateManyWithWhereWithoutRequesterInput = {
    where: ChangeRequestScalarWhereInput
    data: XOR<ChangeRequestUpdateManyMutationInput, ChangeRequestUncheckedUpdateManyWithoutRequesterInput>
  }

  export type NodeUpsertWithWhereUniqueWithoutOwnerUserInput = {
    where: NodeWhereUniqueInput
    update: XOR<NodeUpdateWithoutOwnerUserInput, NodeUncheckedUpdateWithoutOwnerUserInput>
    create: XOR<NodeCreateWithoutOwnerUserInput, NodeUncheckedCreateWithoutOwnerUserInput>
  }

  export type NodeUpdateWithWhereUniqueWithoutOwnerUserInput = {
    where: NodeWhereUniqueInput
    data: XOR<NodeUpdateWithoutOwnerUserInput, NodeUncheckedUpdateWithoutOwnerUserInput>
  }

  export type NodeUpdateManyWithWhereWithoutOwnerUserInput = {
    where: NodeScalarWhereInput
    data: XOR<NodeUpdateManyMutationInput, NodeUncheckedUpdateManyWithoutOwnerUserInput>
  }

  export type NodeAssignmentUpsertWithWhereUniqueWithoutUserInput = {
    where: NodeAssignmentWhereUniqueInput
    update: XOR<NodeAssignmentUpdateWithoutUserInput, NodeAssignmentUncheckedUpdateWithoutUserInput>
    create: XOR<NodeAssignmentCreateWithoutUserInput, NodeAssignmentUncheckedCreateWithoutUserInput>
  }

  export type NodeAssignmentUpdateWithWhereUniqueWithoutUserInput = {
    where: NodeAssignmentWhereUniqueInput
    data: XOR<NodeAssignmentUpdateWithoutUserInput, NodeAssignmentUncheckedUpdateWithoutUserInput>
  }

  export type NodeAssignmentUpdateManyWithWhereWithoutUserInput = {
    where: NodeAssignmentScalarWhereInput
    data: XOR<NodeAssignmentUpdateManyMutationInput, NodeAssignmentUncheckedUpdateManyWithoutUserInput>
  }

  export type NodeAssignmentScalarWhereInput = {
    AND?: NodeAssignmentScalarWhereInput | NodeAssignmentScalarWhereInput[]
    OR?: NodeAssignmentScalarWhereInput[]
    NOT?: NodeAssignmentScalarWhereInput | NodeAssignmentScalarWhereInput[]
    id?: StringFilter<"NodeAssignment"> | string
    nodeId?: StringFilter<"NodeAssignment"> | string
    userId?: StringFilter<"NodeAssignment"> | string
    role?: EnumNodeAssignmentRoleFilter<"NodeAssignment"> | $Enums.NodeAssignmentRole
    createdAt?: DateTimeFilter<"NodeAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"NodeAssignment"> | Date | string
  }

  export type KpiValuePeriodUpsertWithWhereUniqueWithoutEnteredByUserInput = {
    where: KpiValuePeriodWhereUniqueInput
    update: XOR<KpiValuePeriodUpdateWithoutEnteredByUserInput, KpiValuePeriodUncheckedUpdateWithoutEnteredByUserInput>
    create: XOR<KpiValuePeriodCreateWithoutEnteredByUserInput, KpiValuePeriodUncheckedCreateWithoutEnteredByUserInput>
  }

  export type KpiValuePeriodUpdateWithWhereUniqueWithoutEnteredByUserInput = {
    where: KpiValuePeriodWhereUniqueInput
    data: XOR<KpiValuePeriodUpdateWithoutEnteredByUserInput, KpiValuePeriodUncheckedUpdateWithoutEnteredByUserInput>
  }

  export type KpiValuePeriodUpdateManyWithWhereWithoutEnteredByUserInput = {
    where: KpiValuePeriodScalarWhereInput
    data: XOR<KpiValuePeriodUpdateManyMutationInput, KpiValuePeriodUncheckedUpdateManyWithoutEnteredByUserInput>
  }

  export type KpiValuePeriodScalarWhereInput = {
    AND?: KpiValuePeriodScalarWhereInput | KpiValuePeriodScalarWhereInput[]
    OR?: KpiValuePeriodScalarWhereInput[]
    NOT?: KpiValuePeriodScalarWhereInput | KpiValuePeriodScalarWhereInput[]
    id?: StringFilter<"KpiValuePeriod"> | string
    kpiId?: StringFilter<"KpiValuePeriod"> | string
    periodStart?: DateTimeFilter<"KpiValuePeriod"> | Date | string
    periodEnd?: DateTimeFilter<"KpiValuePeriod"> | Date | string
    calculatedValue?: FloatNullableFilter<"KpiValuePeriod"> | number | null
    status?: EnumKpiValueStatusFilter<"KpiValuePeriod"> | $Enums.KpiValueStatus
    note?: StringNullableFilter<"KpiValuePeriod"> | string | null
    enteredBy?: StringNullableFilter<"KpiValuePeriod"> | string | null
    approvedBy?: StringNullableFilter<"KpiValuePeriod"> | string | null
    submittedAt?: DateTimeNullableFilter<"KpiValuePeriod"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"KpiValuePeriod"> | Date | string | null
    lockedAt?: DateTimeNullableFilter<"KpiValuePeriod"> | Date | string | null
    createdAt?: DateTimeFilter<"KpiValuePeriod"> | Date | string
    updatedAt?: DateTimeFilter<"KpiValuePeriod"> | Date | string
  }

  export type KpiValuePeriodUpsertWithWhereUniqueWithoutApprovedByUserInput = {
    where: KpiValuePeriodWhereUniqueInput
    update: XOR<KpiValuePeriodUpdateWithoutApprovedByUserInput, KpiValuePeriodUncheckedUpdateWithoutApprovedByUserInput>
    create: XOR<KpiValuePeriodCreateWithoutApprovedByUserInput, KpiValuePeriodUncheckedCreateWithoutApprovedByUserInput>
  }

  export type KpiValuePeriodUpdateWithWhereUniqueWithoutApprovedByUserInput = {
    where: KpiValuePeriodWhereUniqueInput
    data: XOR<KpiValuePeriodUpdateWithoutApprovedByUserInput, KpiValuePeriodUncheckedUpdateWithoutApprovedByUserInput>
  }

  export type KpiValuePeriodUpdateManyWithWhereWithoutApprovedByUserInput = {
    where: KpiValuePeriodScalarWhereInput
    data: XOR<KpiValuePeriodUpdateManyMutationInput, KpiValuePeriodUncheckedUpdateManyWithoutApprovedByUserInput>
  }

  export type KpiDefinitionUpsertWithWhereUniqueWithoutOwnerUserInput = {
    where: KpiDefinitionWhereUniqueInput
    update: XOR<KpiDefinitionUpdateWithoutOwnerUserInput, KpiDefinitionUncheckedUpdateWithoutOwnerUserInput>
    create: XOR<KpiDefinitionCreateWithoutOwnerUserInput, KpiDefinitionUncheckedCreateWithoutOwnerUserInput>
  }

  export type KpiDefinitionUpdateWithWhereUniqueWithoutOwnerUserInput = {
    where: KpiDefinitionWhereUniqueInput
    data: XOR<KpiDefinitionUpdateWithoutOwnerUserInput, KpiDefinitionUncheckedUpdateWithoutOwnerUserInput>
  }

  export type KpiDefinitionUpdateManyWithWhereWithoutOwnerUserInput = {
    where: KpiDefinitionScalarWhereInput
    data: XOR<KpiDefinitionUpdateManyMutationInput, KpiDefinitionUncheckedUpdateManyWithoutOwnerUserInput>
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutDirectReportsInput
    directReports?: UserCreateNestedManyWithoutManagerInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionCreateNestedManyWithoutOwnerUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    orgId: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    managerId?: string | null
    departmentId?: string | null
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    directReports?: UserUncheckedCreateNestedManyWithoutManagerInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalUncheckedCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeUncheckedCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentUncheckedCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodUncheckedCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodUncheckedCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionUncheckedCreateNestedManyWithoutOwnerUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutDirectReportsNestedInput
    directReports?: UserUpdateManyWithoutManagerNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directReports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUncheckedUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUncheckedUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUncheckedUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUncheckedUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUncheckedUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUncheckedUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutDirectReportsInput
    directReports?: UserCreateNestedManyWithoutManagerInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionCreateNestedManyWithoutOwnerUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    orgId: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    managerId?: string | null
    departmentId?: string | null
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    directReports?: UserUncheckedCreateNestedManyWithoutManagerInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalUncheckedCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeUncheckedCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentUncheckedCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodUncheckedCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodUncheckedCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionUncheckedCreateNestedManyWithoutOwnerUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutDirectReportsNestedInput
    directReports?: UserUpdateManyWithoutManagerNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directReports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUncheckedUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUncheckedUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUncheckedUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUncheckedUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUncheckedUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUncheckedUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserCreateWithoutPreferencesInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutDirectReportsInput
    directReports?: UserCreateNestedManyWithoutManagerInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    approvals?: ChangeApprovalCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionCreateNestedManyWithoutOwnerUserInput
  }

  export type UserUncheckedCreateWithoutPreferencesInput = {
    id?: string
    orgId: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    managerId?: string | null
    departmentId?: string | null
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    directReports?: UserUncheckedCreateNestedManyWithoutManagerInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    approvals?: ChangeApprovalUncheckedCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeUncheckedCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentUncheckedCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodUncheckedCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodUncheckedCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionUncheckedCreateNestedManyWithoutOwnerUserInput
  }

  export type UserCreateOrConnectWithoutPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
  }

  export type UserUpsertWithoutPreferencesInput = {
    update: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
    create: XOR<UserCreateWithoutPreferencesInput, UserUncheckedCreateWithoutPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPreferencesInput, UserUncheckedUpdateWithoutPreferencesInput>
  }

  export type UserUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutDirectReportsNestedInput
    directReports?: UserUpdateManyWithoutManagerNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    approvals?: ChangeApprovalUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directReports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    approvals?: ChangeApprovalUncheckedUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUncheckedUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUncheckedUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUncheckedUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUncheckedUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUncheckedUpdateManyWithoutOwnerUserNestedInput
  }

  export type OrganizationCreateWithoutChangeRequestsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserCreateNestedManyWithoutOrgInput
    departments?: DepartmentCreateNestedManyWithoutOrgInput
    nodes?: NodeCreateNestedManyWithoutOrgInput
    kpis?: KpiDefinitionCreateNestedManyWithoutOrgInput
  }

  export type OrganizationUncheckedCreateWithoutChangeRequestsInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutOrgInput
    nodes?: NodeUncheckedCreateNestedManyWithoutOrgInput
    kpis?: KpiDefinitionUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrganizationCreateOrConnectWithoutChangeRequestsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutChangeRequestsInput, OrganizationUncheckedCreateWithoutChangeRequestsInput>
  }

  export type UserCreateWithoutChangeRequestsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutDirectReportsInput
    directReports?: UserCreateNestedManyWithoutManagerInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalCreateNestedManyWithoutApproverInput
    ownedNodes?: NodeCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionCreateNestedManyWithoutOwnerUserInput
  }

  export type UserUncheckedCreateWithoutChangeRequestsInput = {
    id?: string
    orgId: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    managerId?: string | null
    departmentId?: string | null
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    directReports?: UserUncheckedCreateNestedManyWithoutManagerInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalUncheckedCreateNestedManyWithoutApproverInput
    ownedNodes?: NodeUncheckedCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentUncheckedCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodUncheckedCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodUncheckedCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionUncheckedCreateNestedManyWithoutOwnerUserInput
  }

  export type UserCreateOrConnectWithoutChangeRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChangeRequestsInput, UserUncheckedCreateWithoutChangeRequestsInput>
  }

  export type ChangeApprovalCreateWithoutChangeRequestInput = {
    id?: string
    status?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    decidedAt?: Date | string | null
    approver: UserCreateNestedOneWithoutApprovalsInput
  }

  export type ChangeApprovalUncheckedCreateWithoutChangeRequestInput = {
    id?: string
    approverId: string
    status?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    decidedAt?: Date | string | null
  }

  export type ChangeApprovalCreateOrConnectWithoutChangeRequestInput = {
    where: ChangeApprovalWhereUniqueInput
    create: XOR<ChangeApprovalCreateWithoutChangeRequestInput, ChangeApprovalUncheckedCreateWithoutChangeRequestInput>
  }

  export type ChangeApprovalCreateManyChangeRequestInputEnvelope = {
    data: ChangeApprovalCreateManyChangeRequestInput | ChangeApprovalCreateManyChangeRequestInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutChangeRequestsInput = {
    update: XOR<OrganizationUpdateWithoutChangeRequestsInput, OrganizationUncheckedUpdateWithoutChangeRequestsInput>
    create: XOR<OrganizationCreateWithoutChangeRequestsInput, OrganizationUncheckedCreateWithoutChangeRequestsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutChangeRequestsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutChangeRequestsInput, OrganizationUncheckedUpdateWithoutChangeRequestsInput>
  }

  export type OrganizationUpdateWithoutChangeRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutOrgNestedInput
    departments?: DepartmentUpdateManyWithoutOrgNestedInput
    nodes?: NodeUpdateManyWithoutOrgNestedInput
    kpis?: KpiDefinitionUpdateManyWithoutOrgNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutChangeRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutOrgNestedInput
    nodes?: NodeUncheckedUpdateManyWithoutOrgNestedInput
    kpis?: KpiDefinitionUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type UserUpsertWithoutChangeRequestsInput = {
    update: XOR<UserUpdateWithoutChangeRequestsInput, UserUncheckedUpdateWithoutChangeRequestsInput>
    create: XOR<UserCreateWithoutChangeRequestsInput, UserUncheckedCreateWithoutChangeRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChangeRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChangeRequestsInput, UserUncheckedUpdateWithoutChangeRequestsInput>
  }

  export type UserUpdateWithoutChangeRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutDirectReportsNestedInput
    directReports?: UserUpdateManyWithoutManagerNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUpdateManyWithoutApproverNestedInput
    ownedNodes?: NodeUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChangeRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directReports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUncheckedUpdateManyWithoutApproverNestedInput
    ownedNodes?: NodeUncheckedUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUncheckedUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUncheckedUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUncheckedUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUncheckedUpdateManyWithoutOwnerUserNestedInput
  }

  export type ChangeApprovalUpsertWithWhereUniqueWithoutChangeRequestInput = {
    where: ChangeApprovalWhereUniqueInput
    update: XOR<ChangeApprovalUpdateWithoutChangeRequestInput, ChangeApprovalUncheckedUpdateWithoutChangeRequestInput>
    create: XOR<ChangeApprovalCreateWithoutChangeRequestInput, ChangeApprovalUncheckedCreateWithoutChangeRequestInput>
  }

  export type ChangeApprovalUpdateWithWhereUniqueWithoutChangeRequestInput = {
    where: ChangeApprovalWhereUniqueInput
    data: XOR<ChangeApprovalUpdateWithoutChangeRequestInput, ChangeApprovalUncheckedUpdateWithoutChangeRequestInput>
  }

  export type ChangeApprovalUpdateManyWithWhereWithoutChangeRequestInput = {
    where: ChangeApprovalScalarWhereInput
    data: XOR<ChangeApprovalUpdateManyMutationInput, ChangeApprovalUncheckedUpdateManyWithoutChangeRequestInput>
  }

  export type ChangeRequestCreateWithoutApprovalsInput = {
    id?: string
    entityType: string
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    decidedAt?: Date | string | null
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutChangeRequestsInput
    requester: UserCreateNestedOneWithoutChangeRequestsInput
  }

  export type ChangeRequestUncheckedCreateWithoutApprovalsInput = {
    id?: string
    orgId: string
    entityType: string
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.ApprovalStatus
    requestedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    decidedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ChangeRequestCreateOrConnectWithoutApprovalsInput = {
    where: ChangeRequestWhereUniqueInput
    create: XOR<ChangeRequestCreateWithoutApprovalsInput, ChangeRequestUncheckedCreateWithoutApprovalsInput>
  }

  export type UserCreateWithoutApprovalsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutDirectReportsInput
    directReports?: UserCreateNestedManyWithoutManagerInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionCreateNestedManyWithoutOwnerUserInput
  }

  export type UserUncheckedCreateWithoutApprovalsInput = {
    id?: string
    orgId: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    managerId?: string | null
    departmentId?: string | null
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    directReports?: UserUncheckedCreateNestedManyWithoutManagerInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeUncheckedCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentUncheckedCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodUncheckedCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodUncheckedCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionUncheckedCreateNestedManyWithoutOwnerUserInput
  }

  export type UserCreateOrConnectWithoutApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovalsInput, UserUncheckedCreateWithoutApprovalsInput>
  }

  export type ChangeRequestUpsertWithoutApprovalsInput = {
    update: XOR<ChangeRequestUpdateWithoutApprovalsInput, ChangeRequestUncheckedUpdateWithoutApprovalsInput>
    create: XOR<ChangeRequestCreateWithoutApprovalsInput, ChangeRequestUncheckedCreateWithoutApprovalsInput>
    where?: ChangeRequestWhereInput
  }

  export type ChangeRequestUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: ChangeRequestWhereInput
    data: XOR<ChangeRequestUpdateWithoutApprovalsInput, ChangeRequestUncheckedUpdateWithoutApprovalsInput>
  }

  export type ChangeRequestUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutChangeRequestsNestedInput
    requester?: UserUpdateOneRequiredWithoutChangeRequestsNestedInput
  }

  export type ChangeRequestUncheckedUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    requestedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpsertWithoutApprovalsInput = {
    update: XOR<UserUpdateWithoutApprovalsInput, UserUncheckedUpdateWithoutApprovalsInput>
    create: XOR<UserCreateWithoutApprovalsInput, UserUncheckedCreateWithoutApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovalsInput, UserUncheckedUpdateWithoutApprovalsInput>
  }

  export type UserUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutDirectReportsNestedInput
    directReports?: UserUpdateManyWithoutManagerNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directReports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUncheckedUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUncheckedUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUncheckedUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUncheckedUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUncheckedUpdateManyWithoutOwnerUserNestedInput
  }

  export type NodeCreateWithoutNodeTypeInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutNodesInput
    parent?: NodeCreateNestedOneWithoutChildrenInput
    children?: NodeCreateNestedManyWithoutParentInput
    ownerUser?: UserCreateNestedOneWithoutOwnedNodesInput
    assignments?: NodeAssignmentCreateNestedManyWithoutNodeInput
    outgoingDeps?: NodeDependencyCreateNestedManyWithoutDependsOnNodeInput
    incomingDeps?: NodeDependencyCreateNestedManyWithoutBlockedNodeInput
    kpis?: KpiDefinitionCreateNestedManyWithoutPrimaryNodeInput
  }

  export type NodeUncheckedCreateWithoutNodeTypeInput = {
    id?: string
    orgId: string
    parentId?: string | null
    name: string
    description?: string | null
    ownerUserId?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: NodeUncheckedCreateNestedManyWithoutParentInput
    assignments?: NodeAssignmentUncheckedCreateNestedManyWithoutNodeInput
    outgoingDeps?: NodeDependencyUncheckedCreateNestedManyWithoutDependsOnNodeInput
    incomingDeps?: NodeDependencyUncheckedCreateNestedManyWithoutBlockedNodeInput
    kpis?: KpiDefinitionUncheckedCreateNestedManyWithoutPrimaryNodeInput
  }

  export type NodeCreateOrConnectWithoutNodeTypeInput = {
    where: NodeWhereUniqueInput
    create: XOR<NodeCreateWithoutNodeTypeInput, NodeUncheckedCreateWithoutNodeTypeInput>
  }

  export type NodeCreateManyNodeTypeInputEnvelope = {
    data: NodeCreateManyNodeTypeInput | NodeCreateManyNodeTypeInput[]
    skipDuplicates?: boolean
  }

  export type NodeUpsertWithWhereUniqueWithoutNodeTypeInput = {
    where: NodeWhereUniqueInput
    update: XOR<NodeUpdateWithoutNodeTypeInput, NodeUncheckedUpdateWithoutNodeTypeInput>
    create: XOR<NodeCreateWithoutNodeTypeInput, NodeUncheckedCreateWithoutNodeTypeInput>
  }

  export type NodeUpdateWithWhereUniqueWithoutNodeTypeInput = {
    where: NodeWhereUniqueInput
    data: XOR<NodeUpdateWithoutNodeTypeInput, NodeUncheckedUpdateWithoutNodeTypeInput>
  }

  export type NodeUpdateManyWithWhereWithoutNodeTypeInput = {
    where: NodeScalarWhereInput
    data: XOR<NodeUpdateManyMutationInput, NodeUncheckedUpdateManyWithoutNodeTypeInput>
  }

  export type OrganizationCreateWithoutNodesInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserCreateNestedManyWithoutOrgInput
    departments?: DepartmentCreateNestedManyWithoutOrgInput
    kpis?: KpiDefinitionCreateNestedManyWithoutOrgInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutOrgInput
  }

  export type OrganizationUncheckedCreateWithoutNodesInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutOrgInput
    kpis?: KpiDefinitionUncheckedCreateNestedManyWithoutOrgInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrganizationCreateOrConnectWithoutNodesInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutNodesInput, OrganizationUncheckedCreateWithoutNodesInput>
  }

  export type NodeTypeCreateWithoutNodesInput = {
    id?: string
    code: $Enums.NodeTypeCode
    displayName: string
    levelOrder: number
    canHaveKpis?: boolean
  }

  export type NodeTypeUncheckedCreateWithoutNodesInput = {
    id?: string
    code: $Enums.NodeTypeCode
    displayName: string
    levelOrder: number
    canHaveKpis?: boolean
  }

  export type NodeTypeCreateOrConnectWithoutNodesInput = {
    where: NodeTypeWhereUniqueInput
    create: XOR<NodeTypeCreateWithoutNodesInput, NodeTypeUncheckedCreateWithoutNodesInput>
  }

  export type NodeCreateWithoutChildrenInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutNodesInput
    nodeType: NodeTypeCreateNestedOneWithoutNodesInput
    parent?: NodeCreateNestedOneWithoutChildrenInput
    ownerUser?: UserCreateNestedOneWithoutOwnedNodesInput
    assignments?: NodeAssignmentCreateNestedManyWithoutNodeInput
    outgoingDeps?: NodeDependencyCreateNestedManyWithoutDependsOnNodeInput
    incomingDeps?: NodeDependencyCreateNestedManyWithoutBlockedNodeInput
    kpis?: KpiDefinitionCreateNestedManyWithoutPrimaryNodeInput
  }

  export type NodeUncheckedCreateWithoutChildrenInput = {
    id?: string
    orgId: string
    nodeTypeId: string
    parentId?: string | null
    name: string
    description?: string | null
    ownerUserId?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    assignments?: NodeAssignmentUncheckedCreateNestedManyWithoutNodeInput
    outgoingDeps?: NodeDependencyUncheckedCreateNestedManyWithoutDependsOnNodeInput
    incomingDeps?: NodeDependencyUncheckedCreateNestedManyWithoutBlockedNodeInput
    kpis?: KpiDefinitionUncheckedCreateNestedManyWithoutPrimaryNodeInput
  }

  export type NodeCreateOrConnectWithoutChildrenInput = {
    where: NodeWhereUniqueInput
    create: XOR<NodeCreateWithoutChildrenInput, NodeUncheckedCreateWithoutChildrenInput>
  }

  export type NodeCreateWithoutParentInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutNodesInput
    nodeType: NodeTypeCreateNestedOneWithoutNodesInput
    children?: NodeCreateNestedManyWithoutParentInput
    ownerUser?: UserCreateNestedOneWithoutOwnedNodesInput
    assignments?: NodeAssignmentCreateNestedManyWithoutNodeInput
    outgoingDeps?: NodeDependencyCreateNestedManyWithoutDependsOnNodeInput
    incomingDeps?: NodeDependencyCreateNestedManyWithoutBlockedNodeInput
    kpis?: KpiDefinitionCreateNestedManyWithoutPrimaryNodeInput
  }

  export type NodeUncheckedCreateWithoutParentInput = {
    id?: string
    orgId: string
    nodeTypeId: string
    name: string
    description?: string | null
    ownerUserId?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: NodeUncheckedCreateNestedManyWithoutParentInput
    assignments?: NodeAssignmentUncheckedCreateNestedManyWithoutNodeInput
    outgoingDeps?: NodeDependencyUncheckedCreateNestedManyWithoutDependsOnNodeInput
    incomingDeps?: NodeDependencyUncheckedCreateNestedManyWithoutBlockedNodeInput
    kpis?: KpiDefinitionUncheckedCreateNestedManyWithoutPrimaryNodeInput
  }

  export type NodeCreateOrConnectWithoutParentInput = {
    where: NodeWhereUniqueInput
    create: XOR<NodeCreateWithoutParentInput, NodeUncheckedCreateWithoutParentInput>
  }

  export type NodeCreateManyParentInputEnvelope = {
    data: NodeCreateManyParentInput | NodeCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutOwnedNodesInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutDirectReportsInput
    directReports?: UserCreateNestedManyWithoutManagerInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutRequesterInput
    nodeAssignments?: NodeAssignmentCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionCreateNestedManyWithoutOwnerUserInput
  }

  export type UserUncheckedCreateWithoutOwnedNodesInput = {
    id?: string
    orgId: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    managerId?: string | null
    departmentId?: string | null
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    directReports?: UserUncheckedCreateNestedManyWithoutManagerInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalUncheckedCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutRequesterInput
    nodeAssignments?: NodeAssignmentUncheckedCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodUncheckedCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodUncheckedCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionUncheckedCreateNestedManyWithoutOwnerUserInput
  }

  export type UserCreateOrConnectWithoutOwnedNodesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedNodesInput, UserUncheckedCreateWithoutOwnedNodesInput>
  }

  export type NodeAssignmentCreateWithoutNodeInput = {
    id?: string
    role?: $Enums.NodeAssignmentRole
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNodeAssignmentsInput
  }

  export type NodeAssignmentUncheckedCreateWithoutNodeInput = {
    id?: string
    userId: string
    role?: $Enums.NodeAssignmentRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NodeAssignmentCreateOrConnectWithoutNodeInput = {
    where: NodeAssignmentWhereUniqueInput
    create: XOR<NodeAssignmentCreateWithoutNodeInput, NodeAssignmentUncheckedCreateWithoutNodeInput>
  }

  export type NodeAssignmentCreateManyNodeInputEnvelope = {
    data: NodeAssignmentCreateManyNodeInput | NodeAssignmentCreateManyNodeInput[]
    skipDuplicates?: boolean
  }

  export type NodeDependencyCreateWithoutDependsOnNodeInput = {
    id?: string
    createdAt?: Date | string
    blockedNode: NodeCreateNestedOneWithoutIncomingDepsInput
  }

  export type NodeDependencyUncheckedCreateWithoutDependsOnNodeInput = {
    id?: string
    blockedNodeId: string
    createdAt?: Date | string
  }

  export type NodeDependencyCreateOrConnectWithoutDependsOnNodeInput = {
    where: NodeDependencyWhereUniqueInput
    create: XOR<NodeDependencyCreateWithoutDependsOnNodeInput, NodeDependencyUncheckedCreateWithoutDependsOnNodeInput>
  }

  export type NodeDependencyCreateManyDependsOnNodeInputEnvelope = {
    data: NodeDependencyCreateManyDependsOnNodeInput | NodeDependencyCreateManyDependsOnNodeInput[]
    skipDuplicates?: boolean
  }

  export type NodeDependencyCreateWithoutBlockedNodeInput = {
    id?: string
    createdAt?: Date | string
    dependsOnNode: NodeCreateNestedOneWithoutOutgoingDepsInput
  }

  export type NodeDependencyUncheckedCreateWithoutBlockedNodeInput = {
    id?: string
    dependsOnNodeId: string
    createdAt?: Date | string
  }

  export type NodeDependencyCreateOrConnectWithoutBlockedNodeInput = {
    where: NodeDependencyWhereUniqueInput
    create: XOR<NodeDependencyCreateWithoutBlockedNodeInput, NodeDependencyUncheckedCreateWithoutBlockedNodeInput>
  }

  export type NodeDependencyCreateManyBlockedNodeInputEnvelope = {
    data: NodeDependencyCreateManyBlockedNodeInput | NodeDependencyCreateManyBlockedNodeInput[]
    skipDuplicates?: boolean
  }

  export type KpiDefinitionCreateWithoutPrimaryNodeInput = {
    id?: string
    name: string
    description?: string | null
    formula?: string | null
    unit?: string | null
    direction?: $Enums.KpiDirection
    aggregation?: $Enums.KpiAggregationMethod
    periodType: $Enums.KpiPeriodType
    baselineValue?: number | null
    targetValue?: number | null
    weight?: number | null
    status?: $Enums.KpiDefinitionStatus
    org: OrganizationCreateNestedOneWithoutKpisInput
    ownerUser?: UserCreateNestedOneWithoutOwnedKpisInput
    variables?: KpiVariableCreateNestedManyWithoutKpiInput
    values?: KpiValuePeriodCreateNestedManyWithoutKpiInput
  }

  export type KpiDefinitionUncheckedCreateWithoutPrimaryNodeInput = {
    id?: string
    orgId: string
    ownerUserId?: string | null
    name: string
    description?: string | null
    formula?: string | null
    unit?: string | null
    direction?: $Enums.KpiDirection
    aggregation?: $Enums.KpiAggregationMethod
    periodType: $Enums.KpiPeriodType
    baselineValue?: number | null
    targetValue?: number | null
    weight?: number | null
    status?: $Enums.KpiDefinitionStatus
    variables?: KpiVariableUncheckedCreateNestedManyWithoutKpiInput
    values?: KpiValuePeriodUncheckedCreateNestedManyWithoutKpiInput
  }

  export type KpiDefinitionCreateOrConnectWithoutPrimaryNodeInput = {
    where: KpiDefinitionWhereUniqueInput
    create: XOR<KpiDefinitionCreateWithoutPrimaryNodeInput, KpiDefinitionUncheckedCreateWithoutPrimaryNodeInput>
  }

  export type KpiDefinitionCreateManyPrimaryNodeInputEnvelope = {
    data: KpiDefinitionCreateManyPrimaryNodeInput | KpiDefinitionCreateManyPrimaryNodeInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutNodesInput = {
    update: XOR<OrganizationUpdateWithoutNodesInput, OrganizationUncheckedUpdateWithoutNodesInput>
    create: XOR<OrganizationCreateWithoutNodesInput, OrganizationUncheckedCreateWithoutNodesInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutNodesInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutNodesInput, OrganizationUncheckedUpdateWithoutNodesInput>
  }

  export type OrganizationUpdateWithoutNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutOrgNestedInput
    departments?: DepartmentUpdateManyWithoutOrgNestedInput
    kpis?: KpiDefinitionUpdateManyWithoutOrgNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutOrgNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutOrgNestedInput
    kpis?: KpiDefinitionUncheckedUpdateManyWithoutOrgNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type NodeTypeUpsertWithoutNodesInput = {
    update: XOR<NodeTypeUpdateWithoutNodesInput, NodeTypeUncheckedUpdateWithoutNodesInput>
    create: XOR<NodeTypeCreateWithoutNodesInput, NodeTypeUncheckedCreateWithoutNodesInput>
    where?: NodeTypeWhereInput
  }

  export type NodeTypeUpdateToOneWithWhereWithoutNodesInput = {
    where?: NodeTypeWhereInput
    data: XOR<NodeTypeUpdateWithoutNodesInput, NodeTypeUncheckedUpdateWithoutNodesInput>
  }

  export type NodeTypeUpdateWithoutNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: EnumNodeTypeCodeFieldUpdateOperationsInput | $Enums.NodeTypeCode
    displayName?: StringFieldUpdateOperationsInput | string
    levelOrder?: IntFieldUpdateOperationsInput | number
    canHaveKpis?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NodeTypeUncheckedUpdateWithoutNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: EnumNodeTypeCodeFieldUpdateOperationsInput | $Enums.NodeTypeCode
    displayName?: StringFieldUpdateOperationsInput | string
    levelOrder?: IntFieldUpdateOperationsInput | number
    canHaveKpis?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NodeUpsertWithoutChildrenInput = {
    update: XOR<NodeUpdateWithoutChildrenInput, NodeUncheckedUpdateWithoutChildrenInput>
    create: XOR<NodeCreateWithoutChildrenInput, NodeUncheckedCreateWithoutChildrenInput>
    where?: NodeWhereInput
  }

  export type NodeUpdateToOneWithWhereWithoutChildrenInput = {
    where?: NodeWhereInput
    data: XOR<NodeUpdateWithoutChildrenInput, NodeUncheckedUpdateWithoutChildrenInput>
  }

  export type NodeUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutNodesNestedInput
    nodeType?: NodeTypeUpdateOneRequiredWithoutNodesNestedInput
    parent?: NodeUpdateOneWithoutChildrenNestedInput
    ownerUser?: UserUpdateOneWithoutOwnedNodesNestedInput
    assignments?: NodeAssignmentUpdateManyWithoutNodeNestedInput
    outgoingDeps?: NodeDependencyUpdateManyWithoutDependsOnNodeNestedInput
    incomingDeps?: NodeDependencyUpdateManyWithoutBlockedNodeNestedInput
    kpis?: KpiDefinitionUpdateManyWithoutPrimaryNodeNestedInput
  }

  export type NodeUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    nodeTypeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignments?: NodeAssignmentUncheckedUpdateManyWithoutNodeNestedInput
    outgoingDeps?: NodeDependencyUncheckedUpdateManyWithoutDependsOnNodeNestedInput
    incomingDeps?: NodeDependencyUncheckedUpdateManyWithoutBlockedNodeNestedInput
    kpis?: KpiDefinitionUncheckedUpdateManyWithoutPrimaryNodeNestedInput
  }

  export type NodeUpsertWithWhereUniqueWithoutParentInput = {
    where: NodeWhereUniqueInput
    update: XOR<NodeUpdateWithoutParentInput, NodeUncheckedUpdateWithoutParentInput>
    create: XOR<NodeCreateWithoutParentInput, NodeUncheckedCreateWithoutParentInput>
  }

  export type NodeUpdateWithWhereUniqueWithoutParentInput = {
    where: NodeWhereUniqueInput
    data: XOR<NodeUpdateWithoutParentInput, NodeUncheckedUpdateWithoutParentInput>
  }

  export type NodeUpdateManyWithWhereWithoutParentInput = {
    where: NodeScalarWhereInput
    data: XOR<NodeUpdateManyMutationInput, NodeUncheckedUpdateManyWithoutParentInput>
  }

  export type UserUpsertWithoutOwnedNodesInput = {
    update: XOR<UserUpdateWithoutOwnedNodesInput, UserUncheckedUpdateWithoutOwnedNodesInput>
    create: XOR<UserCreateWithoutOwnedNodesInput, UserUncheckedCreateWithoutOwnedNodesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedNodesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedNodesInput, UserUncheckedUpdateWithoutOwnedNodesInput>
  }

  export type UserUpdateWithoutOwnedNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutDirectReportsNestedInput
    directReports?: UserUpdateManyWithoutManagerNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutRequesterNestedInput
    nodeAssignments?: NodeAssignmentUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directReports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUncheckedUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutRequesterNestedInput
    nodeAssignments?: NodeAssignmentUncheckedUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUncheckedUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUncheckedUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUncheckedUpdateManyWithoutOwnerUserNestedInput
  }

  export type NodeAssignmentUpsertWithWhereUniqueWithoutNodeInput = {
    where: NodeAssignmentWhereUniqueInput
    update: XOR<NodeAssignmentUpdateWithoutNodeInput, NodeAssignmentUncheckedUpdateWithoutNodeInput>
    create: XOR<NodeAssignmentCreateWithoutNodeInput, NodeAssignmentUncheckedCreateWithoutNodeInput>
  }

  export type NodeAssignmentUpdateWithWhereUniqueWithoutNodeInput = {
    where: NodeAssignmentWhereUniqueInput
    data: XOR<NodeAssignmentUpdateWithoutNodeInput, NodeAssignmentUncheckedUpdateWithoutNodeInput>
  }

  export type NodeAssignmentUpdateManyWithWhereWithoutNodeInput = {
    where: NodeAssignmentScalarWhereInput
    data: XOR<NodeAssignmentUpdateManyMutationInput, NodeAssignmentUncheckedUpdateManyWithoutNodeInput>
  }

  export type NodeDependencyUpsertWithWhereUniqueWithoutDependsOnNodeInput = {
    where: NodeDependencyWhereUniqueInput
    update: XOR<NodeDependencyUpdateWithoutDependsOnNodeInput, NodeDependencyUncheckedUpdateWithoutDependsOnNodeInput>
    create: XOR<NodeDependencyCreateWithoutDependsOnNodeInput, NodeDependencyUncheckedCreateWithoutDependsOnNodeInput>
  }

  export type NodeDependencyUpdateWithWhereUniqueWithoutDependsOnNodeInput = {
    where: NodeDependencyWhereUniqueInput
    data: XOR<NodeDependencyUpdateWithoutDependsOnNodeInput, NodeDependencyUncheckedUpdateWithoutDependsOnNodeInput>
  }

  export type NodeDependencyUpdateManyWithWhereWithoutDependsOnNodeInput = {
    where: NodeDependencyScalarWhereInput
    data: XOR<NodeDependencyUpdateManyMutationInput, NodeDependencyUncheckedUpdateManyWithoutDependsOnNodeInput>
  }

  export type NodeDependencyScalarWhereInput = {
    AND?: NodeDependencyScalarWhereInput | NodeDependencyScalarWhereInput[]
    OR?: NodeDependencyScalarWhereInput[]
    NOT?: NodeDependencyScalarWhereInput | NodeDependencyScalarWhereInput[]
    id?: StringFilter<"NodeDependency"> | string
    blockedNodeId?: StringFilter<"NodeDependency"> | string
    dependsOnNodeId?: StringFilter<"NodeDependency"> | string
    createdAt?: DateTimeFilter<"NodeDependency"> | Date | string
  }

  export type NodeDependencyUpsertWithWhereUniqueWithoutBlockedNodeInput = {
    where: NodeDependencyWhereUniqueInput
    update: XOR<NodeDependencyUpdateWithoutBlockedNodeInput, NodeDependencyUncheckedUpdateWithoutBlockedNodeInput>
    create: XOR<NodeDependencyCreateWithoutBlockedNodeInput, NodeDependencyUncheckedCreateWithoutBlockedNodeInput>
  }

  export type NodeDependencyUpdateWithWhereUniqueWithoutBlockedNodeInput = {
    where: NodeDependencyWhereUniqueInput
    data: XOR<NodeDependencyUpdateWithoutBlockedNodeInput, NodeDependencyUncheckedUpdateWithoutBlockedNodeInput>
  }

  export type NodeDependencyUpdateManyWithWhereWithoutBlockedNodeInput = {
    where: NodeDependencyScalarWhereInput
    data: XOR<NodeDependencyUpdateManyMutationInput, NodeDependencyUncheckedUpdateManyWithoutBlockedNodeInput>
  }

  export type KpiDefinitionUpsertWithWhereUniqueWithoutPrimaryNodeInput = {
    where: KpiDefinitionWhereUniqueInput
    update: XOR<KpiDefinitionUpdateWithoutPrimaryNodeInput, KpiDefinitionUncheckedUpdateWithoutPrimaryNodeInput>
    create: XOR<KpiDefinitionCreateWithoutPrimaryNodeInput, KpiDefinitionUncheckedCreateWithoutPrimaryNodeInput>
  }

  export type KpiDefinitionUpdateWithWhereUniqueWithoutPrimaryNodeInput = {
    where: KpiDefinitionWhereUniqueInput
    data: XOR<KpiDefinitionUpdateWithoutPrimaryNodeInput, KpiDefinitionUncheckedUpdateWithoutPrimaryNodeInput>
  }

  export type KpiDefinitionUpdateManyWithWhereWithoutPrimaryNodeInput = {
    where: KpiDefinitionScalarWhereInput
    data: XOR<KpiDefinitionUpdateManyMutationInput, KpiDefinitionUncheckedUpdateManyWithoutPrimaryNodeInput>
  }

  export type NodeCreateWithoutAssignmentsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutNodesInput
    nodeType: NodeTypeCreateNestedOneWithoutNodesInput
    parent?: NodeCreateNestedOneWithoutChildrenInput
    children?: NodeCreateNestedManyWithoutParentInput
    ownerUser?: UserCreateNestedOneWithoutOwnedNodesInput
    outgoingDeps?: NodeDependencyCreateNestedManyWithoutDependsOnNodeInput
    incomingDeps?: NodeDependencyCreateNestedManyWithoutBlockedNodeInput
    kpis?: KpiDefinitionCreateNestedManyWithoutPrimaryNodeInput
  }

  export type NodeUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    orgId: string
    nodeTypeId: string
    parentId?: string | null
    name: string
    description?: string | null
    ownerUserId?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: NodeUncheckedCreateNestedManyWithoutParentInput
    outgoingDeps?: NodeDependencyUncheckedCreateNestedManyWithoutDependsOnNodeInput
    incomingDeps?: NodeDependencyUncheckedCreateNestedManyWithoutBlockedNodeInput
    kpis?: KpiDefinitionUncheckedCreateNestedManyWithoutPrimaryNodeInput
  }

  export type NodeCreateOrConnectWithoutAssignmentsInput = {
    where: NodeWhereUniqueInput
    create: XOR<NodeCreateWithoutAssignmentsInput, NodeUncheckedCreateWithoutAssignmentsInput>
  }

  export type UserCreateWithoutNodeAssignmentsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutDirectReportsInput
    directReports?: UserCreateNestedManyWithoutManagerInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeCreateNestedManyWithoutOwnerUserInput
    kpiValuesEntered?: KpiValuePeriodCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionCreateNestedManyWithoutOwnerUserInput
  }

  export type UserUncheckedCreateWithoutNodeAssignmentsInput = {
    id?: string
    orgId: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    managerId?: string | null
    departmentId?: string | null
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    directReports?: UserUncheckedCreateNestedManyWithoutManagerInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalUncheckedCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeUncheckedCreateNestedManyWithoutOwnerUserInput
    kpiValuesEntered?: KpiValuePeriodUncheckedCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodUncheckedCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionUncheckedCreateNestedManyWithoutOwnerUserInput
  }

  export type UserCreateOrConnectWithoutNodeAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNodeAssignmentsInput, UserUncheckedCreateWithoutNodeAssignmentsInput>
  }

  export type NodeUpsertWithoutAssignmentsInput = {
    update: XOR<NodeUpdateWithoutAssignmentsInput, NodeUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<NodeCreateWithoutAssignmentsInput, NodeUncheckedCreateWithoutAssignmentsInput>
    where?: NodeWhereInput
  }

  export type NodeUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: NodeWhereInput
    data: XOR<NodeUpdateWithoutAssignmentsInput, NodeUncheckedUpdateWithoutAssignmentsInput>
  }

  export type NodeUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutNodesNestedInput
    nodeType?: NodeTypeUpdateOneRequiredWithoutNodesNestedInput
    parent?: NodeUpdateOneWithoutChildrenNestedInput
    children?: NodeUpdateManyWithoutParentNestedInput
    ownerUser?: UserUpdateOneWithoutOwnedNodesNestedInput
    outgoingDeps?: NodeDependencyUpdateManyWithoutDependsOnNodeNestedInput
    incomingDeps?: NodeDependencyUpdateManyWithoutBlockedNodeNestedInput
    kpis?: KpiDefinitionUpdateManyWithoutPrimaryNodeNestedInput
  }

  export type NodeUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    nodeTypeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: NodeUncheckedUpdateManyWithoutParentNestedInput
    outgoingDeps?: NodeDependencyUncheckedUpdateManyWithoutDependsOnNodeNestedInput
    incomingDeps?: NodeDependencyUncheckedUpdateManyWithoutBlockedNodeNestedInput
    kpis?: KpiDefinitionUncheckedUpdateManyWithoutPrimaryNodeNestedInput
  }

  export type UserUpsertWithoutNodeAssignmentsInput = {
    update: XOR<UserUpdateWithoutNodeAssignmentsInput, UserUncheckedUpdateWithoutNodeAssignmentsInput>
    create: XOR<UserCreateWithoutNodeAssignmentsInput, UserUncheckedCreateWithoutNodeAssignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNodeAssignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNodeAssignmentsInput, UserUncheckedUpdateWithoutNodeAssignmentsInput>
  }

  export type UserUpdateWithoutNodeAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutDirectReportsNestedInput
    directReports?: UserUpdateManyWithoutManagerNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUpdateManyWithoutOwnerUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNodeAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directReports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUncheckedUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUncheckedUpdateManyWithoutOwnerUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUncheckedUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUncheckedUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUncheckedUpdateManyWithoutOwnerUserNestedInput
  }

  export type NodeCreateWithoutIncomingDepsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutNodesInput
    nodeType: NodeTypeCreateNestedOneWithoutNodesInput
    parent?: NodeCreateNestedOneWithoutChildrenInput
    children?: NodeCreateNestedManyWithoutParentInput
    ownerUser?: UserCreateNestedOneWithoutOwnedNodesInput
    assignments?: NodeAssignmentCreateNestedManyWithoutNodeInput
    outgoingDeps?: NodeDependencyCreateNestedManyWithoutDependsOnNodeInput
    kpis?: KpiDefinitionCreateNestedManyWithoutPrimaryNodeInput
  }

  export type NodeUncheckedCreateWithoutIncomingDepsInput = {
    id?: string
    orgId: string
    nodeTypeId: string
    parentId?: string | null
    name: string
    description?: string | null
    ownerUserId?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: NodeUncheckedCreateNestedManyWithoutParentInput
    assignments?: NodeAssignmentUncheckedCreateNestedManyWithoutNodeInput
    outgoingDeps?: NodeDependencyUncheckedCreateNestedManyWithoutDependsOnNodeInput
    kpis?: KpiDefinitionUncheckedCreateNestedManyWithoutPrimaryNodeInput
  }

  export type NodeCreateOrConnectWithoutIncomingDepsInput = {
    where: NodeWhereUniqueInput
    create: XOR<NodeCreateWithoutIncomingDepsInput, NodeUncheckedCreateWithoutIncomingDepsInput>
  }

  export type NodeCreateWithoutOutgoingDepsInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutNodesInput
    nodeType: NodeTypeCreateNestedOneWithoutNodesInput
    parent?: NodeCreateNestedOneWithoutChildrenInput
    children?: NodeCreateNestedManyWithoutParentInput
    ownerUser?: UserCreateNestedOneWithoutOwnedNodesInput
    assignments?: NodeAssignmentCreateNestedManyWithoutNodeInput
    incomingDeps?: NodeDependencyCreateNestedManyWithoutBlockedNodeInput
    kpis?: KpiDefinitionCreateNestedManyWithoutPrimaryNodeInput
  }

  export type NodeUncheckedCreateWithoutOutgoingDepsInput = {
    id?: string
    orgId: string
    nodeTypeId: string
    parentId?: string | null
    name: string
    description?: string | null
    ownerUserId?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: NodeUncheckedCreateNestedManyWithoutParentInput
    assignments?: NodeAssignmentUncheckedCreateNestedManyWithoutNodeInput
    incomingDeps?: NodeDependencyUncheckedCreateNestedManyWithoutBlockedNodeInput
    kpis?: KpiDefinitionUncheckedCreateNestedManyWithoutPrimaryNodeInput
  }

  export type NodeCreateOrConnectWithoutOutgoingDepsInput = {
    where: NodeWhereUniqueInput
    create: XOR<NodeCreateWithoutOutgoingDepsInput, NodeUncheckedCreateWithoutOutgoingDepsInput>
  }

  export type NodeUpsertWithoutIncomingDepsInput = {
    update: XOR<NodeUpdateWithoutIncomingDepsInput, NodeUncheckedUpdateWithoutIncomingDepsInput>
    create: XOR<NodeCreateWithoutIncomingDepsInput, NodeUncheckedCreateWithoutIncomingDepsInput>
    where?: NodeWhereInput
  }

  export type NodeUpdateToOneWithWhereWithoutIncomingDepsInput = {
    where?: NodeWhereInput
    data: XOR<NodeUpdateWithoutIncomingDepsInput, NodeUncheckedUpdateWithoutIncomingDepsInput>
  }

  export type NodeUpdateWithoutIncomingDepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutNodesNestedInput
    nodeType?: NodeTypeUpdateOneRequiredWithoutNodesNestedInput
    parent?: NodeUpdateOneWithoutChildrenNestedInput
    children?: NodeUpdateManyWithoutParentNestedInput
    ownerUser?: UserUpdateOneWithoutOwnedNodesNestedInput
    assignments?: NodeAssignmentUpdateManyWithoutNodeNestedInput
    outgoingDeps?: NodeDependencyUpdateManyWithoutDependsOnNodeNestedInput
    kpis?: KpiDefinitionUpdateManyWithoutPrimaryNodeNestedInput
  }

  export type NodeUncheckedUpdateWithoutIncomingDepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    nodeTypeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: NodeUncheckedUpdateManyWithoutParentNestedInput
    assignments?: NodeAssignmentUncheckedUpdateManyWithoutNodeNestedInput
    outgoingDeps?: NodeDependencyUncheckedUpdateManyWithoutDependsOnNodeNestedInput
    kpis?: KpiDefinitionUncheckedUpdateManyWithoutPrimaryNodeNestedInput
  }

  export type NodeUpsertWithoutOutgoingDepsInput = {
    update: XOR<NodeUpdateWithoutOutgoingDepsInput, NodeUncheckedUpdateWithoutOutgoingDepsInput>
    create: XOR<NodeCreateWithoutOutgoingDepsInput, NodeUncheckedCreateWithoutOutgoingDepsInput>
    where?: NodeWhereInput
  }

  export type NodeUpdateToOneWithWhereWithoutOutgoingDepsInput = {
    where?: NodeWhereInput
    data: XOR<NodeUpdateWithoutOutgoingDepsInput, NodeUncheckedUpdateWithoutOutgoingDepsInput>
  }

  export type NodeUpdateWithoutOutgoingDepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutNodesNestedInput
    nodeType?: NodeTypeUpdateOneRequiredWithoutNodesNestedInput
    parent?: NodeUpdateOneWithoutChildrenNestedInput
    children?: NodeUpdateManyWithoutParentNestedInput
    ownerUser?: UserUpdateOneWithoutOwnedNodesNestedInput
    assignments?: NodeAssignmentUpdateManyWithoutNodeNestedInput
    incomingDeps?: NodeDependencyUpdateManyWithoutBlockedNodeNestedInput
    kpis?: KpiDefinitionUpdateManyWithoutPrimaryNodeNestedInput
  }

  export type NodeUncheckedUpdateWithoutOutgoingDepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    nodeTypeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: NodeUncheckedUpdateManyWithoutParentNestedInput
    assignments?: NodeAssignmentUncheckedUpdateManyWithoutNodeNestedInput
    incomingDeps?: NodeDependencyUncheckedUpdateManyWithoutBlockedNodeNestedInput
    kpis?: KpiDefinitionUncheckedUpdateManyWithoutPrimaryNodeNestedInput
  }

  export type OrganizationCreateWithoutKpisInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserCreateNestedManyWithoutOrgInput
    departments?: DepartmentCreateNestedManyWithoutOrgInput
    nodes?: NodeCreateNestedManyWithoutOrgInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutOrgInput
  }

  export type OrganizationUncheckedCreateWithoutKpisInput = {
    id?: string
    name: string
    domain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutOrgInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutOrgInput
    nodes?: NodeUncheckedCreateNestedManyWithoutOrgInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutOrgInput
  }

  export type OrganizationCreateOrConnectWithoutKpisInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutKpisInput, OrganizationUncheckedCreateWithoutKpisInput>
  }

  export type NodeCreateWithoutKpisInput = {
    id?: string
    name: string
    description?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutNodesInput
    nodeType: NodeTypeCreateNestedOneWithoutNodesInput
    parent?: NodeCreateNestedOneWithoutChildrenInput
    children?: NodeCreateNestedManyWithoutParentInput
    ownerUser?: UserCreateNestedOneWithoutOwnedNodesInput
    assignments?: NodeAssignmentCreateNestedManyWithoutNodeInput
    outgoingDeps?: NodeDependencyCreateNestedManyWithoutDependsOnNodeInput
    incomingDeps?: NodeDependencyCreateNestedManyWithoutBlockedNodeInput
  }

  export type NodeUncheckedCreateWithoutKpisInput = {
    id?: string
    orgId: string
    nodeTypeId: string
    parentId?: string | null
    name: string
    description?: string | null
    ownerUserId?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: NodeUncheckedCreateNestedManyWithoutParentInput
    assignments?: NodeAssignmentUncheckedCreateNestedManyWithoutNodeInput
    outgoingDeps?: NodeDependencyUncheckedCreateNestedManyWithoutDependsOnNodeInput
    incomingDeps?: NodeDependencyUncheckedCreateNestedManyWithoutBlockedNodeInput
  }

  export type NodeCreateOrConnectWithoutKpisInput = {
    where: NodeWhereUniqueInput
    create: XOR<NodeCreateWithoutKpisInput, NodeUncheckedCreateWithoutKpisInput>
  }

  export type UserCreateWithoutOwnedKpisInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutDirectReportsInput
    directReports?: UserCreateNestedManyWithoutManagerInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodCreateNestedManyWithoutApprovedByUserInput
  }

  export type UserUncheckedCreateWithoutOwnedKpisInput = {
    id?: string
    orgId: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    managerId?: string | null
    departmentId?: string | null
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    directReports?: UserUncheckedCreateNestedManyWithoutManagerInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalUncheckedCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeUncheckedCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentUncheckedCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodUncheckedCreateNestedManyWithoutEnteredByUserInput
    kpiValuesApproved?: KpiValuePeriodUncheckedCreateNestedManyWithoutApprovedByUserInput
  }

  export type UserCreateOrConnectWithoutOwnedKpisInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedKpisInput, UserUncheckedCreateWithoutOwnedKpisInput>
  }

  export type KpiVariableCreateWithoutKpiInput = {
    id?: string
    code: string
    displayName: string
    dataType: $Enums.KpiVariableDataType
    isRequired?: boolean
    values?: KpiVariableValueCreateNestedManyWithoutKpiVariableInput
  }

  export type KpiVariableUncheckedCreateWithoutKpiInput = {
    id?: string
    code: string
    displayName: string
    dataType: $Enums.KpiVariableDataType
    isRequired?: boolean
    values?: KpiVariableValueUncheckedCreateNestedManyWithoutKpiVariableInput
  }

  export type KpiVariableCreateOrConnectWithoutKpiInput = {
    where: KpiVariableWhereUniqueInput
    create: XOR<KpiVariableCreateWithoutKpiInput, KpiVariableUncheckedCreateWithoutKpiInput>
  }

  export type KpiVariableCreateManyKpiInputEnvelope = {
    data: KpiVariableCreateManyKpiInput | KpiVariableCreateManyKpiInput[]
    skipDuplicates?: boolean
  }

  export type KpiValuePeriodCreateWithoutKpiInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    calculatedValue?: number | null
    status?: $Enums.KpiValueStatus
    note?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    enteredByUser?: UserCreateNestedOneWithoutKpiValuesEnteredInput
    approvedByUser?: UserCreateNestedOneWithoutKpiValuesApprovedInput
    variableValues?: KpiVariableValueCreateNestedManyWithoutKpiValueInput
  }

  export type KpiValuePeriodUncheckedCreateWithoutKpiInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    calculatedValue?: number | null
    status?: $Enums.KpiValueStatus
    note?: string | null
    enteredBy?: string | null
    approvedBy?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variableValues?: KpiVariableValueUncheckedCreateNestedManyWithoutKpiValueInput
  }

  export type KpiValuePeriodCreateOrConnectWithoutKpiInput = {
    where: KpiValuePeriodWhereUniqueInput
    create: XOR<KpiValuePeriodCreateWithoutKpiInput, KpiValuePeriodUncheckedCreateWithoutKpiInput>
  }

  export type KpiValuePeriodCreateManyKpiInputEnvelope = {
    data: KpiValuePeriodCreateManyKpiInput | KpiValuePeriodCreateManyKpiInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutKpisInput = {
    update: XOR<OrganizationUpdateWithoutKpisInput, OrganizationUncheckedUpdateWithoutKpisInput>
    create: XOR<OrganizationCreateWithoutKpisInput, OrganizationUncheckedCreateWithoutKpisInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutKpisInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutKpisInput, OrganizationUncheckedUpdateWithoutKpisInput>
  }

  export type OrganizationUpdateWithoutKpisInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutOrgNestedInput
    departments?: DepartmentUpdateManyWithoutOrgNestedInput
    nodes?: NodeUpdateManyWithoutOrgNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutOrgNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutKpisInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutOrgNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutOrgNestedInput
    nodes?: NodeUncheckedUpdateManyWithoutOrgNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutOrgNestedInput
  }

  export type NodeUpsertWithoutKpisInput = {
    update: XOR<NodeUpdateWithoutKpisInput, NodeUncheckedUpdateWithoutKpisInput>
    create: XOR<NodeCreateWithoutKpisInput, NodeUncheckedCreateWithoutKpisInput>
    where?: NodeWhereInput
  }

  export type NodeUpdateToOneWithWhereWithoutKpisInput = {
    where?: NodeWhereInput
    data: XOR<NodeUpdateWithoutKpisInput, NodeUncheckedUpdateWithoutKpisInput>
  }

  export type NodeUpdateWithoutKpisInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutNodesNestedInput
    nodeType?: NodeTypeUpdateOneRequiredWithoutNodesNestedInput
    parent?: NodeUpdateOneWithoutChildrenNestedInput
    children?: NodeUpdateManyWithoutParentNestedInput
    ownerUser?: UserUpdateOneWithoutOwnedNodesNestedInput
    assignments?: NodeAssignmentUpdateManyWithoutNodeNestedInput
    outgoingDeps?: NodeDependencyUpdateManyWithoutDependsOnNodeNestedInput
    incomingDeps?: NodeDependencyUpdateManyWithoutBlockedNodeNestedInput
  }

  export type NodeUncheckedUpdateWithoutKpisInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    nodeTypeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: NodeUncheckedUpdateManyWithoutParentNestedInput
    assignments?: NodeAssignmentUncheckedUpdateManyWithoutNodeNestedInput
    outgoingDeps?: NodeDependencyUncheckedUpdateManyWithoutDependsOnNodeNestedInput
    incomingDeps?: NodeDependencyUncheckedUpdateManyWithoutBlockedNodeNestedInput
  }

  export type UserUpsertWithoutOwnedKpisInput = {
    update: XOR<UserUpdateWithoutOwnedKpisInput, UserUncheckedUpdateWithoutOwnedKpisInput>
    create: XOR<UserCreateWithoutOwnedKpisInput, UserUncheckedCreateWithoutOwnedKpisInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedKpisInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedKpisInput, UserUncheckedUpdateWithoutOwnedKpisInput>
  }

  export type UserUpdateWithoutOwnedKpisInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutDirectReportsNestedInput
    directReports?: UserUpdateManyWithoutManagerNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUpdateManyWithoutApprovedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedKpisInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directReports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUncheckedUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUncheckedUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUncheckedUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUncheckedUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUncheckedUpdateManyWithoutApprovedByUserNestedInput
  }

  export type KpiVariableUpsertWithWhereUniqueWithoutKpiInput = {
    where: KpiVariableWhereUniqueInput
    update: XOR<KpiVariableUpdateWithoutKpiInput, KpiVariableUncheckedUpdateWithoutKpiInput>
    create: XOR<KpiVariableCreateWithoutKpiInput, KpiVariableUncheckedCreateWithoutKpiInput>
  }

  export type KpiVariableUpdateWithWhereUniqueWithoutKpiInput = {
    where: KpiVariableWhereUniqueInput
    data: XOR<KpiVariableUpdateWithoutKpiInput, KpiVariableUncheckedUpdateWithoutKpiInput>
  }

  export type KpiVariableUpdateManyWithWhereWithoutKpiInput = {
    where: KpiVariableScalarWhereInput
    data: XOR<KpiVariableUpdateManyMutationInput, KpiVariableUncheckedUpdateManyWithoutKpiInput>
  }

  export type KpiVariableScalarWhereInput = {
    AND?: KpiVariableScalarWhereInput | KpiVariableScalarWhereInput[]
    OR?: KpiVariableScalarWhereInput[]
    NOT?: KpiVariableScalarWhereInput | KpiVariableScalarWhereInput[]
    id?: StringFilter<"KpiVariable"> | string
    kpiId?: StringFilter<"KpiVariable"> | string
    code?: StringFilter<"KpiVariable"> | string
    displayName?: StringFilter<"KpiVariable"> | string
    dataType?: EnumKpiVariableDataTypeFilter<"KpiVariable"> | $Enums.KpiVariableDataType
    isRequired?: BoolFilter<"KpiVariable"> | boolean
  }

  export type KpiValuePeriodUpsertWithWhereUniqueWithoutKpiInput = {
    where: KpiValuePeriodWhereUniqueInput
    update: XOR<KpiValuePeriodUpdateWithoutKpiInput, KpiValuePeriodUncheckedUpdateWithoutKpiInput>
    create: XOR<KpiValuePeriodCreateWithoutKpiInput, KpiValuePeriodUncheckedCreateWithoutKpiInput>
  }

  export type KpiValuePeriodUpdateWithWhereUniqueWithoutKpiInput = {
    where: KpiValuePeriodWhereUniqueInput
    data: XOR<KpiValuePeriodUpdateWithoutKpiInput, KpiValuePeriodUncheckedUpdateWithoutKpiInput>
  }

  export type KpiValuePeriodUpdateManyWithWhereWithoutKpiInput = {
    where: KpiValuePeriodScalarWhereInput
    data: XOR<KpiValuePeriodUpdateManyMutationInput, KpiValuePeriodUncheckedUpdateManyWithoutKpiInput>
  }

  export type KpiDefinitionCreateWithoutVariablesInput = {
    id?: string
    name: string
    description?: string | null
    formula?: string | null
    unit?: string | null
    direction?: $Enums.KpiDirection
    aggregation?: $Enums.KpiAggregationMethod
    periodType: $Enums.KpiPeriodType
    baselineValue?: number | null
    targetValue?: number | null
    weight?: number | null
    status?: $Enums.KpiDefinitionStatus
    org: OrganizationCreateNestedOneWithoutKpisInput
    primaryNode: NodeCreateNestedOneWithoutKpisInput
    ownerUser?: UserCreateNestedOneWithoutOwnedKpisInput
    values?: KpiValuePeriodCreateNestedManyWithoutKpiInput
  }

  export type KpiDefinitionUncheckedCreateWithoutVariablesInput = {
    id?: string
    orgId: string
    primaryNodeId: string
    ownerUserId?: string | null
    name: string
    description?: string | null
    formula?: string | null
    unit?: string | null
    direction?: $Enums.KpiDirection
    aggregation?: $Enums.KpiAggregationMethod
    periodType: $Enums.KpiPeriodType
    baselineValue?: number | null
    targetValue?: number | null
    weight?: number | null
    status?: $Enums.KpiDefinitionStatus
    values?: KpiValuePeriodUncheckedCreateNestedManyWithoutKpiInput
  }

  export type KpiDefinitionCreateOrConnectWithoutVariablesInput = {
    where: KpiDefinitionWhereUniqueInput
    create: XOR<KpiDefinitionCreateWithoutVariablesInput, KpiDefinitionUncheckedCreateWithoutVariablesInput>
  }

  export type KpiVariableValueCreateWithoutKpiVariableInput = {
    id?: string
    value: number
    kpiValue: KpiValuePeriodCreateNestedOneWithoutVariableValuesInput
  }

  export type KpiVariableValueUncheckedCreateWithoutKpiVariableInput = {
    id?: string
    kpiValueId: string
    value: number
  }

  export type KpiVariableValueCreateOrConnectWithoutKpiVariableInput = {
    where: KpiVariableValueWhereUniqueInput
    create: XOR<KpiVariableValueCreateWithoutKpiVariableInput, KpiVariableValueUncheckedCreateWithoutKpiVariableInput>
  }

  export type KpiVariableValueCreateManyKpiVariableInputEnvelope = {
    data: KpiVariableValueCreateManyKpiVariableInput | KpiVariableValueCreateManyKpiVariableInput[]
    skipDuplicates?: boolean
  }

  export type KpiDefinitionUpsertWithoutVariablesInput = {
    update: XOR<KpiDefinitionUpdateWithoutVariablesInput, KpiDefinitionUncheckedUpdateWithoutVariablesInput>
    create: XOR<KpiDefinitionCreateWithoutVariablesInput, KpiDefinitionUncheckedCreateWithoutVariablesInput>
    where?: KpiDefinitionWhereInput
  }

  export type KpiDefinitionUpdateToOneWithWhereWithoutVariablesInput = {
    where?: KpiDefinitionWhereInput
    data: XOR<KpiDefinitionUpdateWithoutVariablesInput, KpiDefinitionUncheckedUpdateWithoutVariablesInput>
  }

  export type KpiDefinitionUpdateWithoutVariablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumKpiDirectionFieldUpdateOperationsInput | $Enums.KpiDirection
    aggregation?: EnumKpiAggregationMethodFieldUpdateOperationsInput | $Enums.KpiAggregationMethod
    periodType?: EnumKpiPeriodTypeFieldUpdateOperationsInput | $Enums.KpiPeriodType
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiDefinitionStatusFieldUpdateOperationsInput | $Enums.KpiDefinitionStatus
    org?: OrganizationUpdateOneRequiredWithoutKpisNestedInput
    primaryNode?: NodeUpdateOneRequiredWithoutKpisNestedInput
    ownerUser?: UserUpdateOneWithoutOwnedKpisNestedInput
    values?: KpiValuePeriodUpdateManyWithoutKpiNestedInput
  }

  export type KpiDefinitionUncheckedUpdateWithoutVariablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    primaryNodeId?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumKpiDirectionFieldUpdateOperationsInput | $Enums.KpiDirection
    aggregation?: EnumKpiAggregationMethodFieldUpdateOperationsInput | $Enums.KpiAggregationMethod
    periodType?: EnumKpiPeriodTypeFieldUpdateOperationsInput | $Enums.KpiPeriodType
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiDefinitionStatusFieldUpdateOperationsInput | $Enums.KpiDefinitionStatus
    values?: KpiValuePeriodUncheckedUpdateManyWithoutKpiNestedInput
  }

  export type KpiVariableValueUpsertWithWhereUniqueWithoutKpiVariableInput = {
    where: KpiVariableValueWhereUniqueInput
    update: XOR<KpiVariableValueUpdateWithoutKpiVariableInput, KpiVariableValueUncheckedUpdateWithoutKpiVariableInput>
    create: XOR<KpiVariableValueCreateWithoutKpiVariableInput, KpiVariableValueUncheckedCreateWithoutKpiVariableInput>
  }

  export type KpiVariableValueUpdateWithWhereUniqueWithoutKpiVariableInput = {
    where: KpiVariableValueWhereUniqueInput
    data: XOR<KpiVariableValueUpdateWithoutKpiVariableInput, KpiVariableValueUncheckedUpdateWithoutKpiVariableInput>
  }

  export type KpiVariableValueUpdateManyWithWhereWithoutKpiVariableInput = {
    where: KpiVariableValueScalarWhereInput
    data: XOR<KpiVariableValueUpdateManyMutationInput, KpiVariableValueUncheckedUpdateManyWithoutKpiVariableInput>
  }

  export type KpiVariableValueScalarWhereInput = {
    AND?: KpiVariableValueScalarWhereInput | KpiVariableValueScalarWhereInput[]
    OR?: KpiVariableValueScalarWhereInput[]
    NOT?: KpiVariableValueScalarWhereInput | KpiVariableValueScalarWhereInput[]
    id?: StringFilter<"KpiVariableValue"> | string
    kpiValueId?: StringFilter<"KpiVariableValue"> | string
    kpiVariableId?: StringFilter<"KpiVariableValue"> | string
    value?: FloatFilter<"KpiVariableValue"> | number
  }

  export type KpiDefinitionCreateWithoutValuesInput = {
    id?: string
    name: string
    description?: string | null
    formula?: string | null
    unit?: string | null
    direction?: $Enums.KpiDirection
    aggregation?: $Enums.KpiAggregationMethod
    periodType: $Enums.KpiPeriodType
    baselineValue?: number | null
    targetValue?: number | null
    weight?: number | null
    status?: $Enums.KpiDefinitionStatus
    org: OrganizationCreateNestedOneWithoutKpisInput
    primaryNode: NodeCreateNestedOneWithoutKpisInput
    ownerUser?: UserCreateNestedOneWithoutOwnedKpisInput
    variables?: KpiVariableCreateNestedManyWithoutKpiInput
  }

  export type KpiDefinitionUncheckedCreateWithoutValuesInput = {
    id?: string
    orgId: string
    primaryNodeId: string
    ownerUserId?: string | null
    name: string
    description?: string | null
    formula?: string | null
    unit?: string | null
    direction?: $Enums.KpiDirection
    aggregation?: $Enums.KpiAggregationMethod
    periodType: $Enums.KpiPeriodType
    baselineValue?: number | null
    targetValue?: number | null
    weight?: number | null
    status?: $Enums.KpiDefinitionStatus
    variables?: KpiVariableUncheckedCreateNestedManyWithoutKpiInput
  }

  export type KpiDefinitionCreateOrConnectWithoutValuesInput = {
    where: KpiDefinitionWhereUniqueInput
    create: XOR<KpiDefinitionCreateWithoutValuesInput, KpiDefinitionUncheckedCreateWithoutValuesInput>
  }

  export type UserCreateWithoutKpiValuesEnteredInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutDirectReportsInput
    directReports?: UserCreateNestedManyWithoutManagerInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentCreateNestedManyWithoutUserInput
    kpiValuesApproved?: KpiValuePeriodCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionCreateNestedManyWithoutOwnerUserInput
  }

  export type UserUncheckedCreateWithoutKpiValuesEnteredInput = {
    id?: string
    orgId: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    managerId?: string | null
    departmentId?: string | null
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    directReports?: UserUncheckedCreateNestedManyWithoutManagerInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalUncheckedCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeUncheckedCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentUncheckedCreateNestedManyWithoutUserInput
    kpiValuesApproved?: KpiValuePeriodUncheckedCreateNestedManyWithoutApprovedByUserInput
    ownedKpis?: KpiDefinitionUncheckedCreateNestedManyWithoutOwnerUserInput
  }

  export type UserCreateOrConnectWithoutKpiValuesEnteredInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutKpiValuesEnteredInput, UserUncheckedCreateWithoutKpiValuesEnteredInput>
  }

  export type UserCreateWithoutKpiValuesApprovedInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    org: OrganizationCreateNestedOneWithoutUsersInput
    manager?: UserCreateNestedOneWithoutDirectReportsInput
    directReports?: UserCreateNestedManyWithoutManagerInput
    department?: DepartmentCreateNestedOneWithoutUsersInput
    managedDepartments?: DepartmentCreateNestedManyWithoutManagerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodCreateNestedManyWithoutEnteredByUserInput
    ownedKpis?: KpiDefinitionCreateNestedManyWithoutOwnerUserInput
  }

  export type UserUncheckedCreateWithoutKpiValuesApprovedInput = {
    id?: string
    orgId: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    managerId?: string | null
    departmentId?: string | null
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    directReports?: UserUncheckedCreateNestedManyWithoutManagerInput
    managedDepartments?: DepartmentUncheckedCreateNestedManyWithoutManagerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    preferences?: UserPreferenceUncheckedCreateNestedOneWithoutUserInput
    approvals?: ChangeApprovalUncheckedCreateNestedManyWithoutApproverInput
    changeRequests?: ChangeRequestUncheckedCreateNestedManyWithoutRequesterInput
    ownedNodes?: NodeUncheckedCreateNestedManyWithoutOwnerUserInput
    nodeAssignments?: NodeAssignmentUncheckedCreateNestedManyWithoutUserInput
    kpiValuesEntered?: KpiValuePeriodUncheckedCreateNestedManyWithoutEnteredByUserInput
    ownedKpis?: KpiDefinitionUncheckedCreateNestedManyWithoutOwnerUserInput
  }

  export type UserCreateOrConnectWithoutKpiValuesApprovedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutKpiValuesApprovedInput, UserUncheckedCreateWithoutKpiValuesApprovedInput>
  }

  export type KpiVariableValueCreateWithoutKpiValueInput = {
    id?: string
    value: number
    kpiVariable: KpiVariableCreateNestedOneWithoutValuesInput
  }

  export type KpiVariableValueUncheckedCreateWithoutKpiValueInput = {
    id?: string
    kpiVariableId: string
    value: number
  }

  export type KpiVariableValueCreateOrConnectWithoutKpiValueInput = {
    where: KpiVariableValueWhereUniqueInput
    create: XOR<KpiVariableValueCreateWithoutKpiValueInput, KpiVariableValueUncheckedCreateWithoutKpiValueInput>
  }

  export type KpiVariableValueCreateManyKpiValueInputEnvelope = {
    data: KpiVariableValueCreateManyKpiValueInput | KpiVariableValueCreateManyKpiValueInput[]
    skipDuplicates?: boolean
  }

  export type KpiDefinitionUpsertWithoutValuesInput = {
    update: XOR<KpiDefinitionUpdateWithoutValuesInput, KpiDefinitionUncheckedUpdateWithoutValuesInput>
    create: XOR<KpiDefinitionCreateWithoutValuesInput, KpiDefinitionUncheckedCreateWithoutValuesInput>
    where?: KpiDefinitionWhereInput
  }

  export type KpiDefinitionUpdateToOneWithWhereWithoutValuesInput = {
    where?: KpiDefinitionWhereInput
    data: XOR<KpiDefinitionUpdateWithoutValuesInput, KpiDefinitionUncheckedUpdateWithoutValuesInput>
  }

  export type KpiDefinitionUpdateWithoutValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumKpiDirectionFieldUpdateOperationsInput | $Enums.KpiDirection
    aggregation?: EnumKpiAggregationMethodFieldUpdateOperationsInput | $Enums.KpiAggregationMethod
    periodType?: EnumKpiPeriodTypeFieldUpdateOperationsInput | $Enums.KpiPeriodType
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiDefinitionStatusFieldUpdateOperationsInput | $Enums.KpiDefinitionStatus
    org?: OrganizationUpdateOneRequiredWithoutKpisNestedInput
    primaryNode?: NodeUpdateOneRequiredWithoutKpisNestedInput
    ownerUser?: UserUpdateOneWithoutOwnedKpisNestedInput
    variables?: KpiVariableUpdateManyWithoutKpiNestedInput
  }

  export type KpiDefinitionUncheckedUpdateWithoutValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    primaryNodeId?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumKpiDirectionFieldUpdateOperationsInput | $Enums.KpiDirection
    aggregation?: EnumKpiAggregationMethodFieldUpdateOperationsInput | $Enums.KpiAggregationMethod
    periodType?: EnumKpiPeriodTypeFieldUpdateOperationsInput | $Enums.KpiPeriodType
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiDefinitionStatusFieldUpdateOperationsInput | $Enums.KpiDefinitionStatus
    variables?: KpiVariableUncheckedUpdateManyWithoutKpiNestedInput
  }

  export type UserUpsertWithoutKpiValuesEnteredInput = {
    update: XOR<UserUpdateWithoutKpiValuesEnteredInput, UserUncheckedUpdateWithoutKpiValuesEnteredInput>
    create: XOR<UserCreateWithoutKpiValuesEnteredInput, UserUncheckedCreateWithoutKpiValuesEnteredInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutKpiValuesEnteredInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutKpiValuesEnteredInput, UserUncheckedUpdateWithoutKpiValuesEnteredInput>
  }

  export type UserUpdateWithoutKpiValuesEnteredInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutDirectReportsNestedInput
    directReports?: UserUpdateManyWithoutManagerNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUpdateManyWithoutUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserUncheckedUpdateWithoutKpiValuesEnteredInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directReports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUncheckedUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUncheckedUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUncheckedUpdateManyWithoutUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUncheckedUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUncheckedUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserUpsertWithoutKpiValuesApprovedInput = {
    update: XOR<UserUpdateWithoutKpiValuesApprovedInput, UserUncheckedUpdateWithoutKpiValuesApprovedInput>
    create: XOR<UserCreateWithoutKpiValuesApprovedInput, UserUncheckedCreateWithoutKpiValuesApprovedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutKpiValuesApprovedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutKpiValuesApprovedInput, UserUncheckedUpdateWithoutKpiValuesApprovedInput>
  }

  export type UserUpdateWithoutKpiValuesApprovedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutDirectReportsNestedInput
    directReports?: UserUpdateManyWithoutManagerNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUpdateManyWithoutEnteredByUserNestedInput
    ownedKpis?: KpiDefinitionUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserUncheckedUpdateWithoutKpiValuesApprovedInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directReports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUncheckedUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUncheckedUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUncheckedUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUncheckedUpdateManyWithoutEnteredByUserNestedInput
    ownedKpis?: KpiDefinitionUncheckedUpdateManyWithoutOwnerUserNestedInput
  }

  export type KpiVariableValueUpsertWithWhereUniqueWithoutKpiValueInput = {
    where: KpiVariableValueWhereUniqueInput
    update: XOR<KpiVariableValueUpdateWithoutKpiValueInput, KpiVariableValueUncheckedUpdateWithoutKpiValueInput>
    create: XOR<KpiVariableValueCreateWithoutKpiValueInput, KpiVariableValueUncheckedCreateWithoutKpiValueInput>
  }

  export type KpiVariableValueUpdateWithWhereUniqueWithoutKpiValueInput = {
    where: KpiVariableValueWhereUniqueInput
    data: XOR<KpiVariableValueUpdateWithoutKpiValueInput, KpiVariableValueUncheckedUpdateWithoutKpiValueInput>
  }

  export type KpiVariableValueUpdateManyWithWhereWithoutKpiValueInput = {
    where: KpiVariableValueScalarWhereInput
    data: XOR<KpiVariableValueUpdateManyMutationInput, KpiVariableValueUncheckedUpdateManyWithoutKpiValueInput>
  }

  export type KpiValuePeriodCreateWithoutVariableValuesInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    calculatedValue?: number | null
    status?: $Enums.KpiValueStatus
    note?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    kpi: KpiDefinitionCreateNestedOneWithoutValuesInput
    enteredByUser?: UserCreateNestedOneWithoutKpiValuesEnteredInput
    approvedByUser?: UserCreateNestedOneWithoutKpiValuesApprovedInput
  }

  export type KpiValuePeriodUncheckedCreateWithoutVariableValuesInput = {
    id?: string
    kpiId: string
    periodStart: Date | string
    periodEnd: Date | string
    calculatedValue?: number | null
    status?: $Enums.KpiValueStatus
    note?: string | null
    enteredBy?: string | null
    approvedBy?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KpiValuePeriodCreateOrConnectWithoutVariableValuesInput = {
    where: KpiValuePeriodWhereUniqueInput
    create: XOR<KpiValuePeriodCreateWithoutVariableValuesInput, KpiValuePeriodUncheckedCreateWithoutVariableValuesInput>
  }

  export type KpiVariableCreateWithoutValuesInput = {
    id?: string
    code: string
    displayName: string
    dataType: $Enums.KpiVariableDataType
    isRequired?: boolean
    kpi: KpiDefinitionCreateNestedOneWithoutVariablesInput
  }

  export type KpiVariableUncheckedCreateWithoutValuesInput = {
    id?: string
    kpiId: string
    code: string
    displayName: string
    dataType: $Enums.KpiVariableDataType
    isRequired?: boolean
  }

  export type KpiVariableCreateOrConnectWithoutValuesInput = {
    where: KpiVariableWhereUniqueInput
    create: XOR<KpiVariableCreateWithoutValuesInput, KpiVariableUncheckedCreateWithoutValuesInput>
  }

  export type KpiValuePeriodUpsertWithoutVariableValuesInput = {
    update: XOR<KpiValuePeriodUpdateWithoutVariableValuesInput, KpiValuePeriodUncheckedUpdateWithoutVariableValuesInput>
    create: XOR<KpiValuePeriodCreateWithoutVariableValuesInput, KpiValuePeriodUncheckedCreateWithoutVariableValuesInput>
    where?: KpiValuePeriodWhereInput
  }

  export type KpiValuePeriodUpdateToOneWithWhereWithoutVariableValuesInput = {
    where?: KpiValuePeriodWhereInput
    data: XOR<KpiValuePeriodUpdateWithoutVariableValuesInput, KpiValuePeriodUncheckedUpdateWithoutVariableValuesInput>
  }

  export type KpiValuePeriodUpdateWithoutVariableValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiValueStatusFieldUpdateOperationsInput | $Enums.KpiValueStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpi?: KpiDefinitionUpdateOneRequiredWithoutValuesNestedInput
    enteredByUser?: UserUpdateOneWithoutKpiValuesEnteredNestedInput
    approvedByUser?: UserUpdateOneWithoutKpiValuesApprovedNestedInput
  }

  export type KpiValuePeriodUncheckedUpdateWithoutVariableValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    kpiId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiValueStatusFieldUpdateOperationsInput | $Enums.KpiValueStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    enteredBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KpiVariableUpsertWithoutValuesInput = {
    update: XOR<KpiVariableUpdateWithoutValuesInput, KpiVariableUncheckedUpdateWithoutValuesInput>
    create: XOR<KpiVariableCreateWithoutValuesInput, KpiVariableUncheckedCreateWithoutValuesInput>
    where?: KpiVariableWhereInput
  }

  export type KpiVariableUpdateToOneWithWhereWithoutValuesInput = {
    where?: KpiVariableWhereInput
    data: XOR<KpiVariableUpdateWithoutValuesInput, KpiVariableUncheckedUpdateWithoutValuesInput>
  }

  export type KpiVariableUpdateWithoutValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    dataType?: EnumKpiVariableDataTypeFieldUpdateOperationsInput | $Enums.KpiVariableDataType
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    kpi?: KpiDefinitionUpdateOneRequiredWithoutVariablesNestedInput
  }

  export type KpiVariableUncheckedUpdateWithoutValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    kpiId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    dataType?: EnumKpiVariableDataTypeFieldUpdateOperationsInput | $Enums.KpiVariableDataType
    isRequired?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateManyOrgInput = {
    id?: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    managerId?: string | null
    departmentId?: string | null
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DepartmentCreateManyOrgInput = {
    id?: string
    name: string
    code?: string | null
    parentId?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type NodeCreateManyOrgInput = {
    id?: string
    nodeTypeId: string
    parentId?: string | null
    name: string
    description?: string | null
    ownerUserId?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type KpiDefinitionCreateManyOrgInput = {
    id?: string
    primaryNodeId: string
    ownerUserId?: string | null
    name: string
    description?: string | null
    formula?: string | null
    unit?: string | null
    direction?: $Enums.KpiDirection
    aggregation?: $Enums.KpiAggregationMethod
    periodType: $Enums.KpiPeriodType
    baselineValue?: number | null
    targetValue?: number | null
    weight?: number | null
    status?: $Enums.KpiDefinitionStatus
  }

  export type ChangeRequestCreateManyOrgInput = {
    id?: string
    entityType: string
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.ApprovalStatus
    requestedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    decidedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type UserUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    manager?: UserUpdateOneWithoutDirectReportsNestedInput
    directReports?: UserUpdateManyWithoutManagerNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directReports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUncheckedUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUncheckedUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUncheckedUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUncheckedUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUncheckedUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUncheckedUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DepartmentUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: DepartmentUpdateOneWithoutChildrenNestedInput
    children?: DepartmentUpdateManyWithoutParentNestedInput
    manager?: UserUpdateOneWithoutManagedDepartmentsNestedInput
    users?: UserUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: DepartmentUncheckedUpdateManyWithoutParentNestedInput
    users?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NodeUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nodeType?: NodeTypeUpdateOneRequiredWithoutNodesNestedInput
    parent?: NodeUpdateOneWithoutChildrenNestedInput
    children?: NodeUpdateManyWithoutParentNestedInput
    ownerUser?: UserUpdateOneWithoutOwnedNodesNestedInput
    assignments?: NodeAssignmentUpdateManyWithoutNodeNestedInput
    outgoingDeps?: NodeDependencyUpdateManyWithoutDependsOnNodeNestedInput
    incomingDeps?: NodeDependencyUpdateManyWithoutBlockedNodeNestedInput
    kpis?: KpiDefinitionUpdateManyWithoutPrimaryNodeNestedInput
  }

  export type NodeUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeTypeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: NodeUncheckedUpdateManyWithoutParentNestedInput
    assignments?: NodeAssignmentUncheckedUpdateManyWithoutNodeNestedInput
    outgoingDeps?: NodeDependencyUncheckedUpdateManyWithoutDependsOnNodeNestedInput
    incomingDeps?: NodeDependencyUncheckedUpdateManyWithoutBlockedNodeNestedInput
    kpis?: KpiDefinitionUncheckedUpdateManyWithoutPrimaryNodeNestedInput
  }

  export type NodeUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeTypeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KpiDefinitionUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumKpiDirectionFieldUpdateOperationsInput | $Enums.KpiDirection
    aggregation?: EnumKpiAggregationMethodFieldUpdateOperationsInput | $Enums.KpiAggregationMethod
    periodType?: EnumKpiPeriodTypeFieldUpdateOperationsInput | $Enums.KpiPeriodType
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiDefinitionStatusFieldUpdateOperationsInput | $Enums.KpiDefinitionStatus
    primaryNode?: NodeUpdateOneRequiredWithoutKpisNestedInput
    ownerUser?: UserUpdateOneWithoutOwnedKpisNestedInput
    variables?: KpiVariableUpdateManyWithoutKpiNestedInput
    values?: KpiValuePeriodUpdateManyWithoutKpiNestedInput
  }

  export type KpiDefinitionUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryNodeId?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumKpiDirectionFieldUpdateOperationsInput | $Enums.KpiDirection
    aggregation?: EnumKpiAggregationMethodFieldUpdateOperationsInput | $Enums.KpiAggregationMethod
    periodType?: EnumKpiPeriodTypeFieldUpdateOperationsInput | $Enums.KpiPeriodType
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiDefinitionStatusFieldUpdateOperationsInput | $Enums.KpiDefinitionStatus
    variables?: KpiVariableUncheckedUpdateManyWithoutKpiNestedInput
    values?: KpiValuePeriodUncheckedUpdateManyWithoutKpiNestedInput
  }

  export type KpiDefinitionUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    primaryNodeId?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumKpiDirectionFieldUpdateOperationsInput | $Enums.KpiDirection
    aggregation?: EnumKpiAggregationMethodFieldUpdateOperationsInput | $Enums.KpiAggregationMethod
    periodType?: EnumKpiPeriodTypeFieldUpdateOperationsInput | $Enums.KpiPeriodType
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiDefinitionStatusFieldUpdateOperationsInput | $Enums.KpiDefinitionStatus
  }

  export type ChangeRequestUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requester?: UserUpdateOneRequiredWithoutChangeRequestsNestedInput
    approvals?: ChangeApprovalUpdateManyWithoutChangeRequestNestedInput
  }

  export type ChangeRequestUncheckedUpdateWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    requestedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvals?: ChangeApprovalUncheckedUpdateManyWithoutChangeRequestNestedInput
  }

  export type ChangeRequestUncheckedUpdateManyWithoutOrgInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    requestedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DepartmentCreateManyParentInput = {
    id?: string
    orgId: string
    name: string
    code?: string | null
    managerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserCreateManyDepartmentInput = {
    id?: string
    orgId: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    managerId?: string | null
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DepartmentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput
    children?: DepartmentUpdateManyWithoutParentNestedInput
    manager?: UserUpdateOneWithoutManagedDepartmentsNestedInput
    users?: UserUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: DepartmentUncheckedUpdateManyWithoutParentNestedInput
    users?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    manager?: UserUpdateOneWithoutDirectReportsNestedInput
    directReports?: UserUpdateManyWithoutManagerNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directReports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUncheckedUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUncheckedUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUncheckedUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUncheckedUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUncheckedUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUncheckedUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateManyManagerInput = {
    id?: string
    orgId: string
    email: string
    emailVerified?: boolean
    name: string
    role: $Enums.Role
    departmentId?: string | null
    title?: string | null
    image?: string | null
    hashedPassword?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DepartmentCreateManyManagerInput = {
    id?: string
    orgId: string
    name: string
    code?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    expiresAt: Date | string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AccountCreateManyUserInput = {
    id?: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    password?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChangeApprovalCreateManyApproverInput = {
    id?: string
    changeRequestId: string
    status?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    decidedAt?: Date | string | null
  }

  export type ChangeRequestCreateManyRequesterInput = {
    id?: string
    orgId: string
    entityType: string
    entityId: string
    payload: JsonNullValueInput | InputJsonValue
    status?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    decidedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type NodeCreateManyOwnerUserInput = {
    id?: string
    orgId: string
    nodeTypeId: string
    parentId?: string | null
    name: string
    description?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type NodeAssignmentCreateManyUserInput = {
    id?: string
    nodeId: string
    role?: $Enums.NodeAssignmentRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KpiValuePeriodCreateManyEnteredByUserInput = {
    id?: string
    kpiId: string
    periodStart: Date | string
    periodEnd: Date | string
    calculatedValue?: number | null
    status?: $Enums.KpiValueStatus
    note?: string | null
    approvedBy?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KpiValuePeriodCreateManyApprovedByUserInput = {
    id?: string
    kpiId: string
    periodStart: Date | string
    periodEnd: Date | string
    calculatedValue?: number | null
    status?: $Enums.KpiValueStatus
    note?: string | null
    enteredBy?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KpiDefinitionCreateManyOwnerUserInput = {
    id?: string
    orgId: string
    primaryNodeId: string
    name: string
    description?: string | null
    formula?: string | null
    unit?: string | null
    direction?: $Enums.KpiDirection
    aggregation?: $Enums.KpiAggregationMethod
    periodType: $Enums.KpiPeriodType
    baselineValue?: number | null
    targetValue?: number | null
    weight?: number | null
    status?: $Enums.KpiDefinitionStatus
  }

  export type UserUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    directReports?: UserUpdateManyWithoutManagerNestedInput
    department?: DepartmentUpdateOneWithoutUsersNestedInput
    managedDepartments?: DepartmentUpdateManyWithoutManagerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    directReports?: UserUncheckedUpdateManyWithoutManagerNestedInput
    managedDepartments?: DepartmentUncheckedUpdateManyWithoutManagerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    preferences?: UserPreferenceUncheckedUpdateOneWithoutUserNestedInput
    approvals?: ChangeApprovalUncheckedUpdateManyWithoutApproverNestedInput
    changeRequests?: ChangeRequestUncheckedUpdateManyWithoutRequesterNestedInput
    ownedNodes?: NodeUncheckedUpdateManyWithoutOwnerUserNestedInput
    nodeAssignments?: NodeAssignmentUncheckedUpdateManyWithoutUserNestedInput
    kpiValuesEntered?: KpiValuePeriodUncheckedUpdateManyWithoutEnteredByUserNestedInput
    kpiValuesApproved?: KpiValuePeriodUncheckedUpdateManyWithoutApprovedByUserNestedInput
    ownedKpis?: KpiDefinitionUncheckedUpdateManyWithoutOwnerUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DepartmentUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutDepartmentsNestedInput
    parent?: DepartmentUpdateOneWithoutChildrenNestedInput
    children?: DepartmentUpdateManyWithoutParentNestedInput
    users?: UserUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: DepartmentUncheckedUpdateManyWithoutParentNestedInput
    users?: UserUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChangeApprovalUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changeRequest?: ChangeRequestUpdateOneRequiredWithoutApprovalsNestedInput
  }

  export type ChangeApprovalUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeRequestId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChangeApprovalUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeRequestId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChangeRequestUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutChangeRequestsNestedInput
    approvals?: ChangeApprovalUpdateManyWithoutChangeRequestNestedInput
  }

  export type ChangeRequestUncheckedUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvals?: ChangeApprovalUncheckedUpdateManyWithoutChangeRequestNestedInput
  }

  export type ChangeRequestUncheckedUpdateManyWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NodeUpdateWithoutOwnerUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutNodesNestedInput
    nodeType?: NodeTypeUpdateOneRequiredWithoutNodesNestedInput
    parent?: NodeUpdateOneWithoutChildrenNestedInput
    children?: NodeUpdateManyWithoutParentNestedInput
    assignments?: NodeAssignmentUpdateManyWithoutNodeNestedInput
    outgoingDeps?: NodeDependencyUpdateManyWithoutDependsOnNodeNestedInput
    incomingDeps?: NodeDependencyUpdateManyWithoutBlockedNodeNestedInput
    kpis?: KpiDefinitionUpdateManyWithoutPrimaryNodeNestedInput
  }

  export type NodeUncheckedUpdateWithoutOwnerUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    nodeTypeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: NodeUncheckedUpdateManyWithoutParentNestedInput
    assignments?: NodeAssignmentUncheckedUpdateManyWithoutNodeNestedInput
    outgoingDeps?: NodeDependencyUncheckedUpdateManyWithoutDependsOnNodeNestedInput
    incomingDeps?: NodeDependencyUncheckedUpdateManyWithoutBlockedNodeNestedInput
    kpis?: KpiDefinitionUncheckedUpdateManyWithoutPrimaryNodeNestedInput
  }

  export type NodeUncheckedUpdateManyWithoutOwnerUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    nodeTypeId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NodeAssignmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumNodeAssignmentRoleFieldUpdateOperationsInput | $Enums.NodeAssignmentRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    node?: NodeUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type NodeAssignmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    role?: EnumNodeAssignmentRoleFieldUpdateOperationsInput | $Enums.NodeAssignmentRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NodeAssignmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nodeId?: StringFieldUpdateOperationsInput | string
    role?: EnumNodeAssignmentRoleFieldUpdateOperationsInput | $Enums.NodeAssignmentRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KpiValuePeriodUpdateWithoutEnteredByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiValueStatusFieldUpdateOperationsInput | $Enums.KpiValueStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpi?: KpiDefinitionUpdateOneRequiredWithoutValuesNestedInput
    approvedByUser?: UserUpdateOneWithoutKpiValuesApprovedNestedInput
    variableValues?: KpiVariableValueUpdateManyWithoutKpiValueNestedInput
  }

  export type KpiValuePeriodUncheckedUpdateWithoutEnteredByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    kpiId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiValueStatusFieldUpdateOperationsInput | $Enums.KpiValueStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variableValues?: KpiVariableValueUncheckedUpdateManyWithoutKpiValueNestedInput
  }

  export type KpiValuePeriodUncheckedUpdateManyWithoutEnteredByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    kpiId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiValueStatusFieldUpdateOperationsInput | $Enums.KpiValueStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KpiValuePeriodUpdateWithoutApprovedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiValueStatusFieldUpdateOperationsInput | $Enums.KpiValueStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kpi?: KpiDefinitionUpdateOneRequiredWithoutValuesNestedInput
    enteredByUser?: UserUpdateOneWithoutKpiValuesEnteredNestedInput
    variableValues?: KpiVariableValueUpdateManyWithoutKpiValueNestedInput
  }

  export type KpiValuePeriodUncheckedUpdateWithoutApprovedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    kpiId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiValueStatusFieldUpdateOperationsInput | $Enums.KpiValueStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    enteredBy?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variableValues?: KpiVariableValueUncheckedUpdateManyWithoutKpiValueNestedInput
  }

  export type KpiValuePeriodUncheckedUpdateManyWithoutApprovedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    kpiId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiValueStatusFieldUpdateOperationsInput | $Enums.KpiValueStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    enteredBy?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KpiDefinitionUpdateWithoutOwnerUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumKpiDirectionFieldUpdateOperationsInput | $Enums.KpiDirection
    aggregation?: EnumKpiAggregationMethodFieldUpdateOperationsInput | $Enums.KpiAggregationMethod
    periodType?: EnumKpiPeriodTypeFieldUpdateOperationsInput | $Enums.KpiPeriodType
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiDefinitionStatusFieldUpdateOperationsInput | $Enums.KpiDefinitionStatus
    org?: OrganizationUpdateOneRequiredWithoutKpisNestedInput
    primaryNode?: NodeUpdateOneRequiredWithoutKpisNestedInput
    variables?: KpiVariableUpdateManyWithoutKpiNestedInput
    values?: KpiValuePeriodUpdateManyWithoutKpiNestedInput
  }

  export type KpiDefinitionUncheckedUpdateWithoutOwnerUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    primaryNodeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumKpiDirectionFieldUpdateOperationsInput | $Enums.KpiDirection
    aggregation?: EnumKpiAggregationMethodFieldUpdateOperationsInput | $Enums.KpiAggregationMethod
    periodType?: EnumKpiPeriodTypeFieldUpdateOperationsInput | $Enums.KpiPeriodType
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiDefinitionStatusFieldUpdateOperationsInput | $Enums.KpiDefinitionStatus
    variables?: KpiVariableUncheckedUpdateManyWithoutKpiNestedInput
    values?: KpiValuePeriodUncheckedUpdateManyWithoutKpiNestedInput
  }

  export type KpiDefinitionUncheckedUpdateManyWithoutOwnerUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    primaryNodeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumKpiDirectionFieldUpdateOperationsInput | $Enums.KpiDirection
    aggregation?: EnumKpiAggregationMethodFieldUpdateOperationsInput | $Enums.KpiAggregationMethod
    periodType?: EnumKpiPeriodTypeFieldUpdateOperationsInput | $Enums.KpiPeriodType
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiDefinitionStatusFieldUpdateOperationsInput | $Enums.KpiDefinitionStatus
  }

  export type ChangeApprovalCreateManyChangeRequestInput = {
    id?: string
    approverId: string
    status?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    decidedAt?: Date | string | null
  }

  export type ChangeApprovalUpdateWithoutChangeRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approver?: UserUpdateOneRequiredWithoutApprovalsNestedInput
  }

  export type ChangeApprovalUncheckedUpdateWithoutChangeRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChangeApprovalUncheckedUpdateManyWithoutChangeRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NodeCreateManyNodeTypeInput = {
    id?: string
    orgId: string
    parentId?: string | null
    name: string
    description?: string | null
    ownerUserId?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type NodeUpdateWithoutNodeTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutNodesNestedInput
    parent?: NodeUpdateOneWithoutChildrenNestedInput
    children?: NodeUpdateManyWithoutParentNestedInput
    ownerUser?: UserUpdateOneWithoutOwnedNodesNestedInput
    assignments?: NodeAssignmentUpdateManyWithoutNodeNestedInput
    outgoingDeps?: NodeDependencyUpdateManyWithoutDependsOnNodeNestedInput
    incomingDeps?: NodeDependencyUpdateManyWithoutBlockedNodeNestedInput
    kpis?: KpiDefinitionUpdateManyWithoutPrimaryNodeNestedInput
  }

  export type NodeUncheckedUpdateWithoutNodeTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: NodeUncheckedUpdateManyWithoutParentNestedInput
    assignments?: NodeAssignmentUncheckedUpdateManyWithoutNodeNestedInput
    outgoingDeps?: NodeDependencyUncheckedUpdateManyWithoutDependsOnNodeNestedInput
    incomingDeps?: NodeDependencyUncheckedUpdateManyWithoutBlockedNodeNestedInput
    kpis?: KpiDefinitionUncheckedUpdateManyWithoutPrimaryNodeNestedInput
  }

  export type NodeUncheckedUpdateManyWithoutNodeTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NodeCreateManyParentInput = {
    id?: string
    orgId: string
    nodeTypeId: string
    name: string
    description?: string | null
    ownerUserId?: string | null
    status?: $Enums.Status
    progress?: number
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type NodeAssignmentCreateManyNodeInput = {
    id?: string
    userId: string
    role?: $Enums.NodeAssignmentRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NodeDependencyCreateManyDependsOnNodeInput = {
    id?: string
    blockedNodeId: string
    createdAt?: Date | string
  }

  export type NodeDependencyCreateManyBlockedNodeInput = {
    id?: string
    dependsOnNodeId: string
    createdAt?: Date | string
  }

  export type KpiDefinitionCreateManyPrimaryNodeInput = {
    id?: string
    orgId: string
    ownerUserId?: string | null
    name: string
    description?: string | null
    formula?: string | null
    unit?: string | null
    direction?: $Enums.KpiDirection
    aggregation?: $Enums.KpiAggregationMethod
    periodType: $Enums.KpiPeriodType
    baselineValue?: number | null
    targetValue?: number | null
    weight?: number | null
    status?: $Enums.KpiDefinitionStatus
  }

  export type NodeUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    org?: OrganizationUpdateOneRequiredWithoutNodesNestedInput
    nodeType?: NodeTypeUpdateOneRequiredWithoutNodesNestedInput
    children?: NodeUpdateManyWithoutParentNestedInput
    ownerUser?: UserUpdateOneWithoutOwnedNodesNestedInput
    assignments?: NodeAssignmentUpdateManyWithoutNodeNestedInput
    outgoingDeps?: NodeDependencyUpdateManyWithoutDependsOnNodeNestedInput
    incomingDeps?: NodeDependencyUpdateManyWithoutBlockedNodeNestedInput
    kpis?: KpiDefinitionUpdateManyWithoutPrimaryNodeNestedInput
  }

  export type NodeUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    nodeTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: NodeUncheckedUpdateManyWithoutParentNestedInput
    assignments?: NodeAssignmentUncheckedUpdateManyWithoutNodeNestedInput
    outgoingDeps?: NodeDependencyUncheckedUpdateManyWithoutDependsOnNodeNestedInput
    incomingDeps?: NodeDependencyUncheckedUpdateManyWithoutBlockedNodeNestedInput
    kpis?: KpiDefinitionUncheckedUpdateManyWithoutPrimaryNodeNestedInput
  }

  export type NodeUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    nodeTypeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    progress?: IntFieldUpdateOperationsInput | number
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NodeAssignmentUpdateWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumNodeAssignmentRoleFieldUpdateOperationsInput | $Enums.NodeAssignmentRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNodeAssignmentsNestedInput
  }

  export type NodeAssignmentUncheckedUpdateWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumNodeAssignmentRoleFieldUpdateOperationsInput | $Enums.NodeAssignmentRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NodeAssignmentUncheckedUpdateManyWithoutNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumNodeAssignmentRoleFieldUpdateOperationsInput | $Enums.NodeAssignmentRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NodeDependencyUpdateWithoutDependsOnNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedNode?: NodeUpdateOneRequiredWithoutIncomingDepsNestedInput
  }

  export type NodeDependencyUncheckedUpdateWithoutDependsOnNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockedNodeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NodeDependencyUncheckedUpdateManyWithoutDependsOnNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockedNodeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NodeDependencyUpdateWithoutBlockedNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependsOnNode?: NodeUpdateOneRequiredWithoutOutgoingDepsNestedInput
  }

  export type NodeDependencyUncheckedUpdateWithoutBlockedNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    dependsOnNodeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NodeDependencyUncheckedUpdateManyWithoutBlockedNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    dependsOnNodeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KpiDefinitionUpdateWithoutPrimaryNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumKpiDirectionFieldUpdateOperationsInput | $Enums.KpiDirection
    aggregation?: EnumKpiAggregationMethodFieldUpdateOperationsInput | $Enums.KpiAggregationMethod
    periodType?: EnumKpiPeriodTypeFieldUpdateOperationsInput | $Enums.KpiPeriodType
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiDefinitionStatusFieldUpdateOperationsInput | $Enums.KpiDefinitionStatus
    org?: OrganizationUpdateOneRequiredWithoutKpisNestedInput
    ownerUser?: UserUpdateOneWithoutOwnedKpisNestedInput
    variables?: KpiVariableUpdateManyWithoutKpiNestedInput
    values?: KpiValuePeriodUpdateManyWithoutKpiNestedInput
  }

  export type KpiDefinitionUncheckedUpdateWithoutPrimaryNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumKpiDirectionFieldUpdateOperationsInput | $Enums.KpiDirection
    aggregation?: EnumKpiAggregationMethodFieldUpdateOperationsInput | $Enums.KpiAggregationMethod
    periodType?: EnumKpiPeriodTypeFieldUpdateOperationsInput | $Enums.KpiPeriodType
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiDefinitionStatusFieldUpdateOperationsInput | $Enums.KpiDefinitionStatus
    variables?: KpiVariableUncheckedUpdateManyWithoutKpiNestedInput
    values?: KpiValuePeriodUncheckedUpdateManyWithoutKpiNestedInput
  }

  export type KpiDefinitionUncheckedUpdateManyWithoutPrimaryNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    ownerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    formula?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    direction?: EnumKpiDirectionFieldUpdateOperationsInput | $Enums.KpiDirection
    aggregation?: EnumKpiAggregationMethodFieldUpdateOperationsInput | $Enums.KpiAggregationMethod
    periodType?: EnumKpiPeriodTypeFieldUpdateOperationsInput | $Enums.KpiPeriodType
    baselineValue?: NullableFloatFieldUpdateOperationsInput | number | null
    targetValue?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiDefinitionStatusFieldUpdateOperationsInput | $Enums.KpiDefinitionStatus
  }

  export type KpiVariableCreateManyKpiInput = {
    id?: string
    code: string
    displayName: string
    dataType: $Enums.KpiVariableDataType
    isRequired?: boolean
  }

  export type KpiValuePeriodCreateManyKpiInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    calculatedValue?: number | null
    status?: $Enums.KpiValueStatus
    note?: string | null
    enteredBy?: string | null
    approvedBy?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KpiVariableUpdateWithoutKpiInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    dataType?: EnumKpiVariableDataTypeFieldUpdateOperationsInput | $Enums.KpiVariableDataType
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    values?: KpiVariableValueUpdateManyWithoutKpiVariableNestedInput
  }

  export type KpiVariableUncheckedUpdateWithoutKpiInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    dataType?: EnumKpiVariableDataTypeFieldUpdateOperationsInput | $Enums.KpiVariableDataType
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    values?: KpiVariableValueUncheckedUpdateManyWithoutKpiVariableNestedInput
  }

  export type KpiVariableUncheckedUpdateManyWithoutKpiInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    dataType?: EnumKpiVariableDataTypeFieldUpdateOperationsInput | $Enums.KpiVariableDataType
    isRequired?: BoolFieldUpdateOperationsInput | boolean
  }

  export type KpiValuePeriodUpdateWithoutKpiInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiValueStatusFieldUpdateOperationsInput | $Enums.KpiValueStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enteredByUser?: UserUpdateOneWithoutKpiValuesEnteredNestedInput
    approvedByUser?: UserUpdateOneWithoutKpiValuesApprovedNestedInput
    variableValues?: KpiVariableValueUpdateManyWithoutKpiValueNestedInput
  }

  export type KpiValuePeriodUncheckedUpdateWithoutKpiInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiValueStatusFieldUpdateOperationsInput | $Enums.KpiValueStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    enteredBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variableValues?: KpiVariableValueUncheckedUpdateManyWithoutKpiValueNestedInput
  }

  export type KpiValuePeriodUncheckedUpdateManyWithoutKpiInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    calculatedValue?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumKpiValueStatusFieldUpdateOperationsInput | $Enums.KpiValueStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    enteredBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KpiVariableValueCreateManyKpiVariableInput = {
    id?: string
    kpiValueId: string
    value: number
  }

  export type KpiVariableValueUpdateWithoutKpiVariableInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    kpiValue?: KpiValuePeriodUpdateOneRequiredWithoutVariableValuesNestedInput
  }

  export type KpiVariableValueUncheckedUpdateWithoutKpiVariableInput = {
    id?: StringFieldUpdateOperationsInput | string
    kpiValueId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type KpiVariableValueUncheckedUpdateManyWithoutKpiVariableInput = {
    id?: StringFieldUpdateOperationsInput | string
    kpiValueId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type KpiVariableValueCreateManyKpiValueInput = {
    id?: string
    kpiVariableId: string
    value: number
  }

  export type KpiVariableValueUpdateWithoutKpiValueInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    kpiVariable?: KpiVariableUpdateOneRequiredWithoutValuesNestedInput
  }

  export type KpiVariableValueUncheckedUpdateWithoutKpiValueInput = {
    id?: StringFieldUpdateOperationsInput | string
    kpiVariableId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type KpiVariableValueUncheckedUpdateManyWithoutKpiValueInput = {
    id?: StringFieldUpdateOperationsInput | string
    kpiVariableId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}